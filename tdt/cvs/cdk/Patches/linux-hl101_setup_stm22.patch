diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/Makefile linux/arch/sh/boards/st/stb7109eref/Makefile
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/Makefile	Sun Feb 21 20:04:15 2010
--- linux/arch/sh/boards/st/stb7109eref/Makefile	Mon Feb 22 00:38:11 2010
***************
*** 1,5 ****
  #
! # Makefile for STMicroelectronics STb7109E Reference board
  #
  
! obj-y := setup.o mach.o
--- 1,5 ----
  #
! # Makefile for HL101
  #
  
! obj-y := setup.o mach.o epld.o
diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/epld.c linux/arch/sh/boards/st/stb7109eref/epld.c
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/epld.c	Thu Jan  1 02:00:00 1970
--- linux/arch/sh/boards/st/stb7109eref/epld.c	Mon Feb 22 00:38:11 2010
***************
*** 0 ****
--- 1,77 ----
+ /*
+  * Copyright (C) 2007 STMicroelectronics Limited
+  * Author: Stuart Menefy <stuart.menefy@st.com>
+  *
+  * May be copied or modified under the terms of the GNU General Public
+  * License.  See linux/COPYING for more information.
+  */
+ 
+ #include <linux/kernel.h>
+ #include <linux/platform_device.h>
+ #include <asm/io.h>
+ #include "epld.h"
+ 
+ #define DRIVER_NAME "epld"
+ 
+ static void __iomem *epld_base;
+ static int epld_opsize;
+ 
+ void epld_write(unsigned long value, unsigned long offset)
+ {
+ 	if (epld_opsize == 16)
+ 		writew(value, epld_base + offset);
+ 	else
+ 		writeb(value, epld_base + offset);
+ }
+ 
+ unsigned long epld_read(unsigned long offset)
+ {
+ 	if (epld_opsize == 16)
+ 		return readw(epld_base + offset);
+ 	else
+ 		return readb(epld_base + offset);
+ }
+ 
+ void __init epld_early_init(struct platform_device *pdev)
+ {
+ 	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+ 	struct plat_epld_data *data = pdev->dev.platform_data;
+ 
+ 	epld_base = ioremap(pdev->resource[0].start, size);
+ 	if (!epld_base)
+ 		panic("Unable to ioremap EPLD");
+ 
+ 	if (data) {
+ 		epld_opsize = data->opsize;
+ 	}
+ }
+ 
+ static int __init epld_probe(struct platform_device *pdev)
+ {
+ 	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+ 
+ 	if (!request_mem_region(pdev->resource[0].start, size, pdev->name))
+ 		return -EBUSY;
+ 
+ 	if (epld_base)
+ 		return 0;
+ 
+ 	epld_early_init(pdev);
+ 
+ 	return 0;
+ }
+ 
+ static struct platform_driver epld_driver = {
+ 	.probe		= epld_probe,
+ 	.driver	= {
+ 		.name	= DRIVER_NAME,
+ 		.owner	= THIS_MODULE,
+ 	},
+ };
+ 
+ static int __init epld_init(void)
+ {
+ 	return platform_driver_register(&epld_driver);
+ }
+ 
+ arch_initcall(epld_init);
diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/epld.h linux/arch/sh/boards/st/stb7109eref/epld.h
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/epld.h	Thu Jan  1 02:00:00 1970
--- linux/arch/sh/boards/st/stb7109eref/epld.h	Mon Feb 22 00:38:11 2010
***************
*** 0 ****
--- 1,15 ----
+ 
+ #define EPLD_FLASH              0x400000
+ 
+ #define EPLD_BASE               0x03000000
+ #define EPLD_SIZE               0x00800000
+ 
+ void epld_write(unsigned long value, unsigned long offset);
+ unsigned long epld_read(unsigned long offset);
+ void epld_early_init(struct platform_device *device);
+ 
+ void harp_init_irq(void);
+ 
+ struct plat_epld_data {
+ 	int opsize;
+ };
diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/mach.c linux/arch/sh/boards/st/stb7109eref/mach.c
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/mach.c	Sun Feb 21 20:04:15 2010
--- linux/arch/sh/boards/st/stb7109eref/mach.c	Mon Feb 22 00:38:11 2010
***************
*** 21,26 ****
--- 21,28 ----
  #include <asm/led.h>
  #include <asm/machvec_init.h>
  
+ #define ILC_EXT_MDINT           70
+ 
  static void __iomem *stb7109eref_ioport_map(unsigned long port, unsigned int size)
  {
  #ifdef CONFIG_BLK_DEV_ST40IDE
***************
*** 45,54 ****
  
  	/* Set the ILC to route external interrupts to the the INTC */
  	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
- 	ilc_route_external(70, 4, 1);	/* MDINT */
  	ilc_route_external(ILC_EXT_IRQ1, 5, 0);	/* VoIP */
  	ilc_route_external(ILC_EXT_IRQ2, 6, 0);	/* ATA */
! 	ilc_route_external(ILC_EXT_IRQ3, 7, 0);	/* SMC Ethernet */
  
  	make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
  	make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
--- 47,55 ----
  
  	/* Set the ILC to route external interrupts to the the INTC */
  	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
  	ilc_route_external(ILC_EXT_IRQ1, 5, 0);	/* VoIP */
  	ilc_route_external(ILC_EXT_IRQ2, 6, 0);	/* ATA */
! 	ilc_route_external(ILC_EXT_MDINT,7, 0);	/* STE10Xp */
  
  	make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
  	make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/setup.c linux/arch/sh/boards/st/stb7109eref/setup.c
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/setup.c	Sun Feb 21 20:04:15 2010
--- linux/arch/sh/boards/st/stb7109eref/setup.c	Mon Feb 22 19:19:32 2010
***************
*** 8,13 ****
--- 8,15 ----
   * License.  See linux/COPYING for more information.
   *
   * STMicroelectronics STb7109E Reference board support.
+  *
+  * The STb7109E code was adapted to HL-101 mainboard.
   */
  
  #include <linux/config.h>
***************
*** 16,28 ****
  #include <linux/stpio.h>
  #include <linux/st_soc.h>
  #include <linux/delay.h>
  #include <linux/platform_device.h>
  #include <linux/mtd/physmap.h>
  #include <asm/io.h>
  
! #include <linux/stm/710x_fdma.h>
  #include <linux/stm/7109_cut2_fdma2_firmware.h>
  #include <linux/stm/7109_cut3_fdma2_firmware.h>
  
  #define SYSCONF_BASE 0xb9001000
  #define SYSCONF_DEVICEID	(SYSCONF_BASE + 0x000)
--- 18,37 ----
  #include <linux/stpio.h>
  #include <linux/st_soc.h>
  #include <linux/delay.h>
+ #include <linux/bpa2.h>
  #include <linux/platform_device.h>
  #include <linux/mtd/physmap.h>
  #include <asm/io.h>
+ #include "epld.h"
+ 
+ #include <linux/stm/fdma-plat.h>
+ #include <linux/stm/fdma-reqs.h>
  
! #ifdef CONFIG_STM_DMA
! #include <linux/stm/7100_fdma2_firmware.h>
  #include <linux/stm/7109_cut2_fdma2_firmware.h>
  #include <linux/stm/7109_cut3_fdma2_firmware.h>
+ #endif
  
  #define SYSCONF_BASE 0xb9001000
  #define SYSCONF_DEVICEID	(SYSCONF_BASE + 0x000)
***************
*** 73,78 ****
--- 82,155 ----
  static void stb7109eth_hw_setup(void) { }
  #endif
  
+ #define ASC2_INTEN ((unsigned int*)(0xb8032010))
+ #define ASC3_INTEN ((unsigned int*)(0xb8033010))
+ #define ASC3BaseAddress 0xb8033000
+ #define ASC_TX_BUFF     0x004
+ #define ASC_INT_STA     0x014
+ #define ASC_INT_STA_THE   0x04
+ 
+ 
+ /* additional info:
+ 
+ LMI_SYS:
+ 0x04000000-0x07FFFFFF = 64MB RAM for linux
+ 
+ LMI_VID:
+ 0x10000000-0x103FFFFF = 4MB RAM for ST231-0 (video delta)
+ 0x10400000-0x107FFFFF = 4MB RAM for ST231-1 (audio delta)
+ 0x10800000-0x13FFFFFF = 56MB RAM for allocator
+ */
+ 
+ //FIXME
+ 
+ const char *LMI_VID_partalias[] = { "BPA2_Region1", "coredisplay-video", "v4l2-video-buffers", "gfx-memory", NULL };
+ const char *LMI_SYS_partalias[] = { "BPA2_Region0", "bigphysarea",  NULL };
+ 
+ static struct bpa2_partition_desc bpa2_parts_table[] = {
+         {
+                 .name  = "LMI_VID",
+                 .start = 0x10800000,
+                 .size  = 0x03800000,
+                 .flags = 0,
+                 .aka   = LMI_VID_partalias
+         },
+         {
+                 .name  = "LMI_SYS",
+                 .start = 0,
+                 .size  = 0x01600000,
+                 .flags = 0,
+                 .aka   = LMI_SYS_partalias
+         }
+ };
+ 
+ /* prototypes */
+ static void phy_reset(void* bus);
+ static void send_fp_byte(unsigned char Data);
+ static void system_power_off(void);
+ 
+ static void send_fp_byte(unsigned char Data)
+ {
+         unsigned char *ASC_3_TX_BUFF = (unsigned char*)(ASC3BaseAddress + ASC_TX_BUFF);
+         unsigned int *ASC_3_INT_STA = (unsigned int*)(ASC3BaseAddress + ASC_INT_STA);
+         unsigned long Counter = 100000;
+ 
+         while (((*ASC_3_INT_STA & ASC_INT_STA_THE) == 0) && --Counter);
+         *ASC_3_TX_BUFF = Data;
+ }
+ 
+ static void system_power_off(void)
+ {
+         send_fp_byte(0x02);
+         send_fp_byte(0x11);
+         send_fp_byte(0x81);
+         send_fp_byte(0x03);
+         send_fp_byte(0x02);
+         send_fp_byte(0x21);
+         send_fp_byte(0x01);
+         send_fp_byte(0x03);
+ }
+ 
  /*
   * Initialize the board
   */
***************
*** 80,99 ****
  {
  	unsigned long sysconf;
  	unsigned long chip_revision;
! 	static struct stpio_pin *ethreset;
  
! 	printk("STMicroelectronics STb7109E Reference board initialisation\n");
  
  	sysconf = ctrl_inl(SYSCONF_DEVICEID);
  	chip_revision = (sysconf >> 28) + 1;
  	printk("STb7109 version %ld.x\n", chip_revision);
  
  	/* Route UART2 instead of SCI to PIO4 */
  	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
  	/* Set SSC{0,1,2}_MUX_SEL = 0 */
  	sysconf &= ~(0xE);
  	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
  
  	/* Permanently enable Flash VPP */
  	{
  		static struct stpio_pin *pin;
--- 157,201 ----
  {
  	unsigned long sysconf;
  	unsigned long chip_revision;
! 	static struct stpio_pin *usbpower, *pin;
  
! 	printk("SpiderBox HL101 initialization\n");
  
  	sysconf = ctrl_inl(SYSCONF_DEVICEID);
  	chip_revision = (sysconf >> 28) + 1;
  	printk("STb7109 version %ld.x\n", chip_revision);
  
+ #if 0
  	/* Route UART2 instead of SCI to PIO4 */
  	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
  	/* Set SSC{0,1,2}_MUX_SEL = 0 */
  	sysconf &= ~(0xE);
+ #endif
+ 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+ 	/* SCIF_PIO_OUT_EN=0 */
+ 	/* Route UART2 and PWM to PIO4 instead of SCIF */
+ 	sysconf &= ~(1<<0);
+ 
+ 	/* Set SSC2_MUX_SEL = 0 */
+ 	/* Treat SSC2 as I2C instead of SSC */
+ 	sysconf &= ~(1<<3);
+ 
  	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
  
+ 	/* disable interrupts to prevent a system lockup */
+ 	printk("disabling ASC IRQ enable flags to prevent a lockup\n");
+ 	*ASC2_INTEN = *ASC2_INTEN & ~0x000001fe;
+ 	*ASC3_INTEN = *ASC3_INTEN & ~0x000001fe;
+ 
+ 	/* assign power-off function */
+ 	pm_power_off = system_power_off;
+ 
+ //FIXME
+ 	/* The Audio DAC uses GPIO pin 2-2 as an active-high
+ 	   mute signal */
+ 	//pin = stpio_request_pin(2, 2, "DACMUTE", STPIO_OUT);
+ 	//stpio_set_pin(pin, 1);
+ 
  	/* Permanently enable Flash VPP */
  	{
  		static struct stpio_pin *pin;
***************
*** 101,126 ****
  		stpio_set_pin(pin, 1);
  	}
  
! 	/* Reset the SMSC 91C111 Ethernet chip */
! 	ethreset = stpio_request_pin(2, 6, "SMSC_RST", STPIO_OUT);
! 	stpio_set_pin(ethreset, 0);
! 	udelay(1);
! 	stpio_set_pin(ethreset, 1);
! 	udelay(1);
! 	stpio_set_pin(ethreset, 0);
! 
! 	/* The ST40RTC sources its clock from clock */
! 	/* generator B */
! 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(8));
! 	ctrl_outl(sysconf | 0x2, SYSCONF_SYS_CFG(8));
  
  	/* Work around for USB over-current detection chip being
  	 * active low, and the 7109 being active high */
  	if (chip_revision < 2) {
  		static struct stpio_pin *pin;
  		pin = stpio_request_pin(5,6, "USBOC", STPIO_OUT);
  		stpio_set_pin(pin, 0);
  	}
  
  	/* Currently all STB1 chips have problems with the sleep instruction,
  	 * so disable it here.
--- 203,225 ----
  		stpio_set_pin(pin, 1);
  	}
  
! 	/* reset the PHY */
! 	phy_reset(NULL);
  
  	/* Work around for USB over-current detection chip being
  	 * active low, and the 7109 being active high */
+ #if 0
  	if (chip_revision < 2) {
  		static struct stpio_pin *pin;
  		pin = stpio_request_pin(5,6, "USBOC", STPIO_OUT);
  		stpio_set_pin(pin, 0);
  	}
+ #else
+ 	/* FIXME: not sure whether this is needed,
+ 	   it was taken over from the p0040 */
+ 	usbpower = stpio_request_pin(5,7, "USBPWR", STPIO_OUT);
+ 	stpio_set_pin(usbpower, 0);
+ #endif
  
  	/* Currently all STB1 chips have problems with the sleep instruction,
  	 * so disable it here.
***************
*** 129,144 ****
  
  	stb7109eth_hw_setup();
  
! 	/* Configure the pio pins for LIRC */
! 	stpio_request_pin(3, 3, "IR", STPIO_IN);
! 	stpio_request_pin(3, 4, "IR", STPIO_IN);
! 	stpio_request_pin(3, 5, "IR", STPIO_ALT_OUT);
! 	stpio_request_pin(3, 6, "IR", STPIO_ALT_OUT);
  }
  
  const char *get_system_type(void)
  {
! 	return "STb7109E Reference board";
  }
  
  static struct resource ssc_resource[] = {
--- 228,241 ----
  
  	stb7109eth_hw_setup();
  
!         printk("LOAD bpa2_parts_table\n");
!         bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
!         printk("END bpa2_parts_table\n");
  }
  
  const char *get_system_type(void)
  {
! 	return "Spider-Box HL101 board";
  }
  
  static struct resource ssc_resource[] = {
***************
*** 167,188 ****
  	       .end = 118,
  	       .flags = IORESOURCE_IRQ,
  	      },
  	[5] = {
  	       .start = 117,
  	       .end = 117,
  	       .flags = IORESOURCE_IRQ,
  	      },
  };
  
  static struct plat_ssc_pio_t ssc_pio[] = {
  	{2, 0, 2, 1, 0xff, 0xff},
! 	{3, 0, 3, 1, 3, 2},
  	{4, 0, 4, 1, 0xff, 0xff},
  };
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
  		(SSC_I2C_CAPABILITY << (0*2)) |
! 		((SSC_SPI_CAPABILITY | SSC_I2C_CAPABILITY) << (1*2)) |
  		(SSC_I2C_CAPABILITY << (2*2)),
  	.pio         = ssc_pio
  };
--- 264,287 ----
  	       .end = 118,
  	       .flags = IORESOURCE_IRQ,
  	      },
+ /*
  	[5] = {
  	       .start = 117,
  	       .end = 117,
  	       .flags = IORESOURCE_IRQ,
  	      },
+ */
  };
  
  static struct plat_ssc_pio_t ssc_pio[] = {
  	{2, 0, 2, 1, 0xff, 0xff},
! 	{3, 0, 3, 1, 0xff, 0xff},
  	{4, 0, 4, 1, 0xff, 0xff},
  };
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
  		(SSC_I2C_CAPABILITY << (0*2)) |
! 		(SSC_I2C_CAPABILITY << (1*2)) |
  		(SSC_I2C_CAPABILITY << (2*2)),
  	.pio         = ssc_pio
  };
***************
*** 195,227 ****
  		 .platform_data = &ssc_private_info
  	}
  };
  static struct plat_lirc_data lirc_private_info = {
  	/* For the 7100, the clock settings will be calculated by the driver
  	 * from the system clock
  	 */
  	.irbclock	= 0, /* use current_cpu data */
! 	.irbclkdiv	= 0, /* automatically calculate */
! 	.irbperiodmult	= 0,
! 	.irbperioddiv	= 0,
! 	.irbontimemult	= 0,
! 	.irbontimediv	= 0,
  	.irbrxmaxperiod = 0x5000,
! 	.irbversion	= 2,
! 	.sysclkdiv	= 2,
! 	.rxpolarity	= 1
! };
! 
! static struct resource smc91x_resources[] = {
! 	[0] = {
! 		.start	= 0xa2000300,
! 		.end	= 0xa2000300 + 0xff,
! 		.flags	= IORESOURCE_MEM,
! 	},
! 	[1] = {
! 		.start	= IRL3_IRQ,
! 		.end	= IRL3_IRQ,
! 		.flags	= IORESOURCE_IRQ,
! 	},
  };
  
  static struct resource st40_ohci_resources[] = {
--- 294,324 ----
  		 .platform_data = &ssc_private_info
  	}
  };
+ 
+ static struct lirc_pio lirc_pios[] = {
+ 	[0] = {
+ 		.bank = 3,
+ 		.pin  = 3,
+ 		.dir  = STPIO_IN
+ 	},
+ };
+ 
  static struct plat_lirc_data lirc_private_info = {
  	/* For the 7100, the clock settings will be calculated by the driver
  	 * from the system clock
  	 */
  	.irbclock	= 0, /* use current_cpu data */
! 	.irbclkdiv      = 0, /* automatically calculate */
! 	.irbperiodmult  = 0,
! 	.irbperioddiv   = 0,
! 	.irbontimemult  = 0,
! 	.irbontimediv   = 0,
  	.irbrxmaxperiod = 0x5000,
! 	.irbversion     = 2,
! 	.sysclkdiv	= 1,
! 	.rxpolarity	= 1,
! 	.pio_pin_arr  = lirc_pios,
! 	.num_pio_pins = ARRAY_SIZE(lirc_pios)
  };
  
  static struct resource st40_ohci_resources[] = {
***************
*** 237,242 ****
--- 334,340 ----
  			.flags = IORESOURCE_IRQ,
  	}
  };
+ 
  static struct resource st40_ehci_resources[] = {
  	/*now this for the ehci*/
  	[0] =  {
***************
*** 268,274 ****
  	.resource = wdt_resource,
  };
  
- 
  static struct resource lirc_resource[]= {
  	/* This is the main LIRC register block, as defined by the spec */
         [0] = {
--- 366,371 ----
***************
*** 308,326 ****
  	.resource = st40_ehci_resources,
  };
  
! static struct platform_device smc91x_device = {
! 	.name		= "smc91x",
! 	.id		= 0,
! 	.num_resources	= ARRAY_SIZE(smc91x_resources),
! 	.resource	= smc91x_resources,
! };
  
  static struct plat_stmmacenet_data eth7109_private_data = {
  	.bus_id = 0,
! 	.phy_addr = 14,
! 	.phy_mask = 1,
  	.phy_name = "ste100p",
! 	.pbl = 1,
  };
  
  static struct platform_device stb7109eth_device = {
--- 405,434 ----
  	.resource = st40_ehci_resources,
  };
  
! static void phy_reset(void* bus)
! {
! 	static struct stpio_pin *phyreset;
! 
! 	printk ("Resetting the network PHY\n");
! 
! 	if (phyreset == NULL) {
! 		phyreset = stpio_request_pin(3, 6, "Phy reset", STPIO_OUT);
! 	}
! 
! 	stpio_set_pin(phyreset, 1);
! 	udelay(1);
! 	stpio_set_pin(phyreset, 0);
! 	udelay(1000);
! 	stpio_set_pin(phyreset, 1);
! }
  
  static struct plat_stmmacenet_data eth7109_private_data = {
  	.bus_id = 0,
! 	.phy_addr = 0,
! 	.phy_mask = 0,
  	.phy_name = "ste100p",
! 	//.pbl = 1,
!         //.fix_mac_speed = fix_mac_speed,
  };
  
  static struct platform_device stb7109eth_device = {
***************
*** 351,375 ****
  	}
  };
  
- 
- static struct resource ste101p_resources[] = {
-         [0] = {
-                 .flags  = IORESOURCE_DISABLED,
-         },
-         [1] = {
-                 .start  = IRL0_IRQ,
-                 .end    = IRL0_IRQ,
-                 .flags  = IORESOURCE_IRQ,
-         },
- };
- 
- static struct platform_device ste101p_device = {
-         .name           = "ste101p",
-         .id             = 0,
-         .num_resources  = ARRAY_SIZE(ste101p_resources),
-         .resource       = ste101p_resources,
- };
- 
  static struct platform_device lirc_device = {
  	.name		= "lirc",
  	.id		= -1,
--- 459,464 ----
***************
*** 406,462 ****
  	}
  };
  
! static struct resource rtc_resource[]= {
! 	[0] = {
! 		.start = 0xffc80000,
! 		.end   = 0xffc80000 + 0x40,
! 		.flags = IORESOURCE_MEM
! 	},
! /* Be careful the
!  * arch/sh/kernel/cpu/irq_ipr.c
!  * must be update with the right value
!  */
! 	[1] = {
! 		.start = 20,/* Alarm IRQ   */
! 		.flags = IORESOURCE_IRQ
! 	},
! 	[2] = {
! 		.start = 21,/* Periodic IRQ*/
! 		.flags = IORESOURCE_IRQ
! 	},
! };
! static struct platform_device rtc_device = {
! 	.name		= "rtc",
! 	.id		= -1,
! 	.num_resources	= ARRAY_SIZE(rtc_resource),
! 	.resource	= rtc_resource,
! };
! 
! #ifdef CONFIG_MTD_PHYSMAP
! static struct mtd_partition mtd_parts_table[3] = {
  	{
! 	 .name = "Boot firmware",
! 	 .size = 0x00040000,
  	 .offset = 0x00000000,
  	 },
  	{
  	 .name = "Kernel",
! 	 .size = 0x00100000,
! 	 .offset = 0x00040000,
! 
  	 },
  	{
  	 .name = "Root FS",
! 	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
! 	 .offset = 0x00140000,
  	 }
  };
  
  static struct physmap_flash_data physmap_flash_data = {
! 	.width		= 2,
! 	.set_vpp	= NULL,
! 	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
! 	.parts		= mtd_parts_table
  };
  #define physmap_flash_data_addr &physmap_flash_data
  #else
--- 495,549 ----
  	}
  };
  
! #ifdef CONFIG_MTD_PARTITIONS
! static struct mtd_partition mtd_parts_table[] = {
  	{
! 	 .name = "Boot loader",
! 	 .size = 0x00030000,
  	 .offset = 0x00000000,
+ 	 .mask_flags = MTD_WRITEABLE
+ 	 },
+ 	{
+ 	 .name = "U-Boot",
+ 	 .size = 0x00020000,
+ 	 .offset = MTDPART_OFS_NXTBLK,
+ 	 .mask_flags = MTD_WRITEABLE
+ 	 },
+ 	{
+ 	 .name = "U-Boot settings",
+ 	 .size = 0x00010000,
+ 	 .offset = MTDPART_OFS_NXTBLK,
  	 },
  	{
  	 .name = "Kernel",
! 	 .size = 0x00010000,
! 	 .offset = MTDPART_OFS_NXTBLK
  	 },
  	{
  	 .name = "Root FS",
! 	 .size = MTDPART_SIZ_FULL,
! 	 .offset = MTDPART_OFS_NXTBLK
  	 }
  };
  
+ static void mtd_set_vpp(struct map_info *map, int vpp)
+ {
+ 	/* Bit 0: VPP enable
+ 	 * Bit 1: Reset (not used in later EPLD versions)
+ 	 */
+ 
+ 	if (vpp) {
+ 		epld_write(3, EPLD_FLASH);
+ 	} else {
+ 		epld_write(2, EPLD_FLASH);
+ 	}
+ }
+ 
  static struct physmap_flash_data physmap_flash_data = {
! 	.width          = 2,
! 	.set_vpp        = mtd_set_vpp,
! 	.nr_parts       = ARRAY_SIZE(mtd_parts_table),
! 	.parts          = mtd_parts_table
  };
  #define physmap_flash_data_addr &physmap_flash_data
  #else
***************
*** 464,526 ****
  #endif
  
  static struct resource physmap_flash_resource = {
! 	.start		= 0x00000000,
! 	.end		= 0x00800000 - 1,
! 	.flags		= IORESOURCE_MEM,
  };
  
  static struct platform_device physmap_flash = {
! 	.name		= "physmap-flash",
! 	.id		= -1,
! 	.dev		= {
! 		.platform_data	= physmap_flash_data_addr,
  	},
! 	.num_resources	= 1,
! 	.resource	= &physmap_flash_resource,
  };
  /*
! Re							RnW,    Opcode,  Transfer Incr addr,   Hold_off Initiator), */
! /*        						1-32   	cnt 1-4  On/Off       0-2        Used) */
! static  fdmareq_RequestConfig_t stb7109_fdma_req_config[]= {
! /*=========================== 7109 ============================================*/
! 
! /*  {  Req  RnW, 						Opcode,    TransferCount  Inc,       Hold_off        Initiator), */
! /*  {               						1-32       1-4            On/Off       0-2           Used) */
! /*0*/	{STB7109_FDMA_REQ_UNUSED,			UNUSED, UNUSED,    1,     	  UNUSED,      0,     	     1 },/* NOT CONNECTED */
! /*1*/	{STB7109_FDMA_DMA_REQ_HDMI_AVI,			READ,   OPCODE_8,  1,             DISABLE_FLG, 0,            1 },  /* Video HDMI */
! /*2*/	{STB7109_FDMA_REQ_DISEQC_HALF_EMPTY,		WRITE,  OPCODE_4,  2,             DISABLE_FLG, 0,            1 },  /* DiseqC half empty */
! /*3*/	{STB7109_FDMA_REQ_DISEQC_HALF_FULL,		READ,   OPCODE_4,  2,             DISABLE_FLG, 0,            1 },  /* DiseqC half full */
! /*4*/	{STB7109_FDMA_REQ_SH4_SCIF_RX,			READ,   OPCODE_4,  2,             DISABLE_FLG, 0,            1 },  /* SH4/SCIF */
! /*5*/	{STB7109_FDMA_REQ_SH4_SCIF_TX,			WRITE,  OPCODE_4,  2,             DISABLE_FLG, 0,            1 },  /* SH4/SCIF */
! /*6*/	{STB7109_FDMA_REQ_SSC_0_RX,			READ,   OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 0 rxbuff full */
! /*7*/	{STB7109_FDMA_REQ_SSC_1_RX,			READ,   OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 1 rxbuff full */
! /*8*/	{STB7109_FDMA_REQ_SSC_2_RX,			READ,   OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 2 rxbuff full */
! /*9*/	{STB7109_FDMA_REQ_SSC_0_TX,			WRITE,  OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 0 txbuff empty */
! /*10*/	{STB7109_FDMA_REQ_SSC_1_TX,			WRITE,  OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 1 txbuff empty */
! /*11*/	{STB7109_FDMA_REQ_SSC_2_TX,			WRITE,  OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 1 txbuff empty */
! /*12*/  {STB7109_FDMA_REQ_UART_0_RX,			READ,   OPCODE_1,  4,             DISABLE_FLG, 0,            1 },  /* UART 0 rx half full */
! /*13*/	{STB7109_FDMA_REQ_UART_1_RX,			READ,   OPCODE_1,  4,             DISABLE_FLG, 0,            1 },  /* UART 1 rx half full */
! /*14*/	{STB7109_FDMA_REQ_UART_2_RX,			READ,   OPCODE_1,  4,             DISABLE_FLG, 0,            1 },  /* UART 2 rx half full */
! /*15*/	{STB7109_FDMA_REQ_UART_3_RX,			READ,   OPCODE_1,  4,             DISABLE_FLG, 0,            1 },  /* UART 3 rx half full */
! /*16*/	{STB7109_FDMA_REQ_UART_0_TX,			WRITE,  OPCODE_1,  1,             DISABLE_FLG, 0,            1 },  /* UART 0 tx half empty */
! /*17*/	{STB7109_FDMA_REQ_UART_1_TX,			WRITE,  OPCODE_1,  1,             DISABLE_FLG, 0,            1 },  /* UART 1 tx half empty */
! /*18*/	{STB7109_FDMA_REQ_UART_2_TX,			WRITE,  OPCODE_1,  1,             DISABLE_FLG, 0,            1 },  /* UART 2 tx half emtpy */
! /*19*/	{STB7109_FDMA_REQ_UART_3_TX,			WRITE,  OPCODE_1,  1,             DISABLE_FLG, 0,            1 },  /* UART 3 tx half empty */
! /*20*/	{STB7109_FDMA_REQ_REQ_EXT_PIO_0,		READ,   OPCODE_4,  1,             DISABLE_FLG, 0,            1 },  /* External 0 (PIO2bit5) hi priority */
! /*21*/	{STB7109_FDMA_REQ_REQ_EXT_PIO_1,		READ,   OPCODE_4,  1,             DISABLE_FLG, 0,            1 },  /* External 1 (PIO2bit6) hi priority */
! /*22*/	{STB7109_FDMA_REQ_CPXM_DECRYPT,  	     	READ,   OPCODE_4,  4,             DISABLE_FLG, 0,            1 },  /* CPxM decrypted data request */
! /*23*/  {STB7109_FDMA_REQ_CPXM_ENCRYPT,  	     	WRITE,  OPCODE_4,  4,             DISABLE_FLG, 0,            1 },  /* CPxm encrypted data request */
! /*24*/	{STB7109_FDMA_REQ_PCM_0,			WRITE,  OPCODE_4,  1,             DISABLE_FLG, 0,            0 },  /* Audio PCM Player 0 */
! /*25*/	{STB7109_FDMA_REQ_PCM_1,			WRITE,  OPCODE_4,  1,             DISABLE_FLG, 0,            0 },  /* Audio PCM Player 1 */
! /*26*/	{STB7109_FDMA_REQ_PCM_READ,			READ,   OPCODE_4,  1,             DISABLE_FLG, 0,            0 },  /* Audio PCM Reader */
! /*27*/	{STB7109_FDMA_REQ_SPDIF,			WRITE,  OPCODE_4,  1,             DISABLE_FLG, 0,            0 },  /* Audio SPDIF - 2xST4*/
! /*29*/	{STB7109_FDMA_REQ_SWTS_0,			WRITE,  OPCODE_32, 1,             DISABLE_FLG, 0,            0 },  /* SWTS 0 */
! /*29*/	{STB7109_FDMA_REQ_SWTS_1,			WRITE,  OPCODE_32, 1,             DISABLE_FLG, 0,            0 },  /* SWTS 1 */
! /*30*/	{STB7109_FDMA_REQ_SWTS_2,			WRITE,  OPCODE_32, 1,             DISABLE_FLG, 0,            0 },  /* SWTS 2 */
! /*31*/  {STB7109_FDMA_REQ_UNUSED,           		UNUSED, UNUSED,    1,             UNUSED,      0,            0 },  /* Reserved */
  };
  
! static fdma_regs_t stb7109_fdma_regs = {
  	.fdma_id= FDMA2_ID,
  	.fdma_ver = FDAM2_VER,
  	.fdma_en = FDMA2_ENABLE_REG,
--- 551,624 ----
  #endif
  
  static struct resource physmap_flash_resource = {
! 	.start          = 0x00000000,
! 	.end            = 0x00800000 - 1,
! 	.flags          = IORESOURCE_MEM,
  };
  
  static struct platform_device physmap_flash = {
! 	.name           = "physmap-flash",
! 	.id             = -1,
! 	.dev            = {
! 	.platform_data  = physmap_flash_data_addr,
  	},
! 	.num_resources  = 1,
! 	.resource       = &physmap_flash_resource,
! };
! 
! static struct platform_device epld_device = {
!         .name           = "epld",
!         .id             = -1,
!         .num_resources  = 1,
!         .resource       = (struct resource[]) {
!                 {
!                         .start  = EPLD_BASE,
!                         .end    = EPLD_BASE + EPLD_SIZE - 1,
!                         .flags  = IORESOURCE_MEM,
!                 }
!         },
!         .dev.platform_data = &(struct plat_epld_data) {
!                  .opsize = 8,
!         },
  };
+ 
+ static struct platform_device boxtype_device = {
+         .name = "boxtype",
+         .dev.platform_data = (void*)100
+ };
+ 
+ #ifdef CONFIG_STM_DMA
+ 
  /*
!  *  FDMA parameters
!  */
! 
! static struct fdma_regs stb7100_fdma_regs = {
! 	 .fdma_id =     	  FDMA2_ID,
! 	 .fdma_ver = 		  FDAM2_VER,
! 	 .fdma_en= 		  FDMA2_ENABLE_REG,
! 	 .fdma_clk_gate = 	  FDMA2_CLOCKGATE,
! 	 .fdma_rev_id = 	  FDMA2_REV_ID,
! 	 .fdma_cmd_statn = 	  STB7100_FDMA_CMD_STATn_REG,
! 	 .fdma_ptrn = 		  STB7100_FDMA_PTR_REG,
! 	 .fdma_cntn = 		  STB7100_FDMA_COUNT_REG,
! 	 .fdma_saddrn = 	  STB7100_FDMA_SADDR_REG,
! 	 .fdma_daddrn = 	  STB7100_FDMA_DADDR_REG,
! 	 .fdma_req_ctln = 	  STB7100_FDMA_REQ_CTLn_REG,
! 	 .fdma_cmd_sta =	  FDMA2_CMD_MBOX_STAT_REG,
! 	 .fdma_cmd_set =	  FDMA2_CMD_MBOX_SET_REG,
! 	 .fdma_cmd_clr = 	  FDMA2_CMD_MBOX_CLR_REG,
! 	 .fdma_cmd_mask =	  FDMA2_CMD_MBOX_MASK_REG,
! 	 .fdma_int_sta = 	  FDMA2_INT_STAT_REG,
! 	 .fdma_int_set = 	  FDMA2_INT_SET_REG,
! 	 .fdma_int_clr= 	  FDMA2_INT_CLR_REG,
! 	 .fdma_int_mask= 	  FDMA2_INT_MASK_REG,
! 	 .fdma_sync_reg= 	  FDMA2_SYNCREG,
! 	 .fdma_dmem_region =  	  STB7100_DMEM_OFFSET,
! 	 .fdma_imem_region =  	  STB7100_IMEM_OFFSET,
  };
  
! static struct fdma_regs stb7109_fdma_regs = {
  	.fdma_id= FDMA2_ID,
  	.fdma_ver = FDAM2_VER,
  	.fdma_en = FDMA2_ENABLE_REG,
***************
*** 545,566 ****
  	.fdma_imem_region = STB7109_IMEM_OFFSET,
  };
  
- static struct fdma_platform_device_data stb7109_C1_fdma_plat_data ={
- 	.cpu_subtype = 7109,
- 	.cpu_rev = 1,
- };
- 
  static struct fdma_platform_device_data stb7109_C2_fdma_plat_data = {
! 	.req_line_tbl_adr = (void*)&stb7109_fdma_req_config,
! 	.registers_ptr =(void*) &stb7109_fdma_regs,
! 	.cpu_subtype = 7109,
! 	.cpu_rev = 2,
  	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
! 	.max_ch_num  =CONFIG_MAX_STM_DMA_CHANNEL_NR,
! 	.fdma_base  = STB7109_FDMA_BASE,
! 	.irq_vect = LINUX_FDMA_STB7109_IRQ_VECT,
! 	.fw_device_name = "STB7109_fdma_fw",
! 	.nr_reqlines = (sizeof(stb7109_fdma_req_config) / sizeof(fdmareq_RequestConfig_t)),
  	.fw.data_reg = (unsigned long*)&STB7109_C2_DMEM_REGION,
  	.fw.imem_reg = (unsigned long*)&STB7109_C2_IMEM_REGION,
  	.fw.imem_fw_sz = STB7109_C2_IMEM_FIRMWARE_SZ,
--- 643,653 ----
  	.fdma_imem_region = STB7109_IMEM_OFFSET,
  };
  
  static struct fdma_platform_device_data stb7109_C2_fdma_plat_data = {
! 	.registers_ptr = &stb7109_fdma_regs,
  	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
! 	.max_ch_num = CONFIG_MAX_STM_DMA_CHANNEL_NR,
! 	.fw_device_name = "stb7109_fdmav2.8.bin",
  	.fw.data_reg = (unsigned long*)&STB7109_C2_DMEM_REGION,
  	.fw.imem_reg = (unsigned long*)&STB7109_C2_IMEM_REGION,
  	.fw.imem_fw_sz = STB7109_C2_IMEM_FIRMWARE_SZ,
***************
*** 570,585 ****
  };
  
  static struct fdma_platform_device_data stb7109_C3_fdma_plat_data = {
- 	.req_line_tbl_adr = (void*)&stb7109_fdma_req_config,
  	.registers_ptr =(void*) &stb7109_fdma_regs,
- 	.cpu_subtype = 7109,
- 	.cpu_rev = 3,
  	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
  	.max_ch_num  =CONFIG_MAX_STM_DMA_CHANNEL_NR,
! 	.fdma_base  = STB7109_FDMA_BASE,
! 	.irq_vect = LINUX_FDMA_STB7109_IRQ_VECT,
! 	.fw_device_name = "STB7109_C3_fdma_fw",
! 	.nr_reqlines = (sizeof(stb7109_fdma_req_config) / sizeof(fdmareq_RequestConfig_t)),
  	.fw.data_reg = (unsigned long*)&STB7109_C3_DMEM_REGION,
  	.fw.imem_reg = (unsigned long*)&STB7109_C3_IMEM_REGION,
  	.fw.imem_fw_sz = STB7109_C3_IMEM_FIRMWARE_SZ,
--- 657,666 ----
  };
  
  static struct fdma_platform_device_data stb7109_C3_fdma_plat_data = {
  	.registers_ptr =(void*) &stb7109_fdma_regs,
  	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
  	.max_ch_num  =CONFIG_MAX_STM_DMA_CHANNEL_NR,
! 	.fw_device_name = "stb7109_fdmav3.0.bin",
  	.fw.data_reg = (unsigned long*)&STB7109_C3_DMEM_REGION,
  	.fw.imem_reg = (unsigned long*)&STB7109_C3_IMEM_REGION,
  	.fw.imem_fw_sz = STB7109_C3_IMEM_FIRMWARE_SZ,
***************
*** 589,637 ****
  
  };
  
  static struct platform_device fdma_710x_device = {
!         .name           = "710x_FDMA",
!         .id             = -1,
  };
  
  static struct resource alsa_710x_resource_pcm0[3] = {
  
  	[0] = {/* allocatable channels*/
! 		.start =2,
! 		.end   = 10,
  		.flags 	= IORESOURCE_IRQ
  	},
  	[1]= {/*fdma reqline*/
! 		.start = STB7109_FDMA_REQ_PCM_0,
! 		.end   = STB7109_FDMA_REQ_PCM_0,
  		.flags = IORESOURCE_IRQ
  	},
! 	[2] = {/*rising or falling edge I2s clocking*/
  		 /*.start = runtime dependant*/
  		 /*.end = runtime dependant*/
  		.flags = IORESOURCE_IRQ
! 	}};
! 
  
  static struct resource alsa_710x_resource_pcm1[3] = {
  
  	[0] = {/* allocatable channels*/
! 		.start = 2,
! 		.end   = 2,
  		.flags 	= IORESOURCE_IRQ,
  	},
  	[1]= {/*fdma reqline*/
! 		.start =STB7109_FDMA_REQ_PCM_1,
! 		.end   =STB7109_FDMA_REQ_PCM_1,
  		.flags = IORESOURCE_IRQ,
  	},
  	[2] = {/*rising or falling edge I2s clocking
! 		1 == FALLING_EDGE
! 		0 == RISING EDGE */
  		 /*.start = runtime dependant*/
  		 /*.end = runtime dependant*/
  		.flags = IORESOURCE_IRQ
! 	}};
  
  static struct resource alsa_710x_resource_spdif[2] = {
  
--- 670,775 ----
  
  };
  
+ static struct fdma_platform_device_data stb7100_Cx_fdma_plat_data = {
+ 	.registers_ptr =(void*) &stb7100_fdma_regs,
+ 	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
+ 	.max_ch_num  =CONFIG_MAX_STM_DMA_CHANNEL_NR,
+ 	.fw_device_name = "stb7100_fdmav2.8.bin",
+ 	.fw.data_reg = (unsigned long*)&STB7100_DMEM_REGION,
+ 	.fw.imem_reg = (unsigned long*)&STB7100_IMEM_REGION,
+ 	.fw.imem_fw_sz = STB7100_IMEM_FIRMWARE_SZ,
+ 	.fw.dmem_fw_sz = STB7100_DMEM_FIRMWARE_SZ,
+ 	.fw.dmem_len = STB7100_DMEM_REGION_LENGTH,
+ 	.fw.imem_len = STB7100_IMEM_REGION_LENGTH
+ };
+ 
+ #endif /* CONFIG_STM_DMA */
+ 
  static struct platform_device fdma_710x_device = {
! 	.name		= "stmfdma",
! 	.id		= -1,
! 	.num_resources	= 2,
! 	.resource = (struct resource[2]) {
! 		[0] = {
! 			.start = STB7100_FDMA_BASE,
! 			.end   = STB7100_FDMA_BASE + 0xffff,
! 			.flags = IORESOURCE_MEM,
! 		},
! 		[1] = {
! 			.start = LINUX_FDMA_STB7100_IRQ_VECT,
! 			.end   = LINUX_FDMA_STB7100_IRQ_VECT,
! 			.flags = IORESOURCE_IRQ,
! 		},
! 	},
  };
  
+ static void fdma_setup(int chip_7109, int chip_revision)
+ {
+ #ifdef CONFIG_STM_DMA
+ 	if(chip_7109){
+ 		switch (chip_revision) {
+ 		case 1:
+ 			BUG();
+ 			break;
+ 		case 2:
+ 			fdma_710x_device.dev.platform_data =(void*) &stb7109_C2_fdma_plat_data;
+ 			break;
+ 		default:
+ 			fdma_710x_device.dev.platform_data =(void*) &stb7109_C3_fdma_plat_data;
+ 			break;
+ 		}
+ 	} else {
+ 		/* 7100 */
+ 		fdma_710x_device.dev.platform_data =(void*) &stb7100_Cx_fdma_plat_data;
+ 	}
+ #endif
+ }
+ 
+ /*
+  * ALSA
+  */
+ 
  static struct resource alsa_710x_resource_pcm0[3] = {
  
  	[0] = {/* allocatable channels*/
! 		/*.start = runtime dependant*/
! 		/*.end   = runtime dependant*/
  		.flags 	= IORESOURCE_IRQ
  	},
  	[1]= {/*fdma reqline*/
! 		/*.start = runtime dependant*/
! 		/*.end   = runtime dependant*/
  		.flags = IORESOURCE_IRQ
  	},
! 	[2] = {/*rising or falling edge I2s clocking
! 		 1 == FALLING_EDGE
! 		 0 == RISING EDGE */
  		 /*.start = runtime dependant*/
  		 /*.end = runtime dependant*/
  		.flags = IORESOURCE_IRQ
! 	}
! };
  
  static struct resource alsa_710x_resource_pcm1[3] = {
  
  	[0] = {/* allocatable channels*/
! 		/*.start = runtime dependant*/
! 		/*.end   = runtime dependant*/
  		.flags 	= IORESOURCE_IRQ,
  	},
  	[1]= {/*fdma reqline*/
! 		/*.start = runtime dependant*/
! 		/*.end   = runtime dependant*/
  		.flags = IORESOURCE_IRQ,
  	},
  	[2] = {/*rising or falling edge I2s clocking
! 		 1 == FALLING_EDGE
! 		 0 == RISING EDGE */
  		 /*.start = runtime dependant*/
  		 /*.end = runtime dependant*/
  		.flags = IORESOURCE_IRQ
! 	}
! };
  
  static struct resource alsa_710x_resource_spdif[2] = {
  
***************
*** 641,663 ****
  		.flags = IORESOURCE_IRQ
  	},
  	[1] = {/*fdma reqline*/
! 		.start =STB7109_FDMA_REQ_SPDIF,
! 		.end   = STB7109_FDMA_REQ_SPDIF,
  		.flags = IORESOURCE_IRQ
! 	}};
  
  static struct resource alsa_710x_resource_cnv[2] = {
  
  	[0] = {/*min allocatable channels*/
! 		.start = 2,
  		.end   =10,
  		.flags = IORESOURCE_IRQ,
  	},
  	[1] = {/*fdma reqline*/
! 		.start = STB7109_FDMA_REQ_PCM_0,
! 		.end   = STB7109_FDMA_REQ_PCM_0,
  		.flags = IORESOURCE_IRQ,
! 	}};
  
  static struct resource alsa_710x_resource_pcmin[3] = {
  
--- 779,803 ----
  		.flags = IORESOURCE_IRQ
  	},
  	[1] = {/*fdma reqline*/
! 		/*.start = runtime dependant*/
! 		/*.end   = runtime dependant*/
  		.flags = IORESOURCE_IRQ
! 	}
! };
  
  static struct resource alsa_710x_resource_cnv[2] = {
  
  	[0] = {/*min allocatable channels*/
! 		.start = 10,
  		.end   =10,
  		.flags = IORESOURCE_IRQ,
  	},
  	[1] = {/*fdma reqline*/
! 		/*.start = runtime dependant*/
! 		/*.end   = runtime dependant*/
  		.flags = IORESOURCE_IRQ,
! 	}
! };
  
  static struct resource alsa_710x_resource_pcmin[3] = {
  
***************
*** 671,732 ****
  		/*.end   = runtime dependant*/
  		.flags = IORESOURCE_IRQ,
  	},
! 	[2] = {/*fdma reqline*/
  		/*.start = runtime dependant*/
  		/*.end   = runtime dependant*/
  		.flags = IORESOURCE_IRQ,
! 	}};
! 
  
  static struct platform_device alsa_710x_device_pcmin = {
  	.name			= "710x_ALSA_PCMIN",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_pcmin),
  	.resource		= alsa_710x_resource_pcmin,
  };
  
  static struct platform_device alsa_710x_device_pcm0 = {
  	.name			= "710x_ALSA_PCM0",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_pcm0),
  	.resource		= alsa_710x_resource_pcm0,
  };
  
- 
  static struct platform_device alsa_710x_device_pcm1 = {
  	.name			= "710x_ALSA_PCM1",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_pcm1),
  	.resource		= alsa_710x_resource_pcm1,
  };
  
  static struct platform_device alsa_710x_device_spdif = {
  	.name			= "710x_ALSA_SPD",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_spdif),
  	.resource		= alsa_710x_resource_spdif,
  };
  
  static struct platform_device alsa_710x_device_cnv = {
  	.name			= "710x_ALSA_CNV",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_cnv),
  	.resource		= alsa_710x_resource_cnv,
  };
  
  
  
! static struct platform_device *stb7109eref_devices[] __initdata = {
! 	&smc91x_device,
  	&stb7109eth_device,
- 	&ste101p_device,
  	&st40_ohci_devices,
  	&st40_ehci_devices,
  	&lirc_device,
  	&sata_device,
- 	&wdt_device,
  	&ssc_device,
- 	&rtc_device,
  	&physmap_flash,
  	&fdma_710x_device,
  	&alsa_710x_device_pcm0,
--- 811,973 ----
  		/*.end   = runtime dependant*/
  		.flags = IORESOURCE_IRQ,
  	},
! 	[2] = {/*rising or falling edge I2s clocking
! 		 1 == FALLING_EDGE
! 		 0 == RISING EDGE */
  		/*.start = runtime dependant*/
  		/*.end   = runtime dependant*/
  		.flags = IORESOURCE_IRQ,
! 	}
! };
  
  static struct platform_device alsa_710x_device_pcmin = {
  	.name			= "710x_ALSA_PCMIN",
! 	.id			= -1,
! 	.num_resources		= ARRAY_SIZE(alsa_710x_resource_pcmin),
  	.resource		= alsa_710x_resource_pcmin,
  };
  
  static struct platform_device alsa_710x_device_pcm0 = {
  	.name			= "710x_ALSA_PCM0",
! 	.id			= -1,
! 	.num_resources		= ARRAY_SIZE(alsa_710x_resource_pcm0),
  	.resource		= alsa_710x_resource_pcm0,
  };
  
  static struct platform_device alsa_710x_device_pcm1 = {
  	.name			= "710x_ALSA_PCM1",
! 	.id			= -1,
! 	.num_resources		= ARRAY_SIZE(alsa_710x_resource_pcm1),
  	.resource		= alsa_710x_resource_pcm1,
  };
  
  static struct platform_device alsa_710x_device_spdif = {
  	.name			= "710x_ALSA_SPD",
! 	.id			= -1,
! 	.num_resources		= ARRAY_SIZE(alsa_710x_resource_spdif),
  	.resource		= alsa_710x_resource_spdif,
  };
  
  static struct platform_device alsa_710x_device_cnv = {
  	.name			= "710x_ALSA_CNV",
! 	.id			= -1,
! 	.num_resources		= ARRAY_SIZE(alsa_710x_resource_cnv),
  	.resource		= alsa_710x_resource_cnv,
  };
  
+ static void alsa_setup(int chip_7109, int chip_revision)
+ {
+ 	if(chip_7109){
+ 
+ 		switch (chip_revision) {
+ 		case 1:
+ 			alsa_710x_resource_pcm0[2].start =0;
+ 			alsa_710x_resource_pcm0[2].end = 0;
+ 
+ 			alsa_710x_resource_pcm1[2].start =0;
+ 			alsa_710x_resource_pcm1[2].end = 0;
+ 
+ 			alsa_710x_resource_pcmin[2].start = 1;
+ 			alsa_710x_resource_pcmin[2].end =   1;
+ 			break;
+ 		case 2:
+ 			alsa_710x_resource_pcm0[2].start =0;
+ 			alsa_710x_resource_pcm0[2].end = 0;
+ 
+ 			alsa_710x_resource_pcm1[2].start =0;
+ 			alsa_710x_resource_pcm1[2].end = 0;
+ 
+ 			alsa_710x_resource_pcmin[2].start = 0;
+ 			alsa_710x_resource_pcmin[2].end =   0;
+ 			break;
+ 		default:
+ 			/* 7109 cut >= 3.0 */
+ 			alsa_710x_resource_pcm0[2].start =1;
+ 			alsa_710x_resource_pcm0[2].end = 1;
+ 
+ 			alsa_710x_resource_pcm1[2].start =1;
+ 			alsa_710x_resource_pcm1[2].end = 1;
+ 
+ 			alsa_710x_resource_pcmin[2].start = 0;
+ 			alsa_710x_resource_pcmin[2].end =   0;
+ 			break;
+ 		}
+ 
+ 		alsa_710x_resource_pcm0[0].start = 2;
+ 		alsa_710x_resource_pcm0[0].end = 10;
+ 
+ 		alsa_710x_resource_pcm1[0].start = 2;
+ 		alsa_710x_resource_pcm1[0].end 	= 2;
+ 
+ 		alsa_710x_resource_pcm0[1].start = STB7109_FDMA_REQ_PCM_0;
+ 		alsa_710x_resource_pcm0[1].end = STB7109_FDMA_REQ_PCM_0;
+ 
+ 		alsa_710x_resource_pcm1[1].start = STB7109_FDMA_REQ_PCM_1;
+ 		alsa_710x_resource_pcm1[1].end = STB7109_FDMA_REQ_PCM_1;
+ 
+ 		alsa_710x_resource_spdif[1].start = STB7109_FDMA_REQ_SPDIF;
+ 		alsa_710x_resource_spdif[1].end =   STB7109_FDMA_REQ_SPDIF;
+ 
+ 		alsa_710x_resource_cnv[0].start =2;
+ 		alsa_710x_resource_cnv[0].end = 10;
+ 		alsa_710x_resource_cnv[1].start = STB7109_FDMA_REQ_PCM_0;
+ 		alsa_710x_resource_cnv[1].end = STB7109_FDMA_REQ_PCM_0;
+ 
+ 		alsa_710x_resource_pcmin[1].start = STB7109_FDMA_REQ_PCM_READ;
+ 		alsa_710x_resource_pcmin[1].end =   STB7109_FDMA_REQ_PCM_READ;
+ 	} else {
+ 		/* 7100 */
+ 		if(chip_revision >=3){
+ 			alsa_710x_resource_pcm0[0].start = 2;
+ 			alsa_710x_resource_pcm0[0].end = 10;
+ 			alsa_710x_resource_pcm1[0].start =2;
+ 			alsa_710x_resource_pcm1[0].end 	= 2;
+ 			alsa_710x_resource_cnv[0].start =2;
+ 			alsa_710x_resource_cnv[0].end = 10;
+ 		}
+ 		else {
+ 			alsa_710x_resource_pcm0[0].start = 10;
+ 			alsa_710x_resource_pcm0[0].end = 10;
+ 			alsa_710x_resource_pcm1[0].start = 10;
+ 			alsa_710x_resource_pcm1[0].end 	= 10;
+ 			alsa_710x_resource_cnv[0].start =10;
+ 			alsa_710x_resource_cnv[0].end = 10;
+ 		}
+ 		alsa_710x_resource_pcm0[1].start = STB7100_FDMA_REQ_PCM_0;
+ 		alsa_710x_resource_pcm0[1].end = STB7100_FDMA_REQ_PCM_0;
+ 
+ 		alsa_710x_resource_pcm1[1].start = STB7100_FDMA_REQ_PCM_1;
+ 		alsa_710x_resource_pcm1[1].end = STB7100_FDMA_REQ_PCM_1;
+ 
+ 		alsa_710x_resource_spdif[1].start =  STB7100_FDMA_REQ_SPDIF;
+ 		alsa_710x_resource_spdif[1].end =  STB7100_FDMA_REQ_SPDIF;
+ 
+ 		alsa_710x_resource_cnv[1].start = STB7100_FDMA_REQ_PCM_0;
+ 		alsa_710x_resource_cnv[1].end = STB7100_FDMA_REQ_PCM_0;
  
+ 		alsa_710x_resource_pcmin[1].start = STB7100_FDMA_REQ_PCM_READ;
+ 		alsa_710x_resource_pcmin[1].end =   STB7100_FDMA_REQ_PCM_READ;
  
! 		alsa_710x_resource_pcm0[2].start =0;
! 		alsa_710x_resource_pcm0[2].end = 0;
! 
! 		alsa_710x_resource_pcm1[2].start =0;
! 		alsa_710x_resource_pcm1[2].end = 0;
! 
! 		alsa_710x_resource_pcmin[2].start = 0;
! 		alsa_710x_resource_pcmin[2].end =   0;
! 	}
! }
! 
! static struct platform_device *hl101_devices[] __initdata = {
! 	&epld_device,
! 	&boxtype_device,
  	&stb7109eth_device,
  	&st40_ohci_devices,
  	&st40_ehci_devices,
  	&lirc_device,
  	&sata_device,
  	&ssc_device,
  	&physmap_flash,
  	&fdma_710x_device,
  	&alsa_710x_device_pcm0,
***************
*** 762,831 ****
  			eth7109_private_data.pbl = 32;
  		}
  	}
- 	switch (chip_revision) {
- 	case 1:
- 		alsa_710x_resource_pcm0[2].start =0;
- 		alsa_710x_resource_pcm0[2].end = 0;
- 
- 		alsa_710x_resource_pcm0[2].start =0;
- 		alsa_710x_resource_pcm0[2].end = 0;
- 
- 		alsa_710x_resource_pcmin[2].start = 1;
- 		alsa_710x_resource_pcmin[2].end =   1;
- 
- 		fdma_710x_device.dev.platform_data = (void*)&stb7109_C1_fdma_plat_data;
- 		break;
- 	case 2:
- 		alsa_710x_resource_pcm0[2].start =0;
- 		alsa_710x_resource_pcm0[2].end = 0;
- 
- 		alsa_710x_resource_pcm0[2].start =0;
- 		alsa_710x_resource_pcm0[2].end = 0;
- 
- 		alsa_710x_resource_pcmin[2].start = 0;
- 		alsa_710x_resource_pcmin[2].end =   0;
- 		fdma_710x_device.dev.platform_data =(void*) &stb7109_C2_fdma_plat_data;
- 		break;
- 	default:
- 		/* 7109 cut >= 3.0 */
- 		BUG_ON(chip_revision < 2);
- 		alsa_710x_resource_pcm0[2].start =1;
- 		alsa_710x_resource_pcm0[2].end = 1;
- 
- 		alsa_710x_resource_pcm0[2].start =1;
- 		alsa_710x_resource_pcm0[2].end = 1;
- 
- 		alsa_710x_resource_pcmin[2].start = 0;
- 		alsa_710x_resource_pcmin[2].end =   0;
- 
- 		fdma_710x_device.dev.platform_data =(void*) &stb7109_C3_fdma_plat_data;
- 		break;
- 	}
- 
- 	alsa_710x_resource_pcm0[0].start = 2;
- 	alsa_710x_resource_pcm0[0].end = 10;
- 
- 	alsa_710x_resource_pcm1[0].start = 2;
- 	alsa_710x_resource_pcm1[0].end 	= 2;
- 
- 	alsa_710x_resource_pcm0[1].start = STB7109_FDMA_REQ_PCM_0;
- 	alsa_710x_resource_pcm0[1].end = STB7109_FDMA_REQ_PCM_0;
- 
- 	alsa_710x_resource_pcm1[1].start = STB7109_FDMA_REQ_PCM_1;
- 	alsa_710x_resource_pcm1[1].end = STB7109_FDMA_REQ_PCM_1;
- 
- 	alsa_710x_resource_spdif[1].start = STB7109_FDMA_REQ_SPDIF;
- 	alsa_710x_resource_spdif[1].end =   STB7109_FDMA_REQ_SPDIF;
- 
- 	alsa_710x_resource_cnv[0].start =10;
- 	alsa_710x_resource_cnv[0].end = 10;
- 	alsa_710x_resource_cnv[1].start = STB7109_FDMA_REQ_PCM_0;
- 	alsa_710x_resource_cnv[1].end = STB7109_FDMA_REQ_PCM_0;
  
! 	alsa_710x_resource_pcmin[1].start = STB7109_FDMA_REQ_PCM_READ;
! 	alsa_710x_resource_pcmin[1].end =   STB7109_FDMA_REQ_PCM_READ;
  
! 	ret = platform_add_devices(stb7109eref_devices, ARRAY_SIZE(stb7109eref_devices));
  	return ret;
  }
  
--- 1003,1013 ----
  			eth7109_private_data.pbl = 32;
  		}
  	}
  
! 	fdma_setup(1, chip_revision);
! 	alsa_setup(1, chip_revision);
  
! 	ret = platform_add_devices(hl101_devices, ARRAY_SIZE(hl101_devices));
  	return ret;
  }
  
