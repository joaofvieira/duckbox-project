diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/compat.h linux-sh4/drivers/media/dvb/dvb-core/compat.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/compat.h	Thu Jan  1 02:00:00 1970
--- linux-sh4/drivers/media/dvb/dvb-core/compat.h	Wed May 19 10:00:27 2010
***************
*** 0 ****
--- 1,242 ----
+ /*
+  * $Id: compat.h,v 1.44 2006/01/15 09:35:16 mchehab Exp $
+  */
+ 
+ #ifndef _COMPAT_H
+ #define _COMPAT_H
+ 
+ #include <linux/version.h>
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+ #define	KERN_CONT	""
+ #endif
+ 
+ /* To allow I2C compatibility code to work */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+ #include <linux/i2c-dev.h>
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+ #ifdef CONFIG_PROC_FS
+ #include <linux/module.h>
+ #include <linux/proc_fs.h>
+ #endif
+ #endif
+ 
+ /* To allow alsa code to work */
+ #ifdef NEED_SOUND_DRIVER_H
+ #include <sound/driver.h>
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+ #define set_freezable()
+ #define cancel_delayed_work_sync cancel_rearming_delayed_work
+ #endif
+ 
+ #ifndef __pure
+ #  define __pure __attribute__((pure))
+ #endif
+ 
+ #ifndef I2C_M_IGNORE_NAK
+ # define I2C_M_IGNORE_NAK 0x1000
+ #endif
+ 
+ /* device_create/destroy added in 2.6.18 */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+ /* on older kernels, class_device_create will in turn be a compat macro */
+ # define device_create(a, b, c, d, e, f, g) class_device_create(a, NULL, c, b, d, e, f, g)
+ # define device_destroy(a, b) class_device_destroy(a, b)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+ #define IRQF_SHARED		SA_SHIRQ
+ #define IRQF_DISABLED		SA_INTERRUPT
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+ #define DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))
+ #define PCIAGP_FAIL 0
+ #define vmalloc_32_user(a) vmalloc_32(a)
+ 
+ /* bool type and enum-based definition of true and false was added in 2.6.19 */
+ typedef int bool;
+ #define true 1
+ #define false 0
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+ #define sony_pic_camera_command(a,b) sonypi_camera_command(a,b)
+ 
+ #define SONY_PIC_COMMAND_SETCAMERAAGC        SONYPI_COMMAND_SETCAMERAAGC
+ #define SONY_PIC_COMMAND_SETCAMERABRIGHTNESS SONYPI_COMMAND_SETCAMERABRIGHTNESS
+ #define SONY_PIC_COMMAND_SETCAMERACOLOR      SONYPI_COMMAND_SETCAMERACOLOR
+ #define SONY_PIC_COMMAND_SETCAMERACONTRAST   SONYPI_COMMAND_SETCAMERACONTRAST
+ #define SONY_PIC_COMMAND_SETCAMERAHUE        SONYPI_COMMAND_SETCAMERAHUE
+ #define SONY_PIC_COMMAND_SETCAMERAPICTURE    SONYPI_COMMAND_SETCAMERAPICTURE
+ #define SONY_PIC_COMMAND_SETCAMERASHARPNESS  SONYPI_COMMAND_SETCAMERASHARPNESS
+ #define SONY_PIC_COMMAND_SETCAMERA           SONYPI_COMMAND_SETCAMERA
+ #endif
+ 
+ /* pci_dev got a new revision field in 2.6.23-rc1 */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) && defined(LINUX_PCI_H)
+ /* Just make it easier to subsitute pci_dev->revision with
+  * v4l_compat_pci_rev(pci_dev).  It's too bad there isn't some kind of context
+  * sensitive macro in C that could do this for us.  */
+ static inline u8 v4l_compat_pci_rev(struct pci_dev *pci)
+ { u8 rev; pci_read_config_byte(pci, PCI_REVISION_ID, &rev); return rev; }
+ #endif
+ 
+ #if defined(COMPAT_PCM_TO_RATE_BIT) && defined(__SOUND_PCM_H)
+ /* New alsa core utility function */
+ static inline unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate)
+ {
+ 	static const unsigned int rates[] = { 5512, 8000, 11025, 16000, 22050,
+ 		32000, 44100, 48000, 64000, 88200, 96000, 176400, 192000 };
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(rates); i++)
+ 		if (rates[i] == rate)
+ 			return 1u << i;
+ 	return SNDRV_PCM_RATE_KNOT;
+ }
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+ # define task_pid_nr(current) ((current)->pid)
+ 
+ # define sg_init_table(a,b)
+ # define sg_page(p) (sg->page)
+ # define sg_set_page(sglist,pg,sz,off)					\
+ do {									\
+ 	struct scatterlist *p=sglist;					\
+ 	p->page   = pg;							\
+ 	p->length = sz;							\
+ 	p->offset = off;						\
+ } while (0)
+ 
+ #define pr_err(fmt, arg...) \
+ 	printk(KERN_ERR fmt, ##arg)
+ #endif
+ 
+ #ifndef BIT_MASK
+ # define BIT_MASK(nr)            (1UL << ((nr) % BITS_PER_LONG))
+ # define BIT_WORD(nr)            ((nr) / BITS_PER_LONG)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+ #define i2c_verify_client(dev)	\
+ 	((dev->bus == &i2c_bus_type) ? to_i2c_client(dev) : NULL)
+ #elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+ #define i2c_verify_client(dev) \
+ 	((dev->bus && 0 == strcmp(dev->bus->name, "i2c")) ? to_i2c_client(dev) : NULL)
+ #endif
+ 
+ #ifndef USB_DEVICE_AND_INTERFACE_INFO
+ # define USB_DEVICE_AND_INTERFACE_INFO(vend,prod,cl,sc,pr) \
+ 	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
+ 		| USB_DEVICE_ID_MATCH_DEVICE, \
+ 	.idVendor = (vend), .idProduct = (prod), \
+ 	.bInterfaceClass = (cl), \
+ 	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+ #define get_unaligned_be16(a)					\
+ 	be16_to_cpu(get_unaligned((unsigned short *)(a)))
+ #define put_unaligned_be16(r, a)				\
+ 	put_unaligned(cpu_to_be16(r), ((unsigned short *)(a)))
+ #define get_unaligned_le16(a)					\
+ 	le16_to_cpu(get_unaligned((unsigned short *)(a)))
+ #define put_unaligned_le16(r, a)				\
+ 	put_unaligned(cpu_to_le16(r), ((unsigned short *)(a)))
+ #define get_unaligned_be32(a)					\
+ 	be32_to_cpu(get_unaligned((u32 *)(a)))
+ #define put_unaligned_be32(r, a)				\
+ 	put_unaligned(cpu_to_be32(r), ((u32 *)(a)))
+ #define get_unaligned_le32(a)					\
+ 	le32_to_cpu(get_unaligned((u32 *)(a)))
+ #define put_unaligned_le32(r, a)				\
+ 	put_unaligned(cpu_to_le32(r), ((u32 *)(a)))
+ #define get_unaligned_le64(a)					\
+ 	le64_to_cpu(get_unaligned((u64 *)(a)))
+ #define put_unaligned_le64(r, a)				\
+ 	put_unaligned(cpu_to_le64(r), ((u64 *)(a)))
+ #endif
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+ #ifdef CONFIG_PROC_FS
+ static inline struct proc_dir_entry *proc_create(const char *a,
+ 	mode_t b, struct proc_dir_entry *c, const struct file_operations *d)
+ {
+ 	struct proc_dir_entry *e;
+ 
+ 	e = create_proc_entry(a, b, c);
+ 	if (e) {
+ 		e->owner = THIS_MODULE;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
+ 		e->proc_fops = d;
+ #else
+ 		e->proc_fops = (struct file_operations *)d;
+ #endif
+ 	}
+ 	return e;
+ }
+ #endif
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+ #ifdef CONFIG_PROC_FS
+ static inline struct proc_dir_entry *proc_create_data(const char *a,
+ 	mode_t b, struct proc_dir_entry *c, const struct file_operations *d,
+ 	void *f)
+ {
+ 	struct proc_dir_entry *e;
+ 
+ 	e = create_proc_entry(a, b, c);
+ 	if (e) {
+ 		e->owner = THIS_MODULE;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
+ 		e->proc_fops = d;
+ #else
+ 		e->proc_fops = (struct file_operations *)d;
+ #endif
+ 		e->data = f;
+ 	}
+ 	return e;
+ }
+ #endif
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+ #define hweight64(x)  generic_hweight64(x)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+ #define div64_u64(a,b) div64_64(a,b)
+ 
+ #define clamp( x, l, h )        max_t( __typeof__( x ),		\
+ 				      ( l ),			\
+ 				      min_t( __typeof__( x ),	\
+ 					     ( h ),        	\
+ 					     ( x ) ) )
+ 
+ #define dev_name(dev)	((dev)->bus_id)
+ 
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+ typedef unsigned long uintptr_t;
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+ static inline int list_is_singular(const struct list_head *head)
+ {
+ 	return !list_empty(head) && (head->next == head->prev);
+ }
+ 
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27)
+ #define current_uid() (current->uid)
+ #endif
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/demux.h linux-sh4/drivers/media/dvb/dvb-core/demux.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/demux.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/demux.h	Wed May 19 10:00:27 2010
***************
*** 80,85 ****
--- 80,87 ----
  #define	TS_PAYLOAD_ONLY 2   /* in case TS_PACKET is set, only send the TS
  			       payload (<=184 bytes per packet) to callback */
  #define TS_DECODER      4   /* send stream to built-in decoder (if present) */
+ #define TS_DEMUX        8   /* in case TS_PACKET is set, send the TS to
+ 			       the demux device, not to the dvr device */
  
  /* PES type for filters which write to built-in decoder */
  /* these should be kept identical to the types in dmx.h */
***************
*** 245,251 ****
  	void* priv;                  /* Pointer to private data of the API client */
  	int (*open) (struct dmx_demux* demux);
  	int (*close) (struct dmx_demux* demux);
! 	int (*write) (struct dmx_demux* demux, const char* buf, size_t count);
  	int (*allocate_ts_feed) (struct dmx_demux* demux,
  				 struct dmx_ts_feed** feed,
  				 dmx_ts_cb callback);
--- 247,253 ----
  	void* priv;                  /* Pointer to private data of the API client */
  	int (*open) (struct dmx_demux* demux);
  	int (*close) (struct dmx_demux* demux);
! 	int (*write) (struct dmx_demux* demux, const char __user *buf, size_t count);
  	int (*allocate_ts_feed) (struct dmx_demux* demux,
  				 struct dmx_ts_feed** feed,
  				 dmx_ts_cb callback);
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dmxdev.c linux-sh4/drivers/media/dvb/dvb-core/dmxdev.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dmxdev.c	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dmxdev.c	Wed May 19 21:01:09 2010
***************
*** 20,30 ****
   *
   */
  
  #include <linux/spinlock.h>
  #include <linux/slab.h>
  #include <linux/vmalloc.h>
  #include <linux/module.h>
- #include <linux/moduleparam.h>
  #include <linux/poll.h>
  #include <linux/ioctl.h>
  #include <linux/wait.h>
--- 20,30 ----
   *
   */
  
+ #include <linux/sched.h>
  #include <linux/spinlock.h>
  #include <linux/slab.h>
  #include <linux/vmalloc.h>
  #include <linux/module.h>
  #include <linux/poll.h>
  #include <linux/ioctl.h>
  #include <linux/wait.h>
***************
*** 97,103 ****
  		if (avail > todo)
  			avail = todo;
  
! 		ret = dvb_ringbuffer_read(src, (u8 *)buf, avail, 1);
  		if (ret < 0)
  			break;
  
--- 97,103 ----
  		if (avail > todo)
  			avail = todo;
  
! 		ret = dvb_ringbuffer_read_user(src, buf, avail);
  		if (ret < 0)
  			break;
  
***************
*** 127,133 ****
  	struct dmxdev *dmxdev = dvbdev->priv;
  	struct dmx_frontend *front;
  
! 	dprintk("function : %s\n", __FUNCTION__);
  
  	if (mutex_lock_interruptible(&dmxdev->mutex))
  		return -ERESTARTSYS;
--- 127,133 ----
  	struct dmxdev *dmxdev = dvbdev->priv;
  	struct dmx_frontend *front;
  
! 	dprintk("function : %s\n", __func__);
  
  	if (mutex_lock_interruptible(&dmxdev->mutex))
  		return -ERESTARTSYS;
***************
*** 245,263 ****
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dmxdev *dmxdev = dvbdev->priv;
- 	int ret;
  
! 	if (dmxdev->exit) {
! 		mutex_unlock(&dmxdev->mutex);
  		return -ENODEV;
- 	}
  
! 	//mutex_lock(&dmxdev->mutex);
! 	ret = dvb_dmxdev_buffer_read(&dmxdev->dvr_buffer,
! 				     file->f_flags & O_NONBLOCK,
! 				     buf, count, ppos);
! 	//mutex_unlock(&dmxdev->mutex);
! 	return ret;
  }
  
  static inline void dvb_dmxdev_filter_state_set(struct dmxdev_filter
--- 245,290 ----
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dmxdev *dmxdev = dvbdev->priv;
  
! 	if (dmxdev->exit)
  		return -ENODEV;
  
! 	return dvb_dmxdev_buffer_read(&dmxdev->dvr_buffer,
! 				      file->f_flags & O_NONBLOCK,
! 				      buf, count, ppos);
! }
! 
! static int dvb_dvr_set_buffer_size(struct dmxdev *dmxdev,
! 				      unsigned long size)
! {
! 	struct dvb_ringbuffer *buf = &dmxdev->dvr_buffer;
! 	void *newmem;
! 	void *oldmem;
! 
! 	dprintk("function : %s\n", __func__);
! 
! 	if (buf->size == size)
! 		return 0;
! 	if (!size)
! 		return -EINVAL;
! 
! 	newmem = vmalloc(size);
! 	if (!newmem)
! 		return -ENOMEM;
! 
! 	oldmem = buf->data;
! 
! 	spin_lock_irq(&dmxdev->lock);
! 	buf->data = newmem;
! 	buf->size = size;
! 
! 	/* reset and not flush in case the buffer shrinks */
! 	dvb_ringbuffer_reset(buf);
! 	spin_unlock_irq(&dmxdev->lock);
! 
! 	vfree(oldmem);
! 
! 	return 0;
  }
  
  static inline void dvb_dmxdev_filter_state_set(struct dmxdev_filter
***************
*** 272,299 ****
  				      unsigned long size)
  {
  	struct dvb_ringbuffer *buf = &dmxdevfilter->buffer;
! 	void *mem;
  
  	if (buf->size == size)
  		return 0;
  	if (dmxdevfilter->state >= DMXDEV_STATE_GO)
  		return -EBUSY;
  	spin_lock_irq(&dmxdevfilter->dev->lock);
! 	mem = buf->data;
! 	buf->data = NULL;
  	buf->size = size;
! 	dvb_ringbuffer_flush(buf);
  	spin_unlock_irq(&dmxdevfilter->dev->lock);
- 	vfree(mem);
  
! 	if (buf->size) {
! 		mem = vmalloc(dmxdevfilter->buffer.size);
! 		if (!mem)
! 			return -ENOMEM;
! 		spin_lock_irq(&dmxdevfilter->dev->lock);
! 		buf->data = mem;
! 		spin_unlock_irq(&dmxdevfilter->dev->lock);
! 	}
  	return 0;
  }
  
--- 299,330 ----
  				      unsigned long size)
  {
  	struct dvb_ringbuffer *buf = &dmxdevfilter->buffer;
! 	void *newmem;
! 	void *oldmem;
  
  	if (buf->size == size)
  		return 0;
+ 	if (!size)
+ 		return -EINVAL;
  	if (dmxdevfilter->state >= DMXDEV_STATE_GO)
  		return -EBUSY;
+ 
+ 	newmem = vmalloc(size);
+ 	if (!newmem)
+ 		return -ENOMEM;
+ 
+ 	oldmem = buf->data;
+ 
  	spin_lock_irq(&dmxdevfilter->dev->lock);
! 	buf->data = newmem;
  	buf->size = size;
! 
! 	/* reset and not flush in case the buffer shrinks */
! 	dvb_ringbuffer_reset(buf);
  	spin_unlock_irq(&dmxdevfilter->dev->lock);
  
! 	vfree(oldmem);
! 
  	return 0;
  }
  
***************
*** 375,381 ****
  		return 0;
  	}
  
! 	if (dmxdevfilter->params.pes.output == DMX_OUT_TAP)
  		buffer = &dmxdevfilter->buffer;
  	else
  		buffer = &dmxdevfilter->dev->dvr_buffer;
--- 406,413 ----
  		return 0;
  	}
  
! 	if (dmxdevfilter->params.pes.output == DMX_OUT_TAP
! 	    || dmxdevfilter->params.pes.output == DMX_OUT_TSDEMUX_TAP)
  		buffer = &dmxdevfilter->buffer;
  	else
  		buffer = &dmxdevfilter->dev->dvr_buffer;
***************
*** 399,404 ****
--- 431,438 ----
  /* stop feed but only mark the specified filter as stopped (state set) */
  static int dvb_dmxdev_feed_stop(struct dmxdev_filter *dmxdevfilter)
  {
+ 	struct dmxdev_feed *feed;
+ 
  	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);
  
  	switch (dmxdevfilter->type) {
***************
*** 407,413 ****
  		dmxdevfilter->feed.sec->stop_filtering(dmxdevfilter->feed.sec);
  		break;
  	case DMXDEV_TYPE_PES:
! 		dmxdevfilter->feed.ts->stop_filtering(dmxdevfilter->feed.ts);
  		break;
  	default:
  		return -EINVAL;
--- 441,448 ----
  		dmxdevfilter->feed.sec->stop_filtering(dmxdevfilter->feed.sec);
  		break;
  	case DMXDEV_TYPE_PES:
! 		list_for_each_entry(feed, &dmxdevfilter->feed.ts, next)
! 			feed->ts->stop_filtering(feed->ts);
  		break;
  	default:
  		return -EINVAL;
***************
*** 418,430 ****
  /* start feed associated with the specified filter */
  static int dvb_dmxdev_feed_start(struct dmxdev_filter *filter)
  {
  	dvb_dmxdev_filter_state_set(filter, DMXDEV_STATE_GO);
  
  	switch (filter->type) {
  	case DMXDEV_TYPE_SEC:
  		return filter->feed.sec->start_filtering(filter->feed.sec);
  	case DMXDEV_TYPE_PES:
! 		return filter->feed.ts->start_filtering(filter->feed.ts);
  	default:
  		return -EINVAL;
  	}
--- 453,475 ----
  /* start feed associated with the specified filter */
  static int dvb_dmxdev_feed_start(struct dmxdev_filter *filter)
  {
+ 	struct dmxdev_feed *feed;
+ 	int ret;
+ 
  	dvb_dmxdev_filter_state_set(filter, DMXDEV_STATE_GO);
  
  	switch (filter->type) {
  	case DMXDEV_TYPE_SEC:
  		return filter->feed.sec->start_filtering(filter->feed.sec);
  	case DMXDEV_TYPE_PES:
! 		list_for_each_entry(feed, &filter->feed.ts, next) {
! 			ret = feed->ts->start_filtering(feed->ts);
! 			if (ret < 0) {
! 				dvb_dmxdev_feed_stop(filter);
! 				return ret;
! 			}
! 		}
! 		break;
  	default:
  		return -EINVAL;
  	}
***************
*** 456,461 ****
--- 501,509 ----
  
  static int dvb_dmxdev_filter_stop(struct dmxdev_filter *dmxdevfilter)
  {
+ 	struct dmxdev_feed *feed;
+ 	struct dmx_demux *demux;
+ 
  	if (dmxdevfilter->state < DMXDEV_STATE_GO)
  		return 0;
  
***************
*** 472,484 ****
  		dmxdevfilter->feed.sec = NULL;
  		break;
  	case DMXDEV_TYPE_PES:
- 		if (!dmxdevfilter->feed.ts)
- 			break;
  		dvb_dmxdev_feed_stop(dmxdevfilter);
! 		dmxdevfilter->dev->demux->
! 		    release_ts_feed(dmxdevfilter->dev->demux,
! 				    dmxdevfilter->feed.ts);
! 		dmxdevfilter->feed.ts = NULL;
  		break;
  	default:
  		if (dmxdevfilter->state == DMXDEV_STATE_ALLOCATED)
--- 520,531 ----
  		dmxdevfilter->feed.sec = NULL;
  		break;
  	case DMXDEV_TYPE_PES:
  		dvb_dmxdev_feed_stop(dmxdevfilter);
! 		demux = dmxdevfilter->dev->demux;
! 		list_for_each_entry(feed, &dmxdevfilter->feed.ts, next) {
! 			demux->release_ts_feed(demux, feed->ts);
! 			feed->ts = NULL;
! 		}
  		break;
  	default:
  		if (dmxdevfilter->state == DMXDEV_STATE_ALLOCATED)
***************
*** 490,508 ****
--- 537,624 ----
  	return 0;
  }
  
+ static void dvb_dmxdev_delete_pids(struct dmxdev_filter *dmxdevfilter)
+ {
+ 	struct dmxdev_feed *feed, *tmp;
+ 
+ 	/* delete all PIDs */
+ 	list_for_each_entry_safe(feed, tmp, &dmxdevfilter->feed.ts, next) {
+ 		list_del(&feed->next);
+ 		kfree(feed);
+ 	}
+ 
+ 	BUG_ON(!list_empty(&dmxdevfilter->feed.ts));
+ }
+ 
  static inline int dvb_dmxdev_filter_reset(struct dmxdev_filter *dmxdevfilter)
  {
  	if (dmxdevfilter->state < DMXDEV_STATE_SET)
  		return 0;
  
+ 	if (dmxdevfilter->type == DMXDEV_TYPE_PES)
+ 		dvb_dmxdev_delete_pids(dmxdevfilter);
+ 
  	dmxdevfilter->type = DMXDEV_TYPE_NONE;
  	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);
  	return 0;
  }
  
+ static int dvb_dmxdev_start_feed(struct dmxdev *dmxdev,
+ 				 struct dmxdev_filter *filter,
+ 				 struct dmxdev_feed *feed)
+ {
+ 	struct timespec timeout = { 0 };
+ 	struct dmx_pes_filter_params *para = &filter->params.pes;
+ 	dmx_output_t otype;
+ 	int ret;
+ 	int ts_type;
+ 	enum dmx_ts_pes ts_pes;
+ 	struct dmx_ts_feed *tsfeed;
+ 
+ 	feed->ts = NULL;
+ 	otype = para->output;
+ 
+ 	ts_pes = (enum dmx_ts_pes)para->pes_type;
+ 
+ 	if (ts_pes < DMX_PES_OTHER)
+ 		ts_type = TS_DECODER;
+ 	else
+ 		ts_type = 0;
+ 
+ 	if (otype == DMX_OUT_TS_TAP)
+ 		ts_type |= TS_PACKET;
+ 	else if (otype == DMX_OUT_TSDEMUX_TAP)
+ 		ts_type |= TS_PACKET | TS_DEMUX;
+ 	else if (otype == DMX_OUT_TAP)
+ 		ts_type |= TS_PACKET | TS_DEMUX | TS_PAYLOAD_ONLY;
+ 
+ 	ret = dmxdev->demux->allocate_ts_feed(dmxdev->demux, &feed->ts,
+ 					      dvb_dmxdev_ts_callback);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	tsfeed = feed->ts;
+ 	tsfeed->priv = filter;
+ 
+ 	ret = tsfeed->set(tsfeed, feed->pid, ts_type, ts_pes, 32768, timeout);
+ 	if (ret < 0) {
+ 		dmxdev->demux->release_ts_feed(dmxdev->demux, tsfeed);
+ 		return ret;
+ 	}
+ 
+ 	ret = tsfeed->start_filtering(tsfeed);
+ 	if (ret < 0) {
+ 		dmxdev->demux->release_ts_feed(dmxdev->demux, tsfeed);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static int dvb_dmxdev_filter_start(struct dmxdev_filter *filter)
  {
  	struct dmxdev *dmxdev = filter->dev;
+ 	struct dmxdev_feed *feed;
  	void *mem;
  	int ret, i;
  
***************
*** 551,557 ****
  								   dvb_dmxdev_section_callback);
  			if (ret < 0) {
  				printk("DVB (%s): could not alloc feed\n",
! 				       __FUNCTION__);
  				return ret;
  			}
  
--- 667,673 ----
  								   dvb_dmxdev_section_callback);
  			if (ret < 0) {
  				printk("DVB (%s): could not alloc feed\n",
! 				       __func__);
  				return ret;
  			}
  
***************
*** 559,565 ****
  					      (para->flags & DMX_CHECK_CRC) ? 1 : 0);
  			if (ret < 0) {
  				printk("DVB (%s): could not set feed\n",
! 				       __FUNCTION__);
  				dvb_dmxdev_feed_restart(filter);
  				return ret;
  			}
--- 675,681 ----
  					      (para->flags & DMX_CHECK_CRC) ? 1 : 0);
  			if (ret < 0) {
  				printk("DVB (%s): could not set feed\n",
! 				       __func__);
  				dvb_dmxdev_feed_restart(filter);
  				return ret;
  			}
***************
*** 600,655 ****
  		break;
  	}
  	case DMXDEV_TYPE_PES:
! 	{
! 		struct timespec timeout = { 0 };
! 		struct dmx_pes_filter_params *para = &filter->params.pes;
! 		dmx_output_t otype;
! 		int ret;
! 		int ts_type;
! 		enum dmx_ts_pes ts_pes;
! 		struct dmx_ts_feed **tsfeed = &filter->feed.ts;
! 
! 		filter->feed.ts = NULL;
! 		otype = para->output;
! 
! 		ts_pes = (enum dmx_ts_pes)para->pes_type;
! 
! 		if (ts_pes < DMX_PES_OTHER)
! 			ts_type = TS_DECODER;
! 		else
! 			ts_type = 0;
! 
! 		if (otype == DMX_OUT_TS_TAP)
! 			ts_type |= TS_PACKET;
! 
! 		if (otype == DMX_OUT_TAP)
! 			ts_type |= TS_PAYLOAD_ONLY | TS_PACKET;
! 
! 		ret = dmxdev->demux->allocate_ts_feed(dmxdev->demux,
! 						      tsfeed,
! 						      dvb_dmxdev_ts_callback);
! 		if (ret < 0)
! 			return ret;
! 
! 		(*tsfeed)->priv = filter;
! 
! 		ret = (*tsfeed)->set(*tsfeed, para->pid, ts_type, ts_pes,
! 				     32768, timeout);
! 		if (ret < 0) {
! 			dmxdev->demux->release_ts_feed(dmxdev->demux,
! 						       *tsfeed);
! 			return ret;
! 		}
! 
! 		ret = filter->feed.ts->start_filtering(filter->feed.ts);
! 		if (ret < 0) {
! 			dmxdev->demux->release_ts_feed(dmxdev->demux,
! 						       *tsfeed);
! 			return ret;
  		}
- 
  		break;
- 	}
  	default:
  		return -EINVAL;
  	}
--- 716,729 ----
  		break;
  	}
  	case DMXDEV_TYPE_PES:
! 		list_for_each_entry(feed, &filter->feed.ts, next) {
! 			ret = dvb_dmxdev_start_feed(dmxdev, filter, feed);
! 			if (ret < 0) {
! 				dvb_dmxdev_filter_stop(filter);
! 				return ret;
! 			}
  		}
  		break;
  	default:
  		return -EINVAL;
  	}
***************
*** 687,693 ****
  	dvb_ringbuffer_init(&dmxdevfilter->buffer, NULL, 8192);
  	dmxdevfilter->type = DMXDEV_TYPE_NONE;
  	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);
- 	dmxdevfilter->feed.ts = NULL;
  	init_timer(&dmxdevfilter->timer);
  
  	dvbdev->users++;
--- 761,766 ----
***************
*** 729,739 ****
  		filter->mode[i] ^= 0xff;
  }
  
  static int dvb_dmxdev_filter_set(struct dmxdev *dmxdev,
  				 struct dmxdev_filter *dmxdevfilter,
  				 struct dmx_sct_filter_params *params)
  {
! 	dprintk("function : %s\n", __FUNCTION__);
  
  	dvb_dmxdev_filter_stop(dmxdevfilter);
  
--- 802,861 ----
  		filter->mode[i] ^= 0xff;
  }
  
+ static int dvb_dmxdev_add_pid(struct dmxdev *dmxdev,
+ 			      struct dmxdev_filter *filter, u16 pid)
+ {
+ 	struct dmxdev_feed *feed;
+ 
+ 	if ((filter->type != DMXDEV_TYPE_PES) ||
+ 	    (filter->state < DMXDEV_STATE_SET))
+ 		return -EINVAL;
+ 
+ 	/* only TS packet filters may have multiple PIDs */
+ 	if ((filter->params.pes.output != DMX_OUT_TSDEMUX_TAP) &&
+ 	    (!list_empty(&filter->feed.ts)))
+ 		return -EINVAL;
+ 
+ 	feed = kzalloc(sizeof(struct dmxdev_feed), GFP_KERNEL);
+ 	if (feed == NULL)
+ 		return -ENOMEM;
+ 
+ 	feed->pid = pid;
+ 	list_add(&feed->next, &filter->feed.ts);
+ 
+ 	if (filter->state >= DMXDEV_STATE_GO)
+ 		return dvb_dmxdev_start_feed(dmxdev, filter, feed);
+ 
+ 	return 0;
+ }
+ 
+ static int dvb_dmxdev_remove_pid(struct dmxdev *dmxdev,
+ 				  struct dmxdev_filter *filter, u16 pid)
+ {
+ 	struct dmxdev_feed *feed, *tmp;
+ 
+ 	if ((filter->type != DMXDEV_TYPE_PES) ||
+ 	    (filter->state < DMXDEV_STATE_SET))
+ 		return -EINVAL;
+ 
+ 	list_for_each_entry_safe(feed, tmp, &filter->feed.ts, next) {
+ 		if ((feed->pid == pid) && (feed->ts != NULL)) {
+ 			feed->ts->stop_filtering(feed->ts);
+ 			filter->dev->demux->release_ts_feed(filter->dev->demux,
+ 							    feed->ts);
+ 			list_del(&feed->next);
+ 			kfree(feed);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static int dvb_dmxdev_filter_set(struct dmxdev *dmxdev,
  				 struct dmxdev_filter *dmxdevfilter,
  				 struct dmx_sct_filter_params *params)
  {
! 	dprintk("function : %s\n", __func__);
  
  	dvb_dmxdev_filter_stop(dmxdevfilter);
  
***************
*** 753,759 ****
--- 875,884 ----
  				     struct dmxdev_filter *dmxdevfilter,
  				     struct dmx_pes_filter_params *params)
  {
+ 	int ret;
+ 
  	dvb_dmxdev_filter_stop(dmxdevfilter);
+ 	dvb_dmxdev_filter_reset(dmxdevfilter);
  
  	if (params->pes_type > DMX_PES_OTHER || params->pes_type < 0)
  		return -EINVAL;
***************
*** 761,769 ****
--- 886,900 ----
  	dmxdevfilter->type = DMXDEV_TYPE_PES;
  	memcpy(&dmxdevfilter->params, params,
  	       sizeof(struct dmx_pes_filter_params));
+ 	INIT_LIST_HEAD(&dmxdevfilter->feed.ts);
  
  	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);
  
+ 	ret = dvb_dmxdev_add_pid(dmxdev, dmxdevfilter,
+ 				 dmxdevfilter->params.pes.pid);
+ 	if (ret < 0)
+ 		return ret;
+ 
  	if (params->flags & DMX_IMMEDIATE_START)
  		return dvb_dmxdev_filter_start(dmxdevfilter);
  
***************
*** 927,932 ****
--- 1058,1081 ----
  					     &((struct dmx_stc *)parg)->base);
  		break;
  
+ 	case DMX_ADD_PID:
+ 		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+ 			ret = -ERESTARTSYS;
+ 			break;
+ 		}
+ 		ret = dvb_dmxdev_add_pid(dmxdev, dmxdevfilter, *(u16 *)parg);
+ 		mutex_unlock(&dmxdevfilter->mutex);
+ 		break;
+ 
+ 	case DMX_REMOVE_PID:
+ 		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+ 			ret = -ERESTARTSYS;
+ 			break;
+ 		}
+ 		ret = dvb_dmxdev_remove_pid(dmxdev, dmxdevfilter, *(u16 *)parg);
+ 		mutex_unlock(&dmxdevfilter->mutex);
+ 		break;
+ 
  	default:
  		ret = -EINVAL;
  		break;
***************
*** 987,993 ****
  	return ret;
  }
  
! static struct file_operations dvb_demux_fops = {
  	.owner = THIS_MODULE,
  	.read = dvb_demux_read,
  	.ioctl = dvb_demux_ioctl,
--- 1136,1142 ----
  	return ret;
  }
  
! static const struct file_operations dvb_demux_fops = {
  	.owner = THIS_MODULE,
  	.read = dvb_demux_read,
  	.ioctl = dvb_demux_ioctl,
***************
*** 1008,1013 ****
--- 1157,1163 ----
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dmxdev *dmxdev = dvbdev->priv;
+ 	unsigned long arg = (unsigned long)parg;
  	int ret;
  
  	if (mutex_lock_interruptible(&dmxdev->mutex))
***************
*** 1015,1022 ****
  
  	switch (cmd) {
  	case DMX_SET_BUFFER_SIZE:
! 		// FIXME: implement
! 		ret = 0;
  		break;
  
  	default:
--- 1165,1171 ----
  
  	switch (cmd) {
  	case DMX_SET_BUFFER_SIZE:
! 		ret = dvb_dvr_set_buffer_size(dmxdev, arg);
  		break;
  
  	default:
***************
*** 1039,1045 ****
  	struct dmxdev *dmxdev = dvbdev->priv;
  	unsigned int mask = 0;
  
! 	dprintk("function : %s\n", __FUNCTION__);
  
  	poll_wait(file, &dmxdev->dvr_buffer.queue, wait);
  
--- 1188,1194 ----
  	struct dmxdev *dmxdev = dvbdev->priv;
  	unsigned int mask = 0;
  
! 	dprintk("function : %s\n", __func__);
  
  	poll_wait(file, &dmxdev->dvr_buffer.queue, wait);
  
***************
*** 1055,1061 ****
  	return mask;
  }
  
! static struct file_operations dvb_dvr_fops = {
  	.owner = THIS_MODULE,
  	.read = dvb_dvr_read,
  	.write = dvb_dvr_write,
--- 1204,1210 ----
  	return mask;
  }
  
! static const struct file_operations dvb_dvr_fops = {
  	.owner = THIS_MODULE,
  	.read = dvb_dvr_read,
  	.write = dvb_dvr_write,
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dmxdev.h linux-sh4/drivers/media/dvb/dvb-core/dmxdev.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dmxdev.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dmxdev.h	Wed May 19 21:01:25 2010
***************
*** 53,65 ****
  	DMXDEV_STATE_TIMEDOUT
  };
  
  struct dmxdev_filter {
  	union {
  		struct dmx_section_filter *sec;
  	} filter;
  
  	union {
! 		struct dmx_ts_feed *ts;
  		struct dmx_section_feed *sec;
  	} feed;
  
--- 53,72 ----
  	DMXDEV_STATE_TIMEDOUT
  };
  
+ struct dmxdev_feed {
+ 	u16 pid;
+ 	struct dmx_ts_feed *ts;
+ 	struct list_head next;
+ };
+ 
  struct dmxdev_filter {
  	union {
  		struct dmx_section_filter *sec;
  	} filter;
  
  	union {
! 		/* list of TS and PES feeds (struct dmxdev_feed) */
! 		struct list_head ts;
  		struct dmx_section_feed *sec;
  	} feed;
  
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_ca_en50221.c linux-sh4/drivers/media/dvb/dvb-core/dvb_ca_en50221.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	Wed May 19 22:04:01 2010
***************
*** 37,54 ****
  #include <linux/delay.h>
  #include <linux/spinlock.h>
  #include <linux/sched.h>
  
  #include "dvb_ca_en50221.h"
  #include "dvb_ringbuffer.h"
  
! static int dvb_ca_en50221_debug;
  
  module_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);
  MODULE_PARM_DESC(cam_debug, "enable verbose debug messages");
  
  #define dprintk if (dvb_ca_en50221_debug) printk
  
! #define INIT_TIMEOUT_SECS 10
  
  #define HOST_LINK_BUF_SIZE 0x200
  
--- 37,56 ----
  #include <linux/delay.h>
  #include <linux/spinlock.h>
  #include <linux/sched.h>
+ #include <linux/proc_fs.h>
  
  #include "dvb_ca_en50221.h"
  #include "dvb_ringbuffer.h"
  
! static int dvb_ca_en50221_debug = 0;
  
  module_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);
  MODULE_PARM_DESC(cam_debug, "enable verbose debug messages");
  
  #define dprintk if (dvb_ca_en50221_debug) printk
  
! static int INIT_TIMEOUT_SECS = 10;
! static int WAIT_FREE_TIMEOUT_SECS = 3;
  
  #define HOST_LINK_BUF_SIZE 0x200
  
***************
*** 114,121 ****
--- 116,151 ----
  	/* buffer for incoming packets */
  	struct dvb_ringbuffer rx_buffer;
  
+ 	/* wait queues for read() and write() operations */
+ 	wait_queue_head_t wait_queue;
+ 
  	/* timer used during various states of the slot */
  	unsigned long timeout;
+ 
+ 	struct proc_dir_entry* entry;
+ 
+ 	int	errorWaitReady;
+ 	int	errorStateValidate;
+ 	int	errorConfigOption;
+ 	int	errorWriteCamControl;
+ 	int	errorWaitFree;
+ 	int	errorInit;
+ 	int	errorRxBuffer;
+ 	int	errorLinkBufferSize;
+ 	int	errorLinkBufferSizeToSmall;
+ 	int	errorBufferEcount;
+ 
+ 	int	ignoreStateValidate;
+ 	int 	ignoreConfigOption;
+ 	int	ignoreWriteCamControl;
+ 	int 	ignoreWaitFree;
+ 	int	ignoreInit;
+ 
+ 	int	pollTime;
+ 
+ 	int	waitWrite;
+ 	int	camPollin;
+ 	int	camPollout;
  };
  
  /* Private CA-interface information */
***************
*** 127,132 ****
--- 157,165 ----
  	/* the DVB device */
  	struct dvb_device *dvbdev;
  
+ 	struct dvb_device *dvbdev_ci[2];
+ 	int slot_states[2];
+ 
  	/* Flags describing the interface (DVB_CA_FLAG_*) */
  	u32 flags;
  
***************
*** 145,150 ****
--- 178,188 ----
  	/* Wait queue used when shutting thread down */
  	wait_queue_head_t thread_queue;
  
+ 	/* dagobert: since we have multiple (logical) devices
+ 	 * we should protect them
+ 	 */
+ 	struct mutex io_mutex;
+ 
  	/* Flag indicating when thread should exit */
  	unsigned int exit:1;
  
***************
*** 165,170 ****
--- 203,212 ----
  static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca, int slot, u8 * ebuf, int ecount);
  static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca, int slot, u8 * ebuf, int ecount);
  
+ struct proc_dir_entry*  ci_dir;
+ 
+ struct dvb_ca_slot *ci0;
+ struct dvb_ca_slot *ci1;
  
  /**
   * Safely find needle in haystack.
***************
*** 175,181 ****
   * @param nlen Number of bytes in needle.
   * @return Pointer into haystack needle was found at, or NULL if not found.
   */
! static char *findstr(char * haystack, int hlen, char * needle, int nlen)
  {
  	int i;
  
--- 217,223 ----
   * @param nlen Number of bytes in needle.
   * @return Pointer into haystack needle was found at, or NULL if not found.
   */
! static u8 *findstr(u8 * haystack, int hlen, u8 * needle, int nlen)
  {
  	int i;
  
***************
*** 190,201 ****
  	return NULL;
  }
  
- 
- 
  /* ******************************************************************************** */
  /* EN50221 physical interface functions */
  
- 
  /**
   * Check CAM status.
   */
--- 232,240 ----
***************
*** 238,244 ****
  	return cam_changed;
  }
  
- 
  /**
   * Wait for flags to become set on the STATUS register on a CAM interface,
   * checking for errors and timeout.
--- 277,282 ----
***************
*** 288,294 ****
  	return -ETIMEDOUT;
  }
  
- 
  /**
   * Initialise the link layer connection to a CAM.
   *
--- 326,331 ----
***************
*** 368,375 ****
  	/* grab the next tuple length and type */
  	if ((_tupleType = ca->pub->read_attribute_mem(ca->pub, slot, _address)) < 0)
  		return _tupleType;
  	if (_tupleType == 0xff) {
! 		dprintk("END OF CHAIN TUPLE type:0x%x\n", _tupleType);
  		*address += 2;
  		*tupleType = _tupleType;
  		*tupleLength = 0;
--- 405,413 ----
  	/* grab the next tuple length and type */
  	if ((_tupleType = ca->pub->read_attribute_mem(ca->pub, slot, _address)) < 0)
  		return _tupleType;
+ 
  	if (_tupleType == 0xff) {
! 		dprintk("END OF CHAIN TUPLE type (%d) :0x%x\n", slot,_tupleType);
  		*address += 2;
  		*tupleType = _tupleType;
  		*tupleLength = 0;
***************
*** 397,403 ****
  	return 0;
  }
  
- 
  /**
   * Parse attribute memory of a CAM module, extracting Config register, and checking
   * it is a DVB CAM module.
--- 435,440 ----
***************
*** 422,428 ****
  	u16 manfid = 0;
  	u16 devid = 0;
  
- 
  	// CISTPL_DEVICE_0A
  	if ((status =
  	     dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)
--- 459,464 ----
***************
*** 430,437 ****
  	if (tupleType != 0x1D)
  		return -EINVAL;
  
- 
- 
  	// CISTPL_DEVICE_0C
  	if ((status =
  	     dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)
--- 466,471 ----
***************
*** 439,446 ****
  	if (tupleType != 0x1C)
  		return -EINVAL;
  
- 
- 
  	// CISTPL_VERS_1
  	if ((status =
  	     dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)
--- 473,478 ----
***************
*** 448,455 ****
  	if (tupleType != 0x15)
  		return -EINVAL;
  
- 
- 
  	// CISTPL_MANFID
  	if ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,
  						&tupleLength, tuple)) < 0)
--- 480,485 ----
***************
*** 461,468 ****
  	manfid = (tuple[1] << 8) | tuple[0];
  	devid = (tuple[3] << 8) | tuple[2];
  
- 
- 
  	// CISTPL_CONFIG
  	if ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,
  						&tupleLength, tuple)) < 0)
--- 491,496 ----
***************
*** 482,488 ****
  	}
  
  	/* check it contains the correct DVB string */
! 	dvb_str = findstr((char *)tuple, tupleLength, "DVB_CI_V", 8);
  	if (dvb_str == NULL)
  		return -EINVAL;
  	if (tupleLength < ((dvb_str - (char *) tuple) + 12))
--- 510,516 ----
  	}
  
  	/* check it contains the correct DVB string */
! 	dvb_str = findstr(tuple, tupleLength, "DVB_CI_V", 8);
  	if (dvb_str == NULL)
  		return -EINVAL;
  	if (tupleLength < ((dvb_str - (char *) tuple) + 12))
***************
*** 513,520 ****
  			ca->slot_info[slot].config_option = tuple[0] & 0x3f;
  
  			/* OK, check it contains the correct strings */
! 			if ((findstr((char *)tuple, tupleLength, "DVB_HOST", 8) == NULL) ||
! 			    (findstr((char *)tuple, tupleLength, "DVB_CI_MODULE", 13) == NULL))
  				break;
  
  			got_cftableentry = 1;
--- 541,548 ----
  			ca->slot_info[slot].config_option = tuple[0] & 0x3f;
  
  			/* OK, check it contains the correct strings */
! 			if ((findstr(tuple, tupleLength, "DVB_HOST", 8) == NULL) ||
! 			    (findstr(tuple, tupleLength, "DVB_CI_MODULE", 13) == NULL))
  				break;
  
  			got_cftableentry = 1;
***************
*** 544,550 ****
  	return 0;
  }
  
- 
  /**
   * Set CAM's configoption correctly.
   *
--- 572,577 ----
***************
*** 572,578 ****
  
  }
  
- 
  /**
   * This function talks to an EN50221 CAM control interface. It reads a buffer of
   * data from the CAM. The data can either be stored in a supplied buffer, or
--- 599,604 ----
***************
*** 593,599 ****
  	u8 buf[HOST_LINK_BUF_SIZE];
  	int i;
  
! 	dprintk("%s\n", __FUNCTION__);
  
  	/* check if we have space for a link buf in the rx_buffer */
  	if (ebuf == NULL) {
--- 619,628 ----
  	u8 buf[HOST_LINK_BUF_SIZE];
  	int i;
  
! 	/*dprintk("%s\n", __FUNCTION__);*/
! 
! 	/* dagobert */
!         mutex_lock(&ca->io_mutex);
  
  	/* check if we have space for a link buf in the rx_buffer */
  	if (ebuf == NULL) {
***************
*** 616,621 ****
--- 645,681 ----
  		goto exit;
  	if (!(status & STATUSREG_DA)) {
  		/* no data */
+ 
+ #ifdef mit
+ 
+ //if I try this next time I must remove
+ //I must think about the data to send
+ //byte[0] is not the connection I think
+ //byte[0] must be 0xa0 ?!?!?
+ 
+ 		/* so poll it */
+ 
+ 		/* dagobert: poll
+ 		 * ->see Spec Page 69 A.4.1.12
+ 		 * ->not sure if we meet all the parts in the spec (100ms ...)
+ 		 */
+ 		char fragbuf[HOST_LINK_BUF_SIZE];
+ 
+ 		fragbuf[0] = slot + 1 /* connection_id */;
+ 		fragbuf[1] = 0x00;
+ 		fragbuf[2] = 0xa0;
+ 		fragbuf[3] = 0x01 /* len */ ;
+ 		fragbuf[4] = slot + 1 /* connection_id */;
+ 
+ 		status = dvb_ca_en50221_write_data(ca, slot, fragbuf, 5);
+ 
+ 		if (status == 5)
+ 		{
+ 			dprintk("POLL Module %d\n", slot);
+ 		} else
+ 			printk("POLL FAILED for Module %d\n", slot);
+ 
+ #endif
  		status = 0;
  		goto exit;
  	}
***************
*** 631,643 ****
  	/* check it will fit */
  	if (ebuf == NULL) {
  		if (bytes_read > ca->slot_info[slot].link_buf_size) {
! 			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i)!\n",
! 			       ca->dvbdev->adapter->num, bytes_read, ca->slot_info[slot].link_buf_size);
  			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  			status = -EIO;
  			goto exit;
  		}
  		if (bytes_read < 2) {
  			printk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n",
  			       ca->dvbdev->adapter->num);
  			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
--- 691,707 ----
  	/* check it will fit */
  	if (ebuf == NULL) {
  		if (bytes_read > ca->slot_info[slot].link_buf_size) {
! 			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i) slot = %d!\n",
! 			       ca->dvbdev->adapter->num, bytes_read, ca->slot_info[slot].link_buf_size, slot);
  			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+ 			//Dagobert
+ 			ca->slot_info[slot].errorLinkBufferSize++;
  			status = -EIO;
  			goto exit;
  		}
  		if (bytes_read < 2) {
+ 			//Dagobert
+ 			ca->slot_info[slot].errorLinkBufferSizeToSmall++;
  			printk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n",
  			       ca->dvbdev->adapter->num);
  			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
***************
*** 646,653 ****
  		}
  	} else {
  		if (bytes_read > ecount) {
! 			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size!\n",
! 			       ca->dvbdev->adapter->num);
  			status = -EIO;
  			goto exit;
  		}
--- 710,718 ----
  		}
  	} else {
  		if (bytes_read > ecount) {
! 			ca->slot_info[slot].errorBufferEcount++;
! 			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size (slot = %d)!\n",
! 			       ca->dvbdev->adapter->num, slot);
  			status = -EIO;
  			goto exit;
  		}
***************
*** 667,672 ****
--- 732,738 ----
  	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
  		goto exit;
  	if (status & STATUSREG_RE) {
+ 		printk("read on slot %d failed ->state now linkinit\n", slot);
  		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  		status = -EIO;
  		goto exit;
***************
*** 688,702 ****
  
  	/* wake up readers when a last_fragment is received */
  	if ((buf[1] & 0x80) == 0x00) {
  		wake_up_interruptible(&ca->wait_queue);
  	}
  	status = bytes_read;
  
  exit:
  	return status;
  }
  
- 
  /**
   * This function talks to an EN50221 CAM control interface. It writes a buffer of data
   * to a CAM.
--- 754,771 ----
  
  	/* wake up readers when a last_fragment is received */
  	if ((buf[1] & 0x80) == 0x00) {
+ 		wake_up_interruptible(&ca->slot_info[slot].wait_queue);
  		wake_up_interruptible(&ca->wait_queue);
  	}
  	status = bytes_read;
  
  exit:
+ 	/* dagobert */
+         mutex_unlock(&ca->io_mutex);
+ 
  	return status;
  }
  
  /**
   * This function talks to an EN50221 CAM control interface. It writes a buffer of data
   * to a CAM.
***************
*** 716,725 ****
  
  	dprintk("%s\n", __FUNCTION__);
  
- 
  	// sanity check
  	if (bytes_write > ca->slot_info[slot].link_buf_size)
  		return -EINVAL;
  
  	/* check if interface is actually waiting for us to read from it, or if a read is in progress */
  	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
--- 785,799 ----
  
  	dprintk("%s\n", __FUNCTION__);
  
  	// sanity check
  	if (bytes_write > ca->slot_info[slot].link_buf_size)
+ 	{
+ 		printk("3. EINVAL\n");
  		return -EINVAL;
+ 	}
+ 
+ 	/* dagobert */
+         mutex_lock(&ca->io_mutex);
  
  	/* check if interface is actually waiting for us to read from it, or if a read is in progress */
  	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
***************
*** 760,765 ****
--- 834,840 ----
  	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
  		goto exit;
  	if (status & STATUSREG_WE) {
+ 		printk("write on slot %d failed ->state now linkinit\n", slot);
  		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  		status = -EIO;
  		goto exit;
***************
*** 773,784 ****
  	ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);
  
  exitnowrite:
  	return status;
  }
  EXPORT_SYMBOL(dvb_ca_en50221_camchange_irq);
  
- 
- 
  /* ******************************************************************************** */
  /* EN50221 higher level functions */
  
--- 848,860 ----
  	ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);
  
  exitnowrite:
+ 	/* dagobert */
+         mutex_unlock(&ca->io_mutex);
+ 
  	return status;
  }
  EXPORT_SYMBOL(dvb_ca_en50221_camchange_irq);
  
  /* ******************************************************************************** */
  /* EN50221 higher level functions */
  
***************
*** 791,803 ****
   */
  static int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)
  {
! 	dprintk("%s\n", __FUNCTION__);
  
  	ca->pub->slot_shutdown(ca->pub, slot);
  	ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
  
  	/* need to wake up all processes to check if they're now
  	   trying to write to a defunct CAM */
  	wake_up_interruptible(&ca->wait_queue);
  
  	dprintk("Slot %i shutdown\n", slot);
--- 867,880 ----
   */
  static int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)
  {
! 	dprintk("%s (slot %d)\n", __FUNCTION__, slot);
  
  	ca->pub->slot_shutdown(ca->pub, slot);
  	ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
  
  	/* need to wake up all processes to check if they're now
  	   trying to write to a defunct CAM */
+ 	wake_up_interruptible(&ca->slot_info[slot].wait_queue);
  	wake_up_interruptible(&ca->wait_queue);
  
  	dprintk("Slot %i shutdown\n", slot);
***************
*** 807,813 ****
  }
  EXPORT_SYMBOL(dvb_ca_en50221_camready_irq);
  
- 
  /**
   * A CAMCHANGE IRQ has occurred.
   *
--- 884,889 ----
***************
*** 836,842 ****
  }
  EXPORT_SYMBOL(dvb_ca_en50221_frda_irq);
  
- 
  /**
   * A CAMREADY IRQ has occurred.
   *
--- 912,917 ----
***************
*** 855,861 ****
  	}
  }
  
- 
  /**
   * An FR or DA IRQ has occurred.
   *
--- 930,935 ----
***************
*** 885,892 ****
  	}
  }
  
- 
- 
  /* ******************************************************************************** */
  /* EN50221 thread functions */
  
--- 959,964 ----
***************
*** 974,981 ****
  	ca->delay = curdelay;
  }
  
- 
- 
  /**
   * Kernel thread which monitors CA slots for CAM changes, and performs data transfers.
   */
--- 1046,1051 ----
***************
*** 1043,1057 ****
--- 1113,1132 ----
  				break;
  
  			case DVB_CA_SLOTSTATE_UNINITIALISED:
+ 				printk("DVB_CA_SLOTSTATE_UNINITIALISED %d\n", slot);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITREADY;
  				ca->pub->slot_reset(ca->pub, slot);
  				ca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);
  				break;
  
  			case DVB_CA_SLOTSTATE_WAITREADY:
+ 				printk("DVB_CA_SLOTSTATE_WAITREADY %d\n", slot);
  				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
  					printk("dvb_ca adaptor %d: PC card did not respond :(\n",
  					       ca->dvbdev->adapter->num);
+ 
+ 					ca->slot_info[slot].errorWaitReady++;
+ 
  					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
  					dvb_ca_en50221_thread_update_delay(ca);
  					break;
***************
*** 1060,1065 ****
--- 1135,1147 ----
  				break;
  
  			case DVB_CA_SLOTSTATE_VALIDATE:
+ 				printk("DVB_CA_SLOTSTATE_VALIDATE %d\n", slot);
+ 
+ 				/*GustavGans: it seems that the validation process comes to early
+ 				  if MPEG stream is turned on and MPEG bypassing is disabled
+ 				  (the first tuple is invalid) */
+ 				mdelay(100);
+ 
  				if (dvb_ca_en50221_parse_attributes(ca, slot) != 0) {
  					/* we need this extra check for annoying interfaces like the budget-av */
  					if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&
***************
*** 1072,1112 ****
  						}
  					}
  
! 					printk("dvb_ca adapter %d: Invalid PC card inserted :(\n",
! 					       ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
  				if (dvb_ca_en50221_set_configoption(ca, slot) != 0) {
  					printk("dvb_ca adapter %d: Unable to initialise CAM :(\n",
  					       ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
  				if (ca->pub->write_cam_control(ca->pub, slot,
  							       CTRLIF_COMMAND, CMDREG_RS) != 0) {
  					printk("dvb_ca adapter %d: Unable to reset CAM IF\n",
  					       ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
! 				dprintk("DVB CAM validated successfully\n");
  
! 				ca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITFR;
  				ca->wakeup = 1;
  				break;
  
  			case DVB_CA_SLOTSTATE_WAITFR:
  				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
  					printk("dvb_ca adapter %d: DVB CAM did not respond :(\n",
  					       ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
  
  				flags = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);
--- 1154,1235 ----
  						}
  					}
  
! 					printk("dvb_ca adapter %d: Invalid PC card inserted (slot = %d) :(\n",
! 					       ca->dvbdev->adapter->num, slot);
! 
! 					//Dagobert
! 					ca->slot_info[slot].errorStateValidate++;
! 					if (ca->slot_info[slot].ignoreStateValidate == 0)
! 					{
! 				 	   ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					   dvb_ca_en50221_thread_update_delay(ca);
! 				 	   break;
! 				        }
  				}
  				if (dvb_ca_en50221_set_configoption(ca, slot) != 0) {
  					printk("dvb_ca adapter %d: Unable to initialise CAM :(\n",
  					       ca->dvbdev->adapter->num);
! 					//Dagobert
! 					ca->slot_info[slot].errorConfigOption++;
! 					if (ca->slot_info[slot].ignoreConfigOption == 0)
! 					{
! 						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 						dvb_ca_en50221_thread_update_delay(ca);
! 						break;
! 					}
  				}
  				if (ca->pub->write_cam_control(ca->pub, slot,
  							       CTRLIF_COMMAND, CMDREG_RS) != 0) {
+ 
  					printk("dvb_ca adapter %d: Unable to reset CAM IF\n",
  					       ca->dvbdev->adapter->num);
! 
! 					//Dagobert
! 					ca->slot_info[slot].errorWriteCamControl++;
! 					if (ca->slot_info[slot].ignoreWriteCamControl == 0)
! 					{
! 						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 						dvb_ca_en50221_thread_update_delay(ca);
! 					        break;
! 					} else
! 					{
! 						//noop
! 					}
  				}
! 				dprintk("DVB CAM validated successfully (slot = %d)\n", slot);
  
! 				ca->slot_info[slot].timeout = jiffies + (WAIT_FREE_TIMEOUT_SECS * HZ);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITFR;
  				ca->wakeup = 1;
  				break;
  
  			case DVB_CA_SLOTSTATE_WAITFR:
+ 				printk("DVB_CA_SLOTSTATE_WAITFR %d\n", slot);
+ #define old
+ #ifdef old
+ /* Dagobert: The Norm says that after setting the RS Bit (see state before) the module
+  * clears the buffer and sets the free bit (FR). But it seems so that older modules does not so,
+  * they set this bit after starting the negotiation.
+  * So we wait here and get a timeout. pvrmain does'nt this and starts the negotiation
+  * (bit SR) directly. Ok first it clears all bits but this seems not necessary at all.
+  */
  				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
  					printk("dvb_ca adapter %d: DVB CAM did not respond :(\n",
  					       ca->dvbdev->adapter->num);
! 
! 					//Dagobert
! 					ca->slot_info[slot].errorWaitFree++;
! 					if (ca->slot_info[slot].ignoreWaitFree == 0)
! 					{
! 						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 						dvb_ca_en50221_thread_update_delay(ca);
! 						break;
! 					} else
! 					{
! 					    ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
! 					    ca->wakeup = 1;
! 					    break;
! 					}
  				}
  
  				flags = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);
***************
*** 1114,1122 ****
--- 1237,1251 ----
  					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  					ca->wakeup = 1;
  				}
+ #else
+ 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+ 					ca->wakeup = 1;
+ #endif
+ 
  				break;
  
  			case DVB_CA_SLOTSTATE_LINKINIT:
+ 				printk("DVB_CA_SLOTSTATE_LINKINIT %d\n", slot);
  				if (dvb_ca_en50221_link_init(ca, slot) != 0) {
  					/* we need this extra check for annoying interfaces like the budget-av */
  					if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&
***************
*** 1130,1144 ****
  					}
  
  					printk("dvb_ca adapter %d: DVB CAM link initialisation failed :(\n", ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
  
  				if (ca->slot_info[slot].rx_buffer.data == NULL) {
  					rxbuf = vmalloc(RX_BUFFER_SIZE);
  					if (rxbuf == NULL) {
  						printk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);
  						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
  						dvb_ca_en50221_thread_update_delay(ca);
  						break;
--- 1259,1282 ----
  					}
  
  					printk("dvb_ca adapter %d: DVB CAM link initialisation failed :(\n", ca->dvbdev->adapter->num);
! 					//Dagobert
! 					ca->slot_info[slot].errorInit++;
! 					if (ca->slot_info[slot].ignoreInit == 0)
! 					{
! 						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 						dvb_ca_en50221_thread_update_delay(ca);
! 						break;
! 					}
  				}
  
  				if (ca->slot_info[slot].rx_buffer.data == NULL) {
  					rxbuf = vmalloc(RX_BUFFER_SIZE);
  					if (rxbuf == NULL) {
  						printk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);
+ 
+ 						//Dagobert: this one cant be ignored I think
+ 						ca->slot_info[slot].errorRxBuffer++;
+ 
  						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
  						dvb_ca_en50221_thread_update_delay(ca);
  						break;
***************
*** 1149,1155 ****
  				ca->pub->slot_ts_enable(ca->pub, slot);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
  				dvb_ca_en50221_thread_update_delay(ca);
! 				printk("dvb_ca adapter %d: DVB CAM detected and initialised successfully\n", ca->dvbdev->adapter->num);
  				break;
  
  			case DVB_CA_SLOTSTATE_RUNNING:
--- 1287,1293 ----
  				ca->pub->slot_ts_enable(ca->pub, slot);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
  				dvb_ca_en50221_thread_update_delay(ca);
! 				printk("dvb_ca adapter %d: DVB CAM detected and initialised successfully (slot = %d)\n", ca->dvbdev->adapter->num, slot);
  				break;
  
  			case DVB_CA_SLOTSTATE_RUNNING:
***************
*** 1159,1164 ****
--- 1297,1307 ----
  				// poll slots for data
  				pktcount = 0;
  				while ((status = dvb_ca_en50221_read_data(ca, slot, NULL, 0)) > 0) {
+ 					mutex_lock(&ca->io_mutex);
+ 					ca->slot_info[slot].camPollin = 1;
+ 					mutex_unlock(&ca->io_mutex);
+ 					//printk("\nPI\n\n");
+ 
  					if (!ca->open)
  						break;
  
***************
*** 1176,1181 ****
--- 1319,1341 ----
  						break;
  					}
  				}
+ 
+ 				/* wg pollwri: wake up poll waiters if there is nothing todo, so he can write some data */
+ 		 		if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) >= 0)
+ 		 		{
+ 	            			if (!(status & STATUSREG_DA))
+ 						if (!(status & STATUSREG_RE))
+ 		           				if (status & STATUSREG_FR)
+ 			   				{
+ 								mutex_lock(&ca->io_mutex);
+ 								ca->slot_info[slot].camPollout = 1;
+ 								mutex_unlock(&ca->io_mutex);
+ 
+ 								wake_up_interruptible(&ca->slot_info[slot].wait_queue);
+ 								wake_up_interruptible(&ca->wait_queue);
+ 							}
+ 		 		}
+ 
  				break;
  			}
  		}
***************
*** 1216,1221 ****
--- 1376,1384 ----
  
  	switch (cmd) {
  	case CA_RESET:
+ 
+ //Dagobert: resetting only requested slot is good idea maybe :-/
+ #ifdef alt
  		for (slot = 0; slot < ca->slot_count; slot++) {
  			if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE) {
  				dvb_ca_en50221_slot_shutdown(ca, slot);
***************
*** 1225,1230 ****
--- 1388,1408 ----
  								     DVB_CA_EN50221_CAMCHANGE_INSERTED);
  			}
  		}
+ #else
+ 		for (slot = 0; slot < ca->slot_count; slot++) {
+ 			int mySlot = ((int) parg);
+ 
+ 			dprintk("mySlot = %d, searched %d\n", mySlot, slot);
+ 
+ 			if (mySlot != slot)
+ 			    continue;
+ 
+ 			dprintk("->reset %d\n", mySlot);
+ 
+ 			//dagobert: rest will be done in loop
+ 			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_UNINITIALISED;
+ 		}
+ #endif
  		ca->next_read_slot = 0;
  		dvb_ca_en50221_thread_wakeup(ca);
  		break;
***************
*** 1251,1256 ****
--- 1429,1439 ----
  			&& (ca->slot_info[info->num].slot_state != DVB_CA_SLOTSTATE_INVALID)) {
  			info->flags = CA_CI_MODULE_PRESENT;
  		}
+ 		//Dagobert
+ 		else
+ 		if (ca->slot_info[info->num].slot_state == DVB_CA_SLOTSTATE_INVALID)
+ 			info->flags = CA_CI_MODULE_INVALID;
+ 
  		if (ca->slot_info[info->num].slot_state == DVB_CA_SLOTSTATE_RUNNING) {
  			info->flags |= CA_CI_MODULE_READY;
  		}
***************
*** 1300,1306 ****
  	struct dvb_ca_private *ca = dvbdev->priv;
  	u8 slot, connection_id;
  	int status;
! 	u8 fragbuf[HOST_LINK_BUF_SIZE];
  	int fragpos = 0;
  	int fraglen;
  	unsigned long timeout;
--- 1483,1489 ----
  	struct dvb_ca_private *ca = dvbdev->priv;
  	u8 slot, connection_id;
  	int status;
! 	char fragbuf[HOST_LINK_BUF_SIZE];
  	int fragpos = 0;
  	int fraglen;
  	unsigned long timeout;
***************
*** 1310,1331 ****
  
  	/* Incoming packet has a 2 byte header. hdr[0] = slot_id, hdr[1] = connection_id */
  	if (count < 2)
  		return -EINVAL;
! 
  	/* extract slot & connection id */
  	if (copy_from_user(&slot, buf, 1))
  		return -EFAULT;
  	if (copy_from_user(&connection_id, buf + 1, 1))
  		return -EFAULT;
  	buf += 2;
  	count -= 2;
  
  	/* check if the slot is actually running */
  	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
  		return -EINVAL;
  
  	/* fragment the packets & store in the buffer */
  	while (fragpos < count) {
  		fraglen = ca->slot_info[slot].link_buf_size - 2;
  		if ((count - fragpos) < fraglen)
  			fraglen = count - fragpos;
--- 1493,1525 ----
  
  	/* Incoming packet has a 2 byte header. hdr[0] = slot_id, hdr[1] = connection_id */
  	if (count < 2)
+ 	{
+ 		printk("1. EINVAL\n");
  		return -EINVAL;
! 	}
  	/* extract slot & connection id */
  	if (copy_from_user(&slot, buf, 1))
  		return -EFAULT;
+ 
  	if (copy_from_user(&connection_id, buf + 1, 1))
  		return -EFAULT;
+ 
+ 	//Dagobert write out the message so we can debug problems better
+ 	//dprintk("0x%02x 0x%02x", slot, connection_id);
+ 
  	buf += 2;
  	count -= 2;
  
  	/* check if the slot is actually running */
  	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
+ 	{
+ 		printk("2. EINVAL (slot = %d)\n", slot);
  		return -EINVAL;
+ 	}
  
  	/* fragment the packets & store in the buffer */
  	while (fragpos < count) {
+ 		int vLoop;
  		fraglen = ca->slot_info[slot].link_buf_size - 2;
  		if ((count - fragpos) < fraglen)
  			fraglen = count - fragpos;
***************
*** 1335,1340 ****
--- 1529,1540 ----
  		if ((status = copy_from_user(fragbuf + 2, buf + fragpos, fraglen)) != 0)
  			goto exit;
  
+ 		//Dagobert write out the message so we can debug problems better
+ 		dprintk("<fraglen = %d\n", fraglen);
+ 		for (vLoop = 0; vLoop < fraglen; vLoop++)
+ 			dprintk(" 0x%02x", fragbuf[vLoop + 2]);
+ 		dprintk("\nfraglen>\n");
+ 
  		timeout = jiffies + HZ / 2;
  		written = 0;
  		while (!time_after(jiffies, timeout)) {
***************
*** 1364,1369 ****
--- 1564,1570 ----
  	status = count + 2;
  
  exit:
+ 	ca->slot_info[slot].waitWrite = 0;
  	return status;
  }
  
***************
*** 1393,1399 ****
  
  		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
  		while (idx != -1) {
! 			dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2, 0);
  			if (connection_id == -1)
  				connection_id = hdr[0];
  			if ((hdr[0] == connection_id) && ((hdr[1] & 0x80) == 0)) {
--- 1594,1600 ----
  
  		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
  		while (idx != -1) {
! 			dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2);
  			if (connection_id == -1)
  				connection_id = hdr[0];
  			if ((hdr[0] == connection_id) && ((hdr[1] & 0x80) == 0)) {
***************
*** 1415,1420 ****
--- 1616,1653 ----
  }
  
  
+ //Dagobert
+ static int dvb_ca_en50221_io_read_condition_for_slot(struct dvb_ca_private *ca, int slot)
+ {
+ 	int idx;
+ 	size_t fraglen;
+ 	int connection_id = -1;
+ 	int found = 0;
+ 	u8 hdr[2];
+ 
+ 	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
+ 		return 0;
+ 
+ 	if (ca->slot_info[slot].rx_buffer.data == NULL) {
+ 		return 0;
+ 	}
+ 
+ 	idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
+ 	while (idx != -1) {
+ 		dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2);
+ 		if (connection_id == -1)
+ 			connection_id = hdr[0];
+ 		if ((hdr[0] == connection_id) && ((hdr[1] & 0x80) == 0)) {
+ 			found = 1;
+ 			break;
+ 		}
+ 
+ 		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);
+ 	}
+ 
+ 	return found;
+ }
+ 
  /**
   * Implementation of read() syscall.
   *
***************
*** 1440,1445 ****
--- 1673,1680 ----
  	size_t fraglen;
  	int pktlen;
  	int dispose = 0;
+ 	/* Dagobert */
+ 	int ci_slot = -1;
  
  	dprintk("%s\n", __FUNCTION__);
  
***************
*** 1447,1464 ****
  	if (count < 2)
  		return -EINVAL;
  
  	/* wait for some data */
  	if ((status = dvb_ca_en50221_io_read_condition(ca, &result, &slot)) == 0) {
  
  		/* if we're in nonblocking mode, exit immediately */
  		if (file->f_flags & O_NONBLOCK)
  			return -EWOULDBLOCK;
! 
  		/* wait for some data */
! 		status = wait_event_interruptible(ca->wait_queue,
  						  dvb_ca_en50221_io_read_condition
  						  (ca, &result, &slot));
  	}
  	if ((status < 0) || (result < 0)) {
  		if (result)
  			return result;
--- 1682,1787 ----
  	if (count < 2)
  		return -EINVAL;
  
+ 	/* Dagobert */
+         if (dvbdev == ca->dvbdev_ci[0])
+ 		ci_slot = 0;
+ 	else
+         if (dvbdev == ca->dvbdev_ci[1])
+ 		ci_slot = 1;
+ 
+ 	if (ci_slot != -1)
+ 	{
+ 		/* is there something to read ? */
+ 		if ((status = dvb_ca_en50221_io_read_condition_for_slot(ca, ci_slot)) == 0) {
+ 
+ 		   /* if we're in nonblocking mode, exit immediately */
+ 		   if (file->f_flags & O_NONBLOCK)
+ 		   {
+ 			   return -EWOULDBLOCK;
+ 		   }
+ 
+ 		   /* wait for some data */
+ 		   status = wait_event_interruptible(ca->slot_info[ci_slot].wait_queue,
+ 						     dvb_ca_en50221_io_read_condition_for_slot
+ 						     (ca, ci_slot));
+ 
+ 		   dprintk("status = %d\n", status);	
+ 
+ 		}
+ 
+ 		if ((status < 0)) {
+ 			return status;
+ 		}
+ 
+ 		slot = ci_slot;
+ 
+ 		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
+ 		pktlen = 2;
+ 		do {
+ 			if (idx == -1) {
+ 				printk("dvb_ca adapter %d: BUG: read packet ended before last_fragment encountered\n", ca->dvbdev->adapter->num);
+ 
+ 		                printk("pktlen = %d, fraglen = %d, count = %d, con_id = %d\n", pktlen, fraglen, count, connection_id);	
+ 		
+ 				status = -EIO;
+ 				goto exit;
+ 			}
+ 
+ 			dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2);
+ 			if (connection_id == -1)
+ 				connection_id = hdr[0];
+ 			if (hdr[0] == connection_id) {
+ 				if (pktlen < count) {
+ 					if ((pktlen + fraglen - 2) > count) {
+ 						fraglen = count - pktlen;
+ 					} else {
+ 						fraglen -= 2;
+ 					}
+ 
+ 					if ((status = dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 2,
+ 									      buf + pktlen, fraglen)) < 0) {
+ 						goto exit;
+ 					}
+ 					pktlen += fraglen;
+ 				}
+ 
+ 				if ((hdr[1] & 0x80) == 0)
+ 					last_fragment = 1;
+ 				dispose = 1;
+ 			}
+ 
+ 			idx2 = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);
+ 			if (dispose)
+ 				dvb_ringbuffer_pkt_dispose(&ca->slot_info[slot].rx_buffer, idx);
+ 			idx = idx2;
+ 			dispose = 0;
+ 		} while (!last_fragment);
+ 
+ 		hdr[0] = slot;
+ 		hdr[1] = connection_id;
+ 
+ 		if ((status = copy_to_user(buf, hdr, 2)) != 0)
+ 			goto exit;
+ 
+ 		status = pktlen;
+ 
+ 		return status;
+ 	}
+ 
  	/* wait for some data */
  	if ((status = dvb_ca_en50221_io_read_condition(ca, &result, &slot)) == 0) {
  
  		/* if we're in nonblocking mode, exit immediately */
  		if (file->f_flags & O_NONBLOCK)
+ 		{
  			return -EWOULDBLOCK;
! 		}
  		/* wait for some data */
! 		status = wait_event_interruptible(ca->slot_info[slot].wait_queue,
  						  dvb_ca_en50221_io_read_condition
  						  (ca, &result, &slot));
  	}
+ 
  	if ((status < 0) || (result < 0)) {
  		if (result)
  			return result;
***************
*** 1474,1480 ****
  			goto exit;
  		}
  
! 		dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2, 0);
  		if (connection_id == -1)
  			connection_id = hdr[0];
  		if (hdr[0] == connection_id) {
--- 1797,1803 ----
  			goto exit;
  		}
  
! 		dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2);
  		if (connection_id == -1)
  			connection_id = hdr[0];
  		if (hdr[0] == connection_id) {
***************
*** 1485,1492 ****
  					fraglen -= 2;
  				}
  
! 				if ((status = dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 2,
! 								      (u8 *)buf + pktlen, fraglen, 1)) < 0) {
  					goto exit;
  				}
  				pktlen += fraglen;
--- 1808,1815 ----
  					fraglen -= 2;
  				}
  
! 				if ((status = dvb_ringbuffer_pkt_read_user(&ca->slot_info[slot].rx_buffer, idx, 2,
! 								      buf + pktlen, fraglen)) < 0) {
  					goto exit;
  				}
  				pktlen += fraglen;
***************
*** 1506,1515 ****
--- 1829,1849 ----
  
  	hdr[0] = slot;
  	hdr[1] = connection_id;
+ 
  	if ((status = copy_to_user(buf, hdr, 2)) != 0)
  		goto exit;
  	status = pktlen;
  
+ #if 0
+ 	//Dagobert write out the message so we can debug problems better
+ 	{
+ 	   int vLoop;
+ 	   for (vLoop = 0; vLoop < pktlen; vLoop++)
+ 	      dprintk("0x%02x ", hdr[vLoop]);
+ 	   dprintk("\n");
+         }
+ #endif
+ 
  exit:
  	return status;
  }
***************
*** 1594,1608 ****
   *
   * @return Standard poll mask.
   */
  static unsigned int dvb_ca_en50221_io_poll(struct file *file, poll_table * wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_ca_private *ca = dvbdev->priv;
  	unsigned int mask = 0;
- 	int slot;
  	int result = 0;
  
! 	dprintk("%s\n", __FUNCTION__);
  
  	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
  		mask |= POLLIN;
--- 1928,2063 ----
   *
   * @return Standard poll mask.
   */
+ #define x_debug
  static unsigned int dvb_ca_en50221_io_poll(struct file *file, poll_table * wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_ca_private *ca = dvbdev->priv;
  	unsigned int mask = 0;
  	int result = 0;
+ 	int slot;
+ 	/* Dagobert */
+ 	int ci_slot = -1;
  
! #ifdef x_debug
! 	//dprintk("%s\n", __FUNCTION__);
! #endif
! 	/* Dagobert */
!         if (dvbdev == ca->dvbdev_ci[0])
! 		ci_slot = 0;
! 	else
!         if (dvbdev == ca->dvbdev_ci[1])
! 		ci_slot = 1;
! 
! 	if (ci_slot != -1)
! 	{
! #ifdef x_debug
! 		//dprintk("CI Slot = %d\n", ci_slot);
! 		//dprintk("%d ", ci_slot);
! #endif
! 
! 		/* get the desired slot from list and check for changed status
! 		 * ->e2 seems to want this only on removal of module and on errors
! 		 */
! 		if (ca->slot_info[ci_slot].slot_state != ca->slot_states[ci_slot])
! 		{
! #ifdef x_debug
! 			//dprintk("old %d, new %d (type %d)\n", ca->slot_states[ci_slot], ca->slot_info[ci_slot].slot_state, ca->slot_info[ci_slot].camchange_type);
! #endif
! 
! 			ca->slot_states[ci_slot] = ca->slot_info[ci_slot].slot_state;
! 
! 			if (ca->slot_info[ci_slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_REMOVED)
! 			{
! 			   mask |= POLLPRI;
! #ifdef x_debug
! 			   printk("return POLLPRI on slot %d ->removed\n", ci_slot);
! #endif
! 
! 			   return mask;
! 			} else
! 			if (ca->slot_info[ci_slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_INSERTED)
! 			{
! 			   if (ca->slot_info[ci_slot].slot_state == DVB_CA_SLOTSTATE_RUNNING)
! 			   {
! 			   	mask |= POLLPRI;
! #ifdef x_debug
! 			   printk("return POLLPRI on slot %d ->inserted\n", ci_slot);
! #endif
! 
! 			   	return mask;
! 			   }
! 			}
! 		}
! 
! 		mutex_lock(&ca->io_mutex);
! 		if(ca->slot_info[ci_slot].camPollout)
! 			mask |= POLLOUT;
! 
! 		if(ca->slot_info[ci_slot].camPollin)
! 			mask |= POLLIN;
! 
! 		ca->slot_info[ci_slot].camPollin = 0;
! 		ca->slot_info[ci_slot].camPollout = 0;
! 		mutex_unlock(&ca->io_mutex);
! 
! 		if(mask != 0)
! 		{
! 			return mask;
! 		}
! 
! 		/* wait for something to happen */
! 		poll_wait(file, &ca->slot_info[ci_slot].wait_queue, wait);
! 
! 		/* get the desired slot from list and check for changed status
! 		 * ->e2 seems to want this only on removal of module and on errors
! 		 */
! 		if (ca->slot_info[ci_slot].slot_state != ca->slot_states[ci_slot])
! 		{
! #ifdef x_debug
! 			dprintk("old %d, new %d (type %d)\n", ca->slot_states[ci_slot], ca->slot_info[ci_slot].slot_state, ca->slot_info[ci_slot].camchange_type);
! #endif
! 
! 			ca->slot_states[ci_slot] = ca->slot_info[ci_slot].slot_state;
! 
! 			if (ca->slot_info[ci_slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_REMOVED)
! 			{
! 			   mask |= POLLPRI;
! #ifdef x_debug
! 			   printk("return POLLPRI on slot %d ->removed\n", ci_slot);
! #endif
! 
! 			   return mask;
! 			} else
! 			if (ca->slot_info[ci_slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_INSERTED)
! 			{
! 			   if (ca->slot_info[ci_slot].slot_state == DVB_CA_SLOTSTATE_RUNNING)
! 			   {
! 			   	mask |= POLLPRI;
! #ifdef x_debug
! 			   printk("return POLLPRI on slot %d ->inserted\n", ci_slot);
! #endif
! 
! 			   	return mask;
! 			   }
! 			}
! 		}
! 
! 		mutex_lock(&ca->io_mutex);
! 		if(ca->slot_info[ci_slot].camPollout)
! 			mask |= POLLOUT;
! 
! 		if(ca->slot_info[ci_slot].camPollin)
! 			mask |= POLLIN;
! 
! 		ca->slot_info[ci_slot].camPollin = 0;
! 		ca->slot_info[ci_slot].camPollout = 0;
! 		mutex_unlock(&ca->io_mutex);
! 
! 		return mask;
! 	}
! 	
! 	/* normal caN handling */
  
  	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
  		mask |= POLLIN;
***************
*** 1642,1647 ****
--- 2097,2324 ----
  	.fops = &dvb_ca_fops,
  };
  
+ /* Dagobert */
+ static struct dvb_device dvbdev_ci[2] = {
+ {
+ 	.priv = NULL,
+ 	.users = 1,
+ 	.readers = 1,
+ 	.writers = 1,
+ 	.fops = &dvb_ca_fops,
+ },
+ {
+ 	.priv = NULL,
+ 	.users = 1,
+ 	.readers = 1,
+ 	.writers = 1,
+ 	.fops = &dvb_ca_fops,
+ }};
+ 
+ /* Dagobert proc */
+ #define stateValid 	"ignoreStateValidate"
+ #define configOption 	"ignoreConfigOption"
+ #define writeCamControl "ignoreWriteCamControl"
+ #define waitFree 	"ignoreWaitFree"
+ #define init 		"ignoreInit"
+ #define initTimeout     "initTimeout"
+ #define waitFreeTimeout "waitFreeTimeout"
+ #define cPollTime 	"pollTime"
+ 
+ void setValue(struct dvb_ca_slot * ci, char* str)
+ {
+ 	int value;
+ 
+ 	if (strncmp(str, stateValid, strlen(stateValid)) == 0)
+ 	{
+ 		sscanf(str + strlen(stateValid) + 1, "%d", &value);
+ 		printk("Set ignoreStateValidate to %d\n", value);
+ 		ci->ignoreStateValidate = value;
+ 	}
+ 	else
+ 	if (strncmp(str, configOption, strlen(configOption)) == 0)
+ 	{
+ 		sscanf(str + strlen(configOption) + 1, "%d", &value);
+ 		printk("Set ignoreConfigOption to %d\n", value);
+ 		ci->ignoreConfigOption = value;
+ 	}
+ 	else
+ 	if (strncmp(str, writeCamControl, strlen(writeCamControl)) == 0)
+ 	{
+ 		sscanf(str + strlen(writeCamControl) + 1, "%d", &value);
+ 		printk("Set ignoreWriteCamControl to %d\n", value);
+ 		ci->ignoreWriteCamControl = value;
+ 	}
+ 	else
+ 	if (strncmp(str, waitFree, strlen(waitFree)) == 0)
+ 	{
+ 		sscanf(str + strlen(waitFree) + 1, "%d", &value);
+ 		printk("Set ignoreWaitFree to %d\n", value);
+ 		ci->ignoreWaitFree = value;
+ 	}
+ 	else
+ 	if (strncmp(str, init, strlen(init)) == 0)
+ 	{
+ 		sscanf(str + strlen(init) + 1, "%d", &value);
+ 		printk("Set ignoreInit to %d\n", value);
+ 		ci->ignoreInit = value;
+ 	}
+ 	else
+ 	if (strncmp(str, initTimeout, strlen(initTimeout)) == 0)
+ 	{
+ 		sscanf(str + strlen(initTimeout) + 1, "%d", &value);
+ 		printk("Set initTimeout to %d\n", value);
+ 		INIT_TIMEOUT_SECS = value;
+ 	} else
+ 	if (strncmp(str, waitFreeTimeout, strlen(waitFreeTimeout)) == 0)
+ 	{
+ 		sscanf(str + strlen(waitFreeTimeout) + 1, "%d", &value);
+ 		printk("Set waitFreeTimeout to %d\n", value);
+ 		WAIT_FREE_TIMEOUT_SECS = value;
+ 	} else
+ 	if (strncmp(str, cPollTime, strlen(cPollTime)) == 0)
+ 	{
+ 		sscanf(str + strlen(cPollTime) + 1, "%d", &value);
+ 		printk("Set pollTime to %d\n", value);
+ 		ci->pollTime = value;
+ 	} else
+ 	  printk("not found\n");
+ }
+ 
+ char* strStatus(int state)
+ {
+ 	if (state == DVB_CA_SLOTSTATE_NONE)
+ 		return "NONE";
+ 	if (state == DVB_CA_SLOTSTATE_UNINITIALISED)
+ 		return "UNINITIALISED";
+ 	if (state == DVB_CA_SLOTSTATE_RUNNING)
+ 		return "RUNNING";
+ 	if (state == DVB_CA_SLOTSTATE_INVALID)
+ 		return "INVALID";
+ 	if (state == DVB_CA_SLOTSTATE_WAITREADY)
+ 		return "WAITREADY";
+ 	if (state == DVB_CA_SLOTSTATE_VALIDATE)
+ 		return "VALIDATE";
+ 	if (state == DVB_CA_SLOTSTATE_WAITFR)
+ 		return "WAITFR";
+ 	if (state == DVB_CA_SLOTSTATE_LINKINIT)
+ 		return "LINKINIT";
+ 	return "UNKNOWN";
+ }
+ 
+ int proc_ci0_read(char *page, char **start, off_t off, int count,int *eof, void *data_unused)
+ {
+ 	int len = 0;
+ 	printk("%s %d\n", __FUNCTION__, count);
+ 
+ 	len = sprintf(page, "ci0:\nCurrentStatus = %s\n\terrorWaitReady: %d\n\terrorStateValidate: %d\n\terrorConfigOption: %d\n\t\
+ errorWriteCamControl: %d\n\terrorWaitFree: %d\n\terrorInit: %d\n\terrorRxBuffer: %d\
+ \n\terrorLinkBufferSize: %d\n\terrorLinkBufferSizeToSmall: %d\n\terrorBufferEcount: %d\
+ \n\tignoreStateValidate: %d\n\tignoreConfigOption: %d\n\tignoreWriteCamControl: %d\
+ \n\tignoreWaitFree: %d\n\tignoreInit: %d\n\
+ \n\tinitTimeout (global): %d\n\twaitFreeTimeout (global): %d\n",
+ 			strStatus(ci0->slot_state),
+ 			ci0->errorWaitReady, ci0->errorStateValidate, ci0->errorConfigOption, ci0->errorWriteCamControl,
+ 			ci0->errorWaitFree, ci0->errorInit, ci0->errorRxBuffer,
+ 			ci0->errorLinkBufferSize, ci0->errorLinkBufferSizeToSmall, ci0->errorBufferEcount,
+ 			ci0->ignoreStateValidate, ci0->ignoreConfigOption, ci0->ignoreWriteCamControl,
+ 			ci0->ignoreWaitFree, ci0->ignoreInit,
+ 			INIT_TIMEOUT_SECS, WAIT_FREE_TIMEOUT_SECS);
+ 
+         return len;
+ }
+ 
+ int proc_ci0_write(struct file *file, const char __user *buf, unsigned long count, void *data)
+ {
+ 	char 		*page;
+ 	char		*myString;
+ 	ssize_t 	ret = -ENOMEM;
+ 
+ 	printk("%s %ld - ", __FUNCTION__, count);
+ 
+ 	page = (char *)__get_free_page(GFP_KERNEL);
+ 	if (page)
+ 	{
+ 		ret = -EFAULT;
+ 		if (copy_from_user(page, buf, count))
+ 			goto out;
+ 
+ 		myString = (char *) kmalloc(count + 1, GFP_KERNEL);
+ 
+ 		strncpy(myString, page, count);
+ 		myString[count] = '\0';
+ 
+ 		printk("%s\n", myString);
+ 
+ 		setValue(ci0, myString);
+ 
+ 		kfree(myString);
+ 	}
+ 
+ 	ret = count;
+ out:
+ 
+ 	free_page((unsigned long)page);
+ 	return ret;
+ 
+ }
+ 
+ int proc_ci1_read(char *page, char **start, off_t off, int count,int *eof, void *data_unused)
+ {
+ 	int len = 0;
+ 	printk("%s %d\n", __FUNCTION__, count);
+ 
+ 	len = sprintf(page, "ci1:\nCurrentStatus = %s\n\terrorWaitReady: %d\n\terrorStateValidate: %d\n\terrorConfigOption: %d\n\t\
+ errorWriteCamControl: %d\n\terrorWaitFree: %d\n\terrorInit: %d\n\terrorRxBuffer: %d\
+ \n\terrorLinkBufferSize: %d\n\terrorLinkBufferSizeToSmall: %d\n\terrorBufferEcount: %d\
+ \n\tignoreStateValidate: %d\n\tignoreConfigOption: %d\n\tignoreWriteCamControl: %d\
+ \n\tignoreWaitFree: %d\n\tignoreInit: %d\n\
+ \n\tinitTimeout (global): %d\n\twaitFreeTimeout (global): %d\n",
+ 			strStatus(ci1->slot_state),
+ 			ci1->errorWaitReady, ci1->errorStateValidate, ci1->errorConfigOption, ci1->errorWriteCamControl,
+ 			ci1->errorWaitFree, ci1->errorInit, ci1->errorRxBuffer,
+ 			ci1->errorLinkBufferSize, ci1->errorLinkBufferSizeToSmall, ci1->errorBufferEcount,
+ 			ci1->ignoreStateValidate, ci1->ignoreConfigOption, ci1->ignoreWriteCamControl,
+ 			ci1->ignoreWaitFree, ci1->ignoreInit,
+ 			INIT_TIMEOUT_SECS, WAIT_FREE_TIMEOUT_SECS);
+ 
+ 
+         return len;
+ }
+ 
+ int proc_ci1_write(struct file *file, const char __user *buf, unsigned long count, void *data)
+ {
+ 	char 		*page;
+ 	char		*myString;
+ 	ssize_t 	ret = -ENOMEM;
+ 
+ 	printk("%s %ld - ", __FUNCTION__, count);
+ 
+ 	page = (char *)__get_free_page(GFP_KERNEL);
+ 	if (page)
+ 	{
+ 		ret = -EFAULT;
+ 		if (copy_from_user(page, buf, count))
+ 			goto out;
+ 
+ 		myString = (char *) kmalloc(count + 1, GFP_KERNEL);
+ 
+ 		strncpy(myString, page, count);
+ 		myString[count] = '\0';
+ 
+ 		printk("%s\n", myString);
+ 
+ 		setValue(ci1, myString);
+ 
+ 		kfree(myString);
+ 	}
+ 
+ 	ret = count;
+ out:
+ 
+ 	free_page((unsigned long)page);
+ 	return ret;
+ 
+ }
  
  /* ******************************************************************************** */
  /* Initialisation/shutdown functions */
***************
*** 1681,1686 ****
--- 2358,2367 ----
  		ret = -ENOMEM;
  		goto error;
  	}
+ 
+ 	/* dagobert */
+         mutex_init(&ca->io_mutex);
+ 
  	init_waitqueue_head(&ca->wait_queue);
  	ca->thread_pid = 0;
  	init_waitqueue_head(&ca->thread_queue);
***************
*** 1695,1706 ****
--- 2376,2421 ----
  	if (ret)
  		goto error;
  
+ 	/* add proc entries for debug and for settings on different modules */
+ 	ci_dir = proc_mkdir("ci" ,  NULL);
+ 
  	/* now initialise each slot */
  	for (i = 0; i < slot_count; i++) {
  		memset(&ca->slot_info[i], 0, sizeof(struct dvb_ca_slot));
+ 
+ 		init_waitqueue_head(&ca->slot_info[i].wait_queue);
  		ca->slot_info[i].slot_state = DVB_CA_SLOTSTATE_NONE;
  		atomic_set(&ca->slot_info[i].camchange_count, 0);
  		ca->slot_info[i].camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;
+ 
+ 		/* Dagobert and add a ci device entry */
+ 	        ret = dvb_register_device(dvb_adapter, &ca->dvbdev_ci[i], &dvbdev_ci[i], ca, DVB_DEVICE_CI);
+ 		ca->slot_states[i] = DVB_CA_EN50221_CAMCHANGE_REMOVED;
+ 	        if (ret)
+ 		    printk("error creating ci device for slot %d\n", i);
+ 
+ 		//Dagobert: Hacky: dont know how to get data from proc read write functions so I share this here
+ 		//(maybe over kdev)?
+ 		if (i == 0)
+ 		{
+ 		   ca->slot_info[i].entry = create_proc_entry("ci0", 0, ci_dir);
+ 		   ci0 = &ca->slot_info[i];
+ 		   ci0->ignoreWaitFree = 1;
+ 		   ci0->pollTime = 100;
+ 		   ci0->waitWrite = 0;
+ 		   ca->slot_info[i].entry->read_proc = proc_ci0_read;
+ 		   ca->slot_info[i].entry->write_proc = proc_ci0_write;
+ 		} else
+ 		{
+ 		   ca->slot_info[i].entry = create_proc_entry("ci1", 0, ci_dir);
+ 		   ci1 = &ca->slot_info[i];
+ 		   ci1->ignoreWaitFree = 1;
+ 		   ci1->pollTime = 100;
+ 		   ci1->waitWrite = 0;
+ 		   ca->slot_info[i].entry->read_proc = proc_ci1_read;
+ 		   ca->slot_info[i].entry->write_proc = proc_ci1_write;
+ 
+ 		}
  	}
  
  	if (signal_pending(current)) {
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_ca_en50221.h linux-sh4/drivers/media/dvb/dvb-core/dvb_ca_en50221.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_ca_en50221.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_ca_en50221.h	Wed May 19 10:00:27 2010
***************
*** 45,52 ****
  	/* the module owning this structure */
  	struct module* owner;
  
! 	/* NOTE: the read_*, write_* and poll_slot_status functions must use locks as
! 	 * they may be called from several threads at once */
  
  	/* functions for accessing attribute memory on the CAM */
  	int (*read_attribute_mem)(struct dvb_ca_en50221* ca, int slot, int address);
--- 45,54 ----
  	/* the module owning this structure */
  	struct module* owner;
  
! 	/* NOTE: the read_*, write_* and poll_slot_status functions will be
! 	 * called for different slots concurrently and need to use locks where
! 	 * and if appropriate. There will be no concurrent access to one slot.
! 	 */
  
  	/* functions for accessing attribute memory on the CAM */
  	int (*read_attribute_mem)(struct dvb_ca_en50221* ca, int slot, int address);
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_demux.c linux-sh4/drivers/media/dvb/dvb-core/dvb_demux.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_demux.c	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_demux.c	Wed May 19 10:00:27 2010
***************
*** 21,26 ****
--- 21,27 ----
   *
   */
  
+ #include <linux/sched.h>
  #include <linux/spinlock.h>
  #include <linux/slab.h>
  #include <linux/vmalloc.h>
***************
*** 29,34 ****
--- 30,36 ----
  #include <linux/string.h>
  #include <linux/crc32.h>
  #include <asm/uaccess.h>
+ #include <asm/div64.h>
  
  #include "dvb_demux.h"
  
***************
*** 38,43 ****
--- 40,62 ----
  */
  // #define DVB_DEMUX_SECTION_LOSS_LOG
  
+ static int dvb_demux_tscheck;
+ module_param(dvb_demux_tscheck, int, 0644);
+ MODULE_PARM_DESC(dvb_demux_tscheck,
+ 		"enable transport stream continuity and TEI check");
+ 
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+ static int dvb_demux_speedcheck;
+ module_param(dvb_demux_speedcheck, int, 0644);
+ MODULE_PARM_DESC(dvb_demux_speedcheck,
+ 		"enable transport stream speed check");
+ #endif
+ 
+ #define dprintk_tscheck(x...) do {                              \
+ 		if (dvb_demux_tscheck && printk_ratelimit())    \
+ 			printk(x);                              \
+ 	} while (0)
+ 
  /******************************************************************************
   * static inlined helper functions
   ******************************************************************************/
***************
*** 368,385 ****
  #define DVR_FEED(f)							\
  	(((f)->type == DMX_TYPE_TS) &&					\
  	((f)->feed.ts.is_filtering) &&					\
! 	(((f)->ts_type & (TS_PACKET|TS_PAYLOAD_ONLY)) == TS_PACKET))
  
  static void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf)
  {
  	struct dvb_demux_feed *feed;
- 	struct list_head *pos, *head = &demux->feed_list;
  	u16 pid = ts_pid(buf);
  	int dvr_done = 0;
  
! 	list_for_each(pos, head) {
! 		feed = list_entry(pos, struct dvb_demux_feed, list_head);
  
  		if ((feed->pid != pid) && (feed->pid != 0x2000))
  			continue;
  
--- 387,456 ----
  #define DVR_FEED(f)							\
  	(((f)->type == DMX_TYPE_TS) &&					\
  	((f)->feed.ts.is_filtering) &&					\
! 	(((f)->ts_type & (TS_PACKET | TS_DEMUX)) == TS_PACKET))
  
  static void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf)
  {
  	struct dvb_demux_feed *feed;
  	u16 pid = ts_pid(buf);
  	int dvr_done = 0;
  
! #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
! 	if (dvb_demux_speedcheck) {
! 		struct timespec cur_time, delta_time;
! 		u64 speed_bytes, speed_timedelta;
! 
! 		demux->speed_pkts_cnt++;
! 
! 		/* show speed every SPEED_PKTS_INTERVAL packets */
! 		if (!(demux->speed_pkts_cnt % SPEED_PKTS_INTERVAL)) {
! 			cur_time = current_kernel_time();
! 
! 			if (demux->speed_last_time.tv_sec != 0 &&
! 					demux->speed_last_time.tv_nsec != 0) {
! 				delta_time = timespec_sub(cur_time,
! 						demux->speed_last_time);
! 				speed_bytes = (u64)demux->speed_pkts_cnt
! 					* 188 * 8;
! 				/* convert to 1024 basis */
! 				speed_bytes = 1000 * div64_u64(speed_bytes,
! 						1024);
! 				speed_timedelta =
! 					(u64)timespec_to_ns(&delta_time);
! 				speed_timedelta = div64_u64(speed_timedelta,
! 						1000000); /* nsec -> usec */
! 				printk(KERN_INFO "TS speed %llu Kbits/sec \n",
! 						div64_u64(speed_bytes,
! 							speed_timedelta));
! 			};
! 
! 			demux->speed_last_time = cur_time;
! 			demux->speed_pkts_cnt = 0;
! 		};
! 	};
! #endif
  
+ 	if (demux->cnt_storage) {
+ 		/* check pkt counter */
+ 		if (pid < MAX_PID) {
+ 			if (buf[1] & 0x80)
+ 				dprintk_tscheck("TEI detected. "
+ 						"PID=0x%x data1=0x%x\n",
+ 						pid, buf[1]);
+ 
+ 			if ((buf[3] & 0xf) != demux->cnt_storage[pid])
+ 				dprintk_tscheck("TS packet counter mismatch. "
+ 						"PID=0x%x expected 0x%x "
+ 						"got 0x%x\n",
+ 						pid, demux->cnt_storage[pid],
+ 						buf[3] & 0xf);
+ 
+ 			demux->cnt_storage[pid] = ((buf[3] & 0xf) + 1)&0xf;
+ 		};
+ 		/* end check */
+ 	};
+ 
+ 	list_for_each_entry(feed, &demux->feed_list, list_head) {
  		if ((feed->pid != pid) && (feed->pid != 0x2000))
  			continue;
  
***************
*** 388,400 ****
  		if ((DVR_FEED(feed)) && (dvr_done++))
  			continue;
  
! 		if (feed->pid == pid) {
  			dvb_dmx_swfilter_packet_type(feed, buf);
! 			if (DVR_FEED(feed))
! 				continue;
! 		}
! 
! 		if (feed->pid == 0x2000)
  			feed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts, DMX_OK);
  	}
  }
--- 459,467 ----
  		if ((DVR_FEED(feed)) && (dvr_done++))
  			continue;
  
! 		if (feed->pid == pid)
  			dvb_dmx_swfilter_packet_type(feed, buf);
! 		else if (feed->pid == 0x2000)
  			feed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts, DMX_OK);
  	}
  }
***************
*** 556,562 ****
  	spin_lock_irq(&feed->demux->lock);
  	if (dvb_demux_feed_find(feed)) {
  		printk(KERN_ERR "%s: feed already in list (type=%x state=%x pid=%x)\n",
! 		       __FUNCTION__, feed->type, feed->state, feed->pid);
  		goto out;
  	}
  
--- 623,629 ----
  	spin_lock_irq(&feed->demux->lock);
  	if (dvb_demux_feed_find(feed)) {
  		printk(KERN_ERR "%s: feed already in list (type=%x state=%x pid=%x)\n",
! 		       __func__, feed->type, feed->state, feed->pid);
  		goto out;
  	}
  
***************
*** 570,576 ****
  	spin_lock_irq(&feed->demux->lock);
  	if (!(dvb_demux_feed_find(feed))) {
  		printk(KERN_ERR "%s: feed not in list (type=%x state=%x pid=%x)\n",
! 		       __FUNCTION__, feed->type, feed->state, feed->pid);
  		goto out;
  	}
  
--- 637,643 ----
  	spin_lock_irq(&feed->demux->lock);
  	if (!(dvb_demux_feed_find(feed))) {
  		printk(KERN_ERR "%s: feed not in list (type=%x state=%x pid=%x)\n",
! 		       __func__, feed->type, feed->state, feed->pid);
  		goto out;
  	}
  
***************
*** 1059,1074 ****
  	return 0;
  }
  
! static int dvbdmx_write(struct dmx_demux *demux, const char *buf, size_t count)
  {
  	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
  
  	if ((!demux->frontend) || (demux->frontend->source != DMX_MEMORY_FE))
  		return -EINVAL;
  
! 	if (mutex_lock_interruptible(&dvbdemux->mutex))
  		return -ERESTARTSYS;
! 	dvb_dmx_swfilter(dvbdemux, (u8 *)buf, count);
  	mutex_unlock(&dvbdemux->mutex);
  
  	if (signal_pending(current))
--- 1126,1152 ----
  	return 0;
  }
  
! static int dvbdmx_write(struct dmx_demux *demux, const char __user *buf, size_t count)
  {
  	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
+ 	void *p;
  
  	if ((!demux->frontend) || (demux->frontend->source != DMX_MEMORY_FE))
  		return -EINVAL;
  
! 	p = kmalloc(count, GFP_USER);
! 	if (!p)
! 		return -ENOMEM;
! 	if (copy_from_user(p, buf, count)) {
! 		kfree(p);
! 		return -EFAULT;
! 	}
! 	if (mutex_lock_interruptible(&dvbdemux->mutex)) {
! 		kfree(p);
  		return -ERESTARTSYS;
! 	}
! 	dvb_dmx_swfilter(dvbdemux, p, count);
! 	kfree(p);
  	mutex_unlock(&dvbdemux->mutex);
  
  	if (signal_pending(current))
***************
*** 1152,1157 ****
--- 1230,1236 ----
  	int i;
  	struct dmx_demux *dmx = &dvbdemux->dmx;
  
+ 	dvbdemux->cnt_storage = NULL;
  	dvbdemux->users = 0;
  	dvbdemux->filter = vmalloc(dvbdemux->filternum * sizeof(struct dvb_demux_filter));
  
***************
*** 1161,1166 ****
--- 1240,1246 ----
  	dvbdemux->feed = vmalloc(dvbdemux->feednum * sizeof(struct dvb_demux_feed));
  	if (!dvbdemux->feed) {
  		vfree(dvbdemux->filter);
+ 		dvbdemux->filter = NULL;
  		return -ENOMEM;
  	}
  	for (i = 0; i < dvbdemux->filternum; i++) {
***************
*** 1172,1177 ****
--- 1252,1264 ----
  		dvbdemux->feed[i].index = i;
  	}
  
+ 	if (dvb_demux_tscheck) {
+ 		dvbdemux->cnt_storage = vmalloc(MAX_PID + 1);
+ 
+ 		if (!dvbdemux->cnt_storage)
+ 			printk(KERN_WARNING "Couldn't allocate memory for TS/TEI check. Disabling it\n");
+ 	}
+ 
  	INIT_LIST_HEAD(&dvbdemux->frontend_list);
  
  	for (i = 0; i < DMX_TS_PES_OTHER; i++) {
***************
*** 1218,1223 ****
--- 1305,1311 ----
  
  void dvb_dmx_release(struct dvb_demux *dvbdemux)
  {
+ 	vfree(dvbdemux->cnt_storage);
  	vfree(dvbdemux->filter);
  	vfree(dvbdemux->feed);
  }
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_demux.h linux-sh4/drivers/media/dvb/dvb-core/dvb_demux.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_demux.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_demux.h	Wed May 19 10:00:27 2010
***************
*** 26,31 ****
--- 26,32 ----
  #include <linux/time.h>
  #include <linux/timer.h>
  #include <linux/spinlock.h>
+ #include "compat.h"
  #include <linux/mutex.h>
  
  #include "demux.h"
***************
*** 42,47 ****
--- 43,52 ----
  
  #define DVB_DEMUX_MASK_MAX 18
  
+ #define MAX_PID 0x1fff
+ 
+ #define SPEED_PKTS_INTERVAL 50000
+ 
  struct dvb_demux_filter {
  	struct dmx_section_filter filter;
  	u8 maskandmode[DMX_MAX_FILTER_SIZE];
***************
*** 127,132 ****
--- 132,142 ----
  
  	struct mutex mutex;
  	spinlock_t lock;
+ 
+ 	uint8_t *cnt_storage; /* for TS continuity check */
+ 
+ 	struct timespec speed_last_time; /* for TS speed check */
+ 	uint32_t speed_pkts_cnt; /* for TS speed check */
  };
  
  int dvb_dmx_init(struct dvb_demux *dvbdemux);
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_filter.c linux-sh4/drivers/media/dvb/dvb-core/dvb_filter.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_filter.c	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_filter.c	Wed May 19 10:00:27 2010
***************
*** 3,9 ****
  #include <linux/string.h>
  #include "dvb_filter.h"
  
! #if 0
  static unsigned int bitrates[3][16] =
  {{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,0},
   {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0},
--- 3,9 ----
  #include <linux/string.h>
  #include "dvb_filter.h"
  
! #if 0 /* keep */
  static unsigned int bitrates[3][16] =
  {{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,0},
   {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0},
***************
*** 26,32 ****
  
  
  
! #if 0
  static void setup_ts2pes(ipack *pa, ipack *pv, u16 *pida, u16 *pidv,
  		  void (*pes_write)(u8 *buf, int count, void *data),
  		  void *priv)
--- 26,32 ----
  
  
  
! #if 0 /* keep */
  static void setup_ts2pes(ipack *pa, ipack *pv, u16 *pida, u16 *pidv,
  		  void (*pes_write)(u8 *buf, int count, void *data),
  		  void *priv)
***************
*** 40,46 ****
  }
  #endif
  
! #if 0
  static void ts_to_pes(ipack *p, u8 *buf) // don't need count (=188)
  {
  	u8 off = 0;
--- 40,46 ----
  }
  #endif
  
! #if 0 /* keep */
  static void ts_to_pes(ipack *p, u8 *buf) // don't need count (=188)
  {
  	u8 off = 0;
***************
*** 65,71 ****
  }
  #endif
  
! #if 0
  /* needs 5 byte input, returns picture coding type*/
  static int read_picture_header(u8 *headr, struct mpg_picture *pic, int field, int pr)
  {
--- 65,71 ----
  }
  #endif
  
! #if 0 /* keep */
  /* needs 5 byte input, returns picture coding type*/
  static int read_picture_header(u8 *headr, struct mpg_picture *pic, int field, int pr)
  {
***************
*** 111,117 ****
  }
  #endif
  
! #if 0
  /* needs 4 byte input */
  static int read_gop_header(u8 *headr, struct mpg_picture *pic, int pr)
  {
--- 111,117 ----
  }
  #endif
  
! #if 0 /* keep */
  /* needs 4 byte input */
  static int read_gop_header(u8 *headr, struct mpg_picture *pic, int pr)
  {
***************
*** 142,148 ****
  }
  #endif
  
! #if 0
  /* needs 8 byte input */
  static int read_sequence_header(u8 *headr, struct dvb_video_info *vi, int pr)
  {
--- 142,148 ----
  }
  #endif
  
! #if 0 /* keep */
  /* needs 8 byte input */
  static int read_sequence_header(u8 *headr, struct dvb_video_info *vi, int pr)
  {
***************
*** 257,263 ****
  #endif
  
  
! #if 0
  static int get_vinfo(u8 *mbuf, int count, struct dvb_video_info *vi, int pr)
  {
  	u8 *headr;
--- 257,263 ----
  #endif
  
  
! #if 0 /* keep */
  static int get_vinfo(u8 *mbuf, int count, struct dvb_video_info *vi, int pr)
  {
  	u8 *headr;
***************
*** 286,292 ****
  #endif
  
  
! #if 0
  static int get_ainfo(u8 *mbuf, int count, struct dvb_audio_info *ai, int pr)
  {
  	u8 *headr;
--- 286,292 ----
  #endif
  
  
! #if 0 /* keep */
  static int get_ainfo(u8 *mbuf, int count, struct dvb_audio_info *ai, int pr)
  {
  	u8 *headr;
***************
*** 393,399 ****
  EXPORT_SYMBOL(dvb_filter_get_ac3info);
  
  
! #if 0
  static u8 *skip_pes_header(u8 **bufp)
  {
  	u8 *inbuf = *bufp;
--- 393,399 ----
  EXPORT_SYMBOL(dvb_filter_get_ac3info);
  
  
! #if 0 /* keep */
  static u8 *skip_pes_header(u8 **bufp)
  {
  	u8 *inbuf = *bufp;
***************
*** 431,437 ****
  }
  #endif
  
! #if 0
  static void initialize_quant_matrix( u32 *matrix )
  {
  	int i;
--- 431,437 ----
  }
  #endif
  
! #if 0 /* keep */
  static void initialize_quant_matrix( u32 *matrix )
  {
  	int i;
***************
*** 458,464 ****
  }
  #endif
  
! #if 0
  static void initialize_mpg_picture(struct mpg_picture *pic)
  {
  	int i;
--- 458,464 ----
  }
  #endif
  
! #if 0 /* keep */
  static void initialize_mpg_picture(struct mpg_picture *pic)
  {
  	int i;
***************
*** 485,491 ****
  }
  #endif
  
! #if 0
  static void mpg_set_picture_parameter( int32_t field_type, struct mpg_picture *pic )
  {
  	int16_t last_h_offset;
--- 485,491 ----
  }
  #endif
  
! #if 0 /* keep */
  static void mpg_set_picture_parameter( int32_t field_type, struct mpg_picture *pic )
  {
  	int16_t last_h_offset;
***************
*** 523,529 ****
  }
  #endif
  
! #if 0
  static void init_mpg_picture( struct mpg_picture *pic, int chan, int32_t field_type)
  {
  	pic->picture_header = 0;
--- 523,529 ----
  }
  #endif
  
! #if 0 /* keep */
  static void init_mpg_picture( struct mpg_picture *pic, int chan, int32_t field_type)
  {
  	pic->picture_header = 0;
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_frontend.c linux-sh4/drivers/media/dvb/dvb-core/dvb_frontend.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_frontend.c	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_frontend.c	Wed May 19 10:00:27 2010
***************
*** 31,52 ****
  #include <linux/wait.h>
  #include <linux/slab.h>
  #include <linux/poll.h>
  #include <linux/module.h>
- #include <linux/moduleparam.h>
  #include <linux/list.h>
  #include <linux/freezer.h>
  #include <linux/jiffies.h>
  #include <linux/kthread.h>
  #include <asm/processor.h>
  
  #include "dvb_frontend.h"
  #include "dvbdev.h"
  
  static int dvb_frontend_debug;
! static int dvb_shutdown_timeout = 5;
  static int dvb_force_auto_inversion;
  static int dvb_override_tune_delay;
  static int dvb_powerdown_on_sleep = 1;
  
  module_param_named(frontend_debug, dvb_frontend_debug, int, 0644);
  MODULE_PARM_DESC(frontend_debug, "Turn on/off frontend core debugging (default:off).");
--- 31,62 ----
  #include <linux/wait.h>
  #include <linux/slab.h>
  #include <linux/poll.h>
+ #include <linux/version.h>
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+ #include <linux/semaphore.h>
+ #endif
  #include <linux/module.h>
  #include <linux/list.h>
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+ #include <linux/suspend.h>
+ #else
  #include <linux/freezer.h>
+ #endif
  #include <linux/jiffies.h>
  #include <linux/kthread.h>
  #include <asm/processor.h>
  
  #include "dvb_frontend.h"
  #include "dvbdev.h"
+ #include "compat.h"
+ #include <linux/dvb/version.h>
  
  static int dvb_frontend_debug;
! static int dvb_shutdown_timeout;
  static int dvb_force_auto_inversion;
  static int dvb_override_tune_delay;
  static int dvb_powerdown_on_sleep = 1;
+ static int dvb_mfe_wait_time = 5;
  
  module_param_named(frontend_debug, dvb_frontend_debug, int, 0644);
  MODULE_PARM_DESC(frontend_debug, "Turn on/off frontend core debugging (default:off).");
***************
*** 58,63 ****
--- 68,75 ----
  MODULE_PARM_DESC(dvb_override_tune_delay, "0: normal (default), >0 => delay in milliseconds to wait for lock after a tune attempt");
  module_param(dvb_powerdown_on_sleep, int, 0644);
  MODULE_PARM_DESC(dvb_powerdown_on_sleep, "0: do not power down, 1: turn LNB voltage off on sleep (default)");
+ module_param(dvb_mfe_wait_time, int, 0644);
+ MODULE_PARM_DESC(dvb_mfe_wait_time, "Wait up to <mfe_wait_time> seconds on open() for multi-frontend to become available (default:5 seconds)");
  
  #define dprintk if (dvb_frontend_debug) printk
  
***************
*** 69,80 ****
  #define FESTATE_ZIGZAG_FAST 32
  #define FESTATE_ZIGZAG_SLOW 64
  #define FESTATE_DISEQC 128
  #define FESTATE_WAITFORLOCK (FESTATE_TUNING_FAST | FESTATE_TUNING_SLOW | FESTATE_ZIGZAG_FAST | FESTATE_ZIGZAG_SLOW | FESTATE_DISEQC)
  #define FESTATE_SEARCHING_FAST (FESTATE_TUNING_FAST | FESTATE_ZIGZAG_FAST)
  #define FESTATE_SEARCHING_SLOW (FESTATE_TUNING_SLOW | FESTATE_ZIGZAG_SLOW)
  #define FESTATE_LOSTLOCK (FESTATE_ZIGZAG_FAST | FESTATE_ZIGZAG_SLOW)
  
- #define FE_ALGO_HW		1
  /*
   * FESTATE_IDLE. No tuning parameters have been supplied and the loop is idling.
   * FESTATE_RETUNE. Parameters have been supplied, but we have not yet performed the first tune.
--- 81,92 ----
  #define FESTATE_ZIGZAG_FAST 32
  #define FESTATE_ZIGZAG_SLOW 64
  #define FESTATE_DISEQC 128
+ #define FESTATE_ERROR 256
  #define FESTATE_WAITFORLOCK (FESTATE_TUNING_FAST | FESTATE_TUNING_SLOW | FESTATE_ZIGZAG_FAST | FESTATE_ZIGZAG_SLOW | FESTATE_DISEQC)
  #define FESTATE_SEARCHING_FAST (FESTATE_TUNING_FAST | FESTATE_ZIGZAG_FAST)
  #define FESTATE_SEARCHING_SLOW (FESTATE_TUNING_SLOW | FESTATE_ZIGZAG_SLOW)
  #define FESTATE_LOSTLOCK (FESTATE_ZIGZAG_FAST | FESTATE_ZIGZAG_SLOW)
  
  /*
   * FESTATE_IDLE. No tuning parameters have been supplied and the loop is idling.
   * FESTATE_RETUNE. Parameters have been supplied, but we have not yet performed the first tune.
***************
*** 125,130 ****
--- 137,143 ----
  	unsigned int step_size;
  	int quality;
  	unsigned int check_wrapped;
+ 	enum dvbfe_search algo_status;
  };
  
  static void dvb_frontend_wakeup(struct dvb_frontend *fe);
***************
*** 136,144 ****
  	struct dvb_frontend_event *e;
  	int wp;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
! 	if (down_interruptible (&events->sem))
  		return;
  
  	wp = (events->eventw + 1) % MAX_EVENT;
--- 149,157 ----
  	struct dvb_frontend_event *e;
  	int wp;
  
! 	dprintk ("%s\n", __func__);
  
! 	if (mutex_lock_interruptible (&events->mtx))
  		return;
  
  	wp = (events->eventw + 1) % MAX_EVENT;
***************
*** 159,165 ****
  
  	events->eventw = wp;
  
! 	up (&events->sem);
  
  	e->status = status;
  
--- 172,178 ----
  
  	events->eventw = wp;
  
! 	mutex_unlock(&events->mtx);
  
  	e->status = status;
  
***************
*** 172,178 ****
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	struct dvb_fe_events *events = &fepriv->events;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
  	if (events->overflow) {
  		events->overflow = 0;
--- 185,191 ----
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	struct dvb_fe_events *events = &fepriv->events;
  
! 	dprintk ("%s\n", __func__);
  
  	if (events->overflow) {
  		events->overflow = 0;
***************
*** 197,203 ****
  			return ret;
  	}
  
! 	if (down_interruptible (&events->sem))
  		return -ERESTARTSYS;
  
  	memcpy (event, &events->events[events->eventr],
--- 210,216 ----
  			return ret;
  	}
  
! 	if (mutex_lock_interruptible (&events->mtx))
  		return -ERESTARTSYS;
  
  	memcpy (event, &events->events[events->eventr],
***************
*** 205,224 ****
  
  	events->eventr = (events->eventr + 1) % MAX_EVENT;
  
! 	up (&events->sem);
  
  	return 0;
  }
  
  static void dvb_frontend_init(struct dvb_frontend *fe)
  {
! 	dprintk ("DVB: initialising frontend %i (%s)...\n",
  		 fe->dvb->num,
  		 fe->ops.info.name);
  
  	if (fe->ops.init)
  		fe->ops.init(fe);
  	if (fe->ops.tuner_ops.init) {
  		fe->ops.tuner_ops.init(fe);
  		if (fe->ops.i2c_gate_ctrl)
  			fe->ops.i2c_gate_ctrl(fe, 0);
--- 218,240 ----
  
  	events->eventr = (events->eventr + 1) % MAX_EVENT;
  
! 	mutex_unlock(&events->mtx);
  
  	return 0;
  }
  
  static void dvb_frontend_init(struct dvb_frontend *fe)
  {
! 	dprintk ("DVB: initialising adapter %i frontend %i (%s)...\n",
  		 fe->dvb->num,
+ 		 fe->id,
  		 fe->ops.info.name);
  
  	if (fe->ops.init)
  		fe->ops.init(fe);
  	if (fe->ops.tuner_ops.init) {
+ 		if (fe->ops.i2c_gate_ctrl)
+ 			fe->ops.i2c_gate_ctrl(fe, 1);
  		fe->ops.tuner_ops.init(fe);
  		if (fe->ops.i2c_gate_ctrl)
  			fe->ops.i2c_gate_ctrl(fe, 0);
***************
*** 238,244 ****
  {
  	int q2;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
  	if (locked)
  		(fepriv->quality) = (fepriv->quality * 220 + 36*256) / 256;
--- 254,260 ----
  {
  	int q2;
  
! 	dprintk ("%s\n", __func__);
  
  	if (locked)
  		(fepriv->quality) = (fepriv->quality * 220 + 36*256) / 256;
***************
*** 262,267 ****
--- 278,284 ----
  {
  	int autoinversion;
  	int ready = 0;
+ 	int fe_set_err = 0;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	int original_inversion = fepriv->parameters.inversion;
  	u32 original_frequency = fepriv->parameters.frequency;
***************
*** 330,336 ****
  
  	dprintk("%s: drift:%i inversion:%i auto_step:%i "
  		"auto_sub_step:%i started_auto_step:%i\n",
! 		__FUNCTION__, fepriv->lnb_drift, fepriv->inversion,
  		fepriv->auto_step, fepriv->auto_sub_step, fepriv->started_auto_step);
  
  	/* set the frontend itself */
--- 347,353 ----
  
  	dprintk("%s: drift:%i inversion:%i auto_step:%i "
  		"auto_sub_step:%i started_auto_step:%i\n",
! 		__func__, fepriv->lnb_drift, fepriv->inversion,
  		fepriv->auto_step, fepriv->auto_sub_step, fepriv->started_auto_step);
  
  	/* set the frontend itself */
***************
*** 338,344 ****
  	if (autoinversion)
  		fepriv->parameters.inversion = fepriv->inversion;
  	if (fe->ops.set_frontend)
! 		fe->ops.set_frontend(fe, &fepriv->parameters);
  
  	fepriv->parameters.frequency = original_frequency;
  	fepriv->parameters.inversion = original_inversion;
--- 355,365 ----
  	if (autoinversion)
  		fepriv->parameters.inversion = fepriv->inversion;
  	if (fe->ops.set_frontend)
! 		fe_set_err = fe->ops.set_frontend(fe, &fepriv->parameters);
! 	if (fe_set_err < 0) {
! 		fepriv->state = FESTATE_ERROR;
! 		return fe_set_err;
! 	}
  
  	fepriv->parameters.frequency = original_frequency;
  	fepriv->parameters.inversion = original_inversion;
***************
*** 350,355 ****
--- 371,377 ----
  static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
  {
  	fe_status_t s = 0;
+ 	int retval = 0;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
  	/* if we've got no parameters, just keep idling */
***************
*** 363,370 ****
  	if (fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT) {
  		if (fepriv->state & FESTATE_RETUNE) {
  			if (fe->ops.set_frontend)
! 				fe->ops.set_frontend(fe, &fepriv->parameters);
! 			fepriv->state = FESTATE_TUNED;
  		}
  		fepriv->delay = 3*HZ;
  		fepriv->quality = 0;
--- 385,396 ----
  	if (fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT) {
  		if (fepriv->state & FESTATE_RETUNE) {
  			if (fe->ops.set_frontend)
! 				retval = fe->ops.set_frontend(fe,
! 							&fepriv->parameters);
! 			if (retval < 0)
! 				fepriv->state = FESTATE_ERROR;
! 			else
! 				fepriv->state = FESTATE_TUNED;
  		}
  		fepriv->delay = 3*HZ;
  		fepriv->quality = 0;
***************
*** 442,448 ****
  		fepriv->delay = fepriv->min_delay;
  
  		/* peform a tune */
! 		if (dvb_frontend_swzigzag_autotune(fe, fepriv->check_wrapped)) {
  			/* OK, if we've run out of trials at the fast speed.
  			 * Drop back to slow for the _next_ attempt */
  			fepriv->state = FESTATE_SEARCHING_SLOW;
--- 468,478 ----
  		fepriv->delay = fepriv->min_delay;
  
  		/* peform a tune */
! 		retval = dvb_frontend_swzigzag_autotune(fe,
! 							fepriv->check_wrapped);
! 		if (retval < 0) {
! 			return;
! 		} else if (retval) {
  			/* OK, if we've run out of trials at the fast speed.
  			 * Drop back to slow for the _next_ attempt */
  			fepriv->state = FESTATE_SEARCHING_SLOW;
***************
*** 510,518 ****
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	unsigned long timeout;
  	fe_status_t s;
  	struct dvb_frontend_parameters *params;
  
! 	dprintk("%s\n", __FUNCTION__);
  
  	fepriv->check_wrapped = 0;
  	fepriv->quality = 0;
--- 540,550 ----
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	unsigned long timeout;
  	fe_status_t s;
+ 	enum dvbfe_algo algo;
+ 
  	struct dvb_frontend_parameters *params;
  
! 	dprintk("%s\n", __func__);
  
  	fepriv->check_wrapped = 0;
  	fepriv->quality = 0;
***************
*** 527,538 ****
--- 559,578 ----
  	while (1) {
  		up(&fepriv->sem);	    /* is locked when we enter the thread... */
  restart:
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
  		timeout = wait_event_interruptible_timeout(fepriv->wait_queue,
  			dvb_frontend_should_wakeup(fe) || kthread_should_stop(),
  			fepriv->delay);
+ #else
+ 		timeout = wait_event_interruptible_timeout(fepriv->wait_queue,
+ 			dvb_frontend_should_wakeup(fe) || kthread_should_stop()
+ 				|| freezing(current),
+ 			fepriv->delay);
+ #endif
  
  		if (kthread_should_stop() || dvb_frontend_is_exiting(fe)) {
  			/* got signal or quitting */
+ 			fepriv->exit = 1;
  			break;
  		}
  
***************
*** 555,584 ****
  
  		/* do an iteration of the tuning loop */
  		if (fe->ops.get_frontend_algo) {
! 			if (fe->ops.get_frontend_algo(fe) == FE_ALGO_HW) {
! 				/* have we been asked to retune? */
! 				params = NULL;
  				if (fepriv->state & FESTATE_RETUNE) {
  					params = &fepriv->parameters;
  					fepriv->state = FESTATE_TUNED;
  				}
! 
! 				fe->ops.tune(fe, params, fepriv->tune_mode_flags, &fepriv->delay, &s);
  				if (s != fepriv->status) {
! 					dvb_frontend_add_event(fe, s);
  					fepriv->status = s;
  				}
! 			} else
! 				dvb_frontend_swzigzag(fe);
! 		} else
  			dvb_frontend_swzigzag(fe);
  	}
  
! 	if (dvb_shutdown_timeout) {
! 		if (dvb_powerdown_on_sleep)
! 			if (fe->ops.set_voltage)
! 				fe->ops.set_voltage(fe, SEC_VOLTAGE_OFF);
  		if (fe->ops.tuner_ops.sleep) {
  			fe->ops.tuner_ops.sleep(fe);
  			if (fe->ops.i2c_gate_ctrl)
  				fe->ops.i2c_gate_ctrl(fe, 0);
--- 595,683 ----
  
  		/* do an iteration of the tuning loop */
  		if (fe->ops.get_frontend_algo) {
! 			algo = fe->ops.get_frontend_algo(fe);
! 			switch (algo) {
! 			case DVBFE_ALGO_HW:
! 				dprintk("%s: Frontend ALGO = DVBFE_ALGO_HW\n", __func__);
! 				fepriv->delay = HZ / 10;
! 
  				if (fepriv->state & FESTATE_RETUNE) {
+ 					dprintk("%s: Retune requested, FESTATE_RETUNE\n", __func__);
+ 					if (fe->ops.tune && !fe->ops.tune(fe, &fepriv->parameters))
+ 						fepriv->state = FESTATE_TUNED; /* doesn't imply lock */
+ 				}
+ 				if (!(fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT) &&
+ 					fepriv->state == FESTATE_TUNED && fe->ops.read_status) {
+ 
+ 					fe->ops.read_status(fe, &s);
+ 					if (s != fepriv->status) {
+ 						dprintk("%s: state changed, adding current state\n", __func__);
+ 						dvb_frontend_add_event(fe, s);
+ 						fepriv->status = s;
+ 					}
+ 				}
+ 				break;
+ 			case DVBFE_ALGO_SW:
+ 				dprintk("%s: Frontend ALGO = DVBFE_ALGO_SW\n", __func__);
+ 				dvb_frontend_swzigzag(fe);
+ 				break;
+ 			case DVBFE_ALGO_CUSTOM:
+ 				params = NULL; /* have we been asked to RETUNE ?	*/
+ 				dprintk("%s: Frontend ALGO = DVBFE_ALGO_CUSTOM, state=%d\n", __func__, fepriv->state);
+ 				if (fepriv->state & FESTATE_RETUNE) {
+ 					dprintk("%s: Retune requested, FESTAT_RETUNE\n", __func__);
  					params = &fepriv->parameters;
  					fepriv->state = FESTATE_TUNED;
  				}
! 				/* Case where we are going to search for a carrier
! 				 * User asked us to retune again for some reason, possibly
! 				 * requesting a search with a new set of parameters
! 				 */
! 				if (fepriv->algo_status & DVBFE_ALGO_SEARCH_AGAIN) {
! 					if (fe->ops.search) {
! 						fepriv->algo_status = fe->ops.search(fe, &fepriv->parameters);
! 						/* We did do a search as was requested, the flags are
! 						 * now unset as well and has the flags wrt to search.
! 						 */
! 					} else {
! 						fepriv->algo_status &= ~DVBFE_ALGO_SEARCH_AGAIN;
! 					}
! 				}
! 				/* Track the carrier if the search was successful */
! 				if (fepriv->algo_status == DVBFE_ALGO_SEARCH_SUCCESS) {
! 					if (fe->ops.track)
! 						fe->ops.track(fe, &fepriv->parameters);
! 				} else {
! 					fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
! 					fepriv->delay = HZ / 2;
! 				}
! 				fe->ops.read_status(fe, &s);
  				if (s != fepriv->status) {
! 					dvb_frontend_add_event(fe, s); /* update event list */
  					fepriv->status = s;
+ 					if (!(s & FE_HAS_LOCK)) {
+ 						fepriv->delay = HZ / 10;
+ 						fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
+ 					} else {
+ 						fepriv->delay = 60 * HZ;
+ 					}
  				}
! 				break;
! 			default:
! 				dprintk("%s: UNDEFINED ALGO !\n", __func__);
! 				break;
! 			}
! 		} else {
  			dvb_frontend_swzigzag(fe);
+ 		}
  	}
  
! 	if (dvb_powerdown_on_sleep) {
! 		if (fe->ops.set_voltage)
! 			fe->ops.set_voltage(fe, SEC_VOLTAGE_OFF);
  		if (fe->ops.tuner_ops.sleep) {
+ 			if (fe->ops.i2c_gate_ctrl)
+ 				fe->ops.i2c_gate_ctrl(fe, 1);
  			fe->ops.tuner_ops.sleep(fe);
  			if (fe->ops.i2c_gate_ctrl)
  				fe->ops.i2c_gate_ctrl(fe, 0);
***************
*** 588,593 ****
--- 687,693 ----
  	}
  
  	fepriv->thread = NULL;
+ 	fepriv->exit = 0;
  	mb();
  
  	dvb_frontend_wakeup(fe);
***************
*** 598,604 ****
  {
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
  	fepriv->exit = 1;
  	mb();
--- 698,704 ----
  {
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
! 	dprintk ("%s\n", __func__);
  
  	fepriv->exit = 1;
  	mb();
***************
*** 666,672 ****
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	struct task_struct *fe_thread;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
  	if (fepriv->thread) {
  		if (!fepriv->exit)
--- 766,772 ----
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	struct task_struct *fe_thread;
  
! 	dprintk ("%s\n", __func__);
  
  	if (fepriv->thread) {
  		if (!fepriv->exit)
***************
*** 686,692 ****
  	mb();
  
  	fe_thread = kthread_run(dvb_frontend_thread, fe,
! 		"kdvb-fe-%i", fe->dvb->num);
  	if (IS_ERR(fe_thread)) {
  		ret = PTR_ERR(fe_thread);
  		printk("dvb_frontend_start: failed to start kthread (%d)\n", ret);
--- 786,792 ----
  	mb();
  
  	fe_thread = kthread_run(dvb_frontend_thread, fe,
! 		"kdvb-ad-%i-fe-%i", fe->dvb->num,fe->id);
  	if (IS_ERR(fe_thread)) {
  		ret = PTR_ERR(fe_thread);
  		printk("dvb_frontend_start: failed to start kthread (%d)\n", ret);
***************
*** 697,702 ****
--- 797,1499 ----
  	return 0;
  }
  
+ static void dvb_frontend_get_frequeny_limits(struct dvb_frontend *fe,
+ 					u32 *freq_min, u32 *freq_max)
+ {
+ 	*freq_min = max(fe->ops.info.frequency_min, fe->ops.tuner_ops.info.frequency_min);
+ 
+ 	if (fe->ops.info.frequency_max == 0)
+ 		*freq_max = fe->ops.tuner_ops.info.frequency_max;
+ 	else if (fe->ops.tuner_ops.info.frequency_max == 0)
+ 		*freq_max = fe->ops.info.frequency_max;
+ 	else
+ 		*freq_max = min(fe->ops.info.frequency_max, fe->ops.tuner_ops.info.frequency_max);
+ 
+ 	if (*freq_min == 0 || *freq_max == 0)
+ 		printk(KERN_WARNING "DVB: adapter %i frontend %u frequency limits undefined - fix the driver\n",
+ 		       fe->dvb->num,fe->id);
+ }
+ 
+ static int dvb_frontend_check_parameters(struct dvb_frontend *fe,
+ 				struct dvb_frontend_parameters *parms)
+ {
+ 	u32 freq_min;
+ 	u32 freq_max;
+ 
+ 	/* range check: frequency */
+ 	dvb_frontend_get_frequeny_limits(fe, &freq_min, &freq_max);
+ 	if ((freq_min && parms->frequency < freq_min) ||
+ 	    (freq_max && parms->frequency > freq_max)) {
+ 		printk(KERN_WARNING "DVB: adapter %i frontend %i frequency %u out of range (%u..%u)\n",
+ 		       fe->dvb->num, fe->id, parms->frequency, freq_min, freq_max);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* range check: symbol rate */
+ 	if (fe->ops.info.type == FE_QPSK) {
+ 		if ((fe->ops.info.symbol_rate_min &&
+ 		     parms->u.qpsk.symbol_rate < fe->ops.info.symbol_rate_min) ||
+ 		    (fe->ops.info.symbol_rate_max &&
+ 		     parms->u.qpsk.symbol_rate > fe->ops.info.symbol_rate_max)) {
+ 			printk(KERN_WARNING "DVB: adapter %i frontend %i symbol rate %u out of range (%u..%u)\n",
+ 			       fe->dvb->num, fe->id, parms->u.qpsk.symbol_rate,
+ 			       fe->ops.info.symbol_rate_min, fe->ops.info.symbol_rate_max);
+ 			return -EINVAL;
+ 		}
+ 
+ 	} else if (fe->ops.info.type == FE_QAM) {
+ 		if ((fe->ops.info.symbol_rate_min &&
+ 		     parms->u.qam.symbol_rate < fe->ops.info.symbol_rate_min) ||
+ 		    (fe->ops.info.symbol_rate_max &&
+ 		     parms->u.qam.symbol_rate > fe->ops.info.symbol_rate_max)) {
+ 			printk(KERN_WARNING "DVB: adapter %i frontend %i symbol rate %u out of range (%u..%u)\n",
+ 			       fe->dvb->num, fe->id, parms->u.qam.symbol_rate,
+ 			       fe->ops.info.symbol_rate_min, fe->ops.info.symbol_rate_max);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/* check for supported modulation */
+ 	if (fe->ops.info.type == FE_QAM &&
+ 	    (parms->u.qam.modulation > QAM_AUTO ||
+ 	     !((1 << (parms->u.qam.modulation + 10)) & fe->ops.info.caps))) {
+ 		printk(KERN_WARNING "DVB: adapter %i frontend %i modulation %u not supported\n",
+ 		       fe->dvb->num, fe->id, parms->u.qam.modulation);
+ 			return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int dvb_frontend_clear_cache(struct dvb_frontend *fe)
+ {
+ 	int i;
+ 
+ 	memset(&(fe->dtv_property_cache), 0,
+ 			sizeof(struct dtv_frontend_properties));
+ 
+ 	fe->dtv_property_cache.state = DTV_CLEAR;
+ 	fe->dtv_property_cache.delivery_system = SYS_UNDEFINED;
+ 	fe->dtv_property_cache.inversion = INVERSION_AUTO;
+ 	fe->dtv_property_cache.fec_inner = FEC_AUTO;
+ 	fe->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_AUTO;
+ 	fe->dtv_property_cache.bandwidth_hz = BANDWIDTH_AUTO;
+ 	fe->dtv_property_cache.guard_interval = GUARD_INTERVAL_AUTO;
+ 	fe->dtv_property_cache.hierarchy = HIERARCHY_AUTO;
+ 	fe->dtv_property_cache.symbol_rate = QAM_AUTO;
+ 	fe->dtv_property_cache.code_rate_HP = FEC_AUTO;
+ 	fe->dtv_property_cache.code_rate_LP = FEC_AUTO;
+ 
+ 	fe->dtv_property_cache.isdbt_partial_reception = -1;
+ 	fe->dtv_property_cache.isdbt_sb_mode = -1;
+ 	fe->dtv_property_cache.isdbt_sb_subchannel = -1;
+ 	fe->dtv_property_cache.isdbt_sb_segment_idx = -1;
+ 	fe->dtv_property_cache.isdbt_sb_segment_count = -1;
+ 	fe->dtv_property_cache.isdbt_layer_enabled = 0x7;
+ 	for (i = 0; i < 3; i++) {
+ 		fe->dtv_property_cache.layer[i].fec = FEC_AUTO;
+ 		fe->dtv_property_cache.layer[i].modulation = QAM_AUTO;
+ 		fe->dtv_property_cache.layer[i].interleaving = -1;
+ 		fe->dtv_property_cache.layer[i].segment_count = -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ #define _DTV_CMD(n, s, b) \
+ [n] = { \
+ 	.name = #n, \
+ 	.cmd  = n, \
+ 	.set  = s,\
+ 	.buffer = b \
+ }
+ 
+ static struct dtv_cmds_h dtv_cmds[] = {
+ 	_DTV_CMD(DTV_TUNE, 1, 0),
+ 	_DTV_CMD(DTV_CLEAR, 1, 0),
+ 
+ 	/* Set */
+ 	_DTV_CMD(DTV_FREQUENCY, 1, 0),
+ 	_DTV_CMD(DTV_BANDWIDTH_HZ, 1, 0),
+ 	_DTV_CMD(DTV_MODULATION, 1, 0),
+ 	_DTV_CMD(DTV_INVERSION, 1, 0),
+ 	_DTV_CMD(DTV_DISEQC_MASTER, 1, 1),
+ 	_DTV_CMD(DTV_SYMBOL_RATE, 1, 0),
+ 	_DTV_CMD(DTV_INNER_FEC, 1, 0),
+ 	_DTV_CMD(DTV_VOLTAGE, 1, 0),
+ 	_DTV_CMD(DTV_TONE, 1, 0),
+ 	_DTV_CMD(DTV_PILOT, 1, 0),
+ 	_DTV_CMD(DTV_ROLLOFF, 1, 0),
+ 	_DTV_CMD(DTV_DELIVERY_SYSTEM, 1, 0),
+ 	_DTV_CMD(DTV_HIERARCHY, 1, 0),
+ 	_DTV_CMD(DTV_CODE_RATE_HP, 1, 0),
+ 	_DTV_CMD(DTV_CODE_RATE_LP, 1, 0),
+ 	_DTV_CMD(DTV_GUARD_INTERVAL, 1, 0),
+ 	_DTV_CMD(DTV_TRANSMISSION_MODE, 1, 0),
+ 
+ 	_DTV_CMD(DTV_ISDBT_PARTIAL_RECEPTION, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_SOUND_BROADCASTING, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_SB_SUBCHANNEL_ID, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_SB_SEGMENT_IDX, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_SB_SEGMENT_COUNT, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYER_ENABLED, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERA_FEC, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERA_MODULATION, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERA_SEGMENT_COUNT, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERA_TIME_INTERLEAVING, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERB_FEC, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERB_MODULATION, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERB_SEGMENT_COUNT, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERB_TIME_INTERLEAVING, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERC_FEC, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERC_MODULATION, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERC_SEGMENT_COUNT, 1, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERC_TIME_INTERLEAVING, 1, 0),
+ 
+ 	_DTV_CMD(DTV_ISDBT_PARTIAL_RECEPTION, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_SOUND_BROADCASTING, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_SB_SUBCHANNEL_ID, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_SB_SEGMENT_IDX, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_SB_SEGMENT_COUNT, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYER_ENABLED, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERA_FEC, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERA_MODULATION, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERA_SEGMENT_COUNT, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERA_TIME_INTERLEAVING, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERB_FEC, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERB_MODULATION, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERB_SEGMENT_COUNT, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERB_TIME_INTERLEAVING, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERC_FEC, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERC_MODULATION, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERC_SEGMENT_COUNT, 0, 0),
+ 	_DTV_CMD(DTV_ISDBT_LAYERC_TIME_INTERLEAVING, 0, 0),
+ 
+ 	_DTV_CMD(DTV_ISDBS_TS_ID, 1, 0),
+ 
+ 	/* Get */
+ 	_DTV_CMD(DTV_DISEQC_SLAVE_REPLY, 0, 1),
+ 	_DTV_CMD(DTV_API_VERSION, 0, 0),
+ 	_DTV_CMD(DTV_CODE_RATE_HP, 0, 0),
+ 	_DTV_CMD(DTV_CODE_RATE_LP, 0, 0),
+ 	_DTV_CMD(DTV_GUARD_INTERVAL, 0, 0),
+ 	_DTV_CMD(DTV_TRANSMISSION_MODE, 0, 0),
+ 	_DTV_CMD(DTV_HIERARCHY, 0, 0),
+ };
+ 
+ static void dtv_property_dump(struct dtv_property *tvp)
+ {
+ 	int i;
+ 
+ 	if (tvp->cmd <= 0 || tvp->cmd > DTV_MAX_COMMAND) {
+ 		printk(KERN_WARNING "%s: tvp.cmd = 0x%08x undefined\n",
+ 			__func__, tvp->cmd);
+ 		return;
+ 	}
+ 
+ 	dprintk("%s() tvp.cmd    = 0x%08x (%s)\n"
+ 		,__func__
+ 		,tvp->cmd
+ 		,dtv_cmds[ tvp->cmd ].name);
+ 
+ 	if(dtv_cmds[ tvp->cmd ].buffer) {
+ 
+ 		dprintk("%s() tvp.u.buffer.len = 0x%02x\n"
+ 			,__func__
+ 			,tvp->u.buffer.len);
+ 
+ 		for(i = 0; i < tvp->u.buffer.len; i++)
+ 			dprintk("%s() tvp.u.buffer.data[0x%02x] = 0x%02x\n"
+ 				,__func__
+ 				,i
+ 				,tvp->u.buffer.data[i]);
+ 
+ 	} else
+ 		dprintk("%s() tvp.u.data = %u\n", __func__, tvp->u.data);
+ }
+ 
+ static int is_legacy_delivery_system(fe_delivery_system_t s)
+ {
+ 	if((s == SYS_UNDEFINED) || (s == SYS_DVBC_ANNEX_AC) ||
+ 	   (s == SYS_DVBC_ANNEX_B) || (s == SYS_DVBT) || (s == SYS_DVBS) ||
+ 	   (s == SYS_ATSC))
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ /* Synchronise the legacy tuning parameters into the cache, so that demodulator
+  * drivers can use a single set_frontend tuning function, regardless of whether
+  * it's being used for the legacy or new API, reducing code and complexity.
+  */
+ static void dtv_property_cache_sync(struct dvb_frontend *fe,
+ 				    struct dvb_frontend_parameters *p)
+ {
+ 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+ 
+ 	c->frequency = p->frequency;
+ 	c->inversion = p->inversion;
+ 
+ 	switch (fe->ops.info.type) {
+ 	case FE_QPSK:
+ 		c->modulation = QPSK;   /* implied for DVB-S in legacy API */
+ 		c->rolloff = ROLLOFF_35;/* implied for DVB-S */
+ 		c->symbol_rate = p->u.qpsk.symbol_rate;
+ 		c->fec_inner = p->u.qpsk.fec_inner;
+ 		c->delivery_system = SYS_DVBS;
+ 		break;
+ 	case FE_QAM:
+ 		c->symbol_rate = p->u.qam.symbol_rate;
+ 		c->fec_inner = p->u.qam.fec_inner;
+ 		c->modulation = p->u.qam.modulation;
+ 		c->delivery_system = SYS_DVBC_ANNEX_AC;
+ 		break;
+ 	case FE_OFDM:
+ 		if (p->u.ofdm.bandwidth == BANDWIDTH_6_MHZ)
+ 			c->bandwidth_hz = 6000000;
+ 		else if (p->u.ofdm.bandwidth == BANDWIDTH_7_MHZ)
+ 			c->bandwidth_hz = 7000000;
+ 		else if (p->u.ofdm.bandwidth == BANDWIDTH_8_MHZ)
+ 			c->bandwidth_hz = 8000000;
+ 		else
+ 			/* Including BANDWIDTH_AUTO */
+ 			c->bandwidth_hz = 0;
+ 		c->code_rate_HP = p->u.ofdm.code_rate_HP;
+ 		c->code_rate_LP = p->u.ofdm.code_rate_LP;
+ 		c->modulation = p->u.ofdm.constellation;
+ 		c->transmission_mode = p->u.ofdm.transmission_mode;
+ 		c->guard_interval = p->u.ofdm.guard_interval;
+ 		c->hierarchy = p->u.ofdm.hierarchy_information;
+ 		c->delivery_system = SYS_DVBT;
+ 		break;
+ 	case FE_ATSC:
+ 		c->modulation = p->u.vsb.modulation;
+ 		if ((c->modulation == VSB_8) || (c->modulation == VSB_16))
+ 			c->delivery_system = SYS_ATSC;
+ 		else
+ 			c->delivery_system = SYS_DVBC_ANNEX_B;
+ 		break;
+ 	}
+ }
+ 
+ /* Ensure the cached values are set correctly in the frontend
+  * legacy tuning structures, for the advanced tuning API.
+  */
+ static void dtv_property_legacy_params_sync(struct dvb_frontend *fe)
+ {
+ 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+ 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+ 	struct dvb_frontend_parameters *p = &fepriv->parameters;
+ 
+ 	p->frequency = c->frequency;
+ 	p->inversion = c->inversion;
+ 
+ 	switch (fe->ops.info.type) {
+ 	case FE_QPSK:
+ 		dprintk("%s() Preparing QPSK req\n", __func__);
+ 		p->u.qpsk.symbol_rate = c->symbol_rate;
+ 		p->u.qpsk.fec_inner = c->fec_inner;
+ 		c->delivery_system = SYS_DVBS;
+ 		break;
+ 	case FE_QAM:
+ 		dprintk("%s() Preparing QAM req\n", __func__);
+ 		p->u.qam.symbol_rate = c->symbol_rate;
+ 		p->u.qam.fec_inner = c->fec_inner;
+ 		p->u.qam.modulation = c->modulation;
+ 		c->delivery_system = SYS_DVBC_ANNEX_AC;
+ 		break;
+ 	case FE_OFDM:
+ 		dprintk("%s() Preparing OFDM req\n", __func__);
+ 		if (c->bandwidth_hz == 6000000)
+ 			p->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;
+ 		else if (c->bandwidth_hz == 7000000)
+ 			p->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;
+ 		else if (c->bandwidth_hz == 8000000)
+ 			p->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;
+ 		else
+ 			p->u.ofdm.bandwidth = BANDWIDTH_AUTO;
+ 		p->u.ofdm.code_rate_HP = c->code_rate_HP;
+ 		p->u.ofdm.code_rate_LP = c->code_rate_LP;
+ 		p->u.ofdm.constellation = c->modulation;
+ 		p->u.ofdm.transmission_mode = c->transmission_mode;
+ 		p->u.ofdm.guard_interval = c->guard_interval;
+ 		p->u.ofdm.hierarchy_information = c->hierarchy;
+ 		c->delivery_system = SYS_DVBT;
+ 		break;
+ 	case FE_ATSC:
+ 		dprintk("%s() Preparing VSB req\n", __func__);
+ 		p->u.vsb.modulation = c->modulation;
+ 		if ((c->modulation == VSB_8) || (c->modulation == VSB_16))
+ 			c->delivery_system = SYS_ATSC;
+ 		else
+ 			c->delivery_system = SYS_DVBC_ANNEX_B;
+ 		break;
+ 	}
+ }
+ 
+ /* Ensure the cached values are set correctly in the frontend
+  * legacy tuning structures, for the legacy tuning API.
+  */
+ static void dtv_property_adv_params_sync(struct dvb_frontend *fe)
+ {
+ 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+ 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+ 	struct dvb_frontend_parameters *p = &fepriv->parameters;
+ 
+ 	p->frequency = c->frequency;
+ 	p->inversion = c->inversion;
+ 
+ 	switch(c->modulation) {
+ 	case PSK_8:
+ 	case APSK_16:
+ 	case APSK_32:
+ 	case QPSK:
+ 		p->u.qpsk.symbol_rate = c->symbol_rate;
+ 		p->u.qpsk.fec_inner = c->fec_inner;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	if(c->delivery_system == SYS_ISDBT) {
+ 		/* Fake out a generic DVB-T request so we pass validation in the ioctl */
+ 		p->frequency = c->frequency;
+ 		p->inversion = c->inversion;
+ 		p->u.ofdm.constellation = QAM_AUTO;
+ 		p->u.ofdm.code_rate_HP = FEC_AUTO;
+ 		p->u.ofdm.code_rate_LP = FEC_AUTO;
+ 		p->u.ofdm.transmission_mode = TRANSMISSION_MODE_AUTO;
+ 		p->u.ofdm.guard_interval = GUARD_INTERVAL_AUTO;
+ 		p->u.ofdm.hierarchy_information = HIERARCHY_AUTO;
+ 		if (c->bandwidth_hz == 8000000)
+ 			p->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;
+ 		else if (c->bandwidth_hz == 7000000)
+ 			p->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;
+ 		else if (c->bandwidth_hz == 6000000)
+ 			p->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;
+ 		else
+ 			p->u.ofdm.bandwidth = BANDWIDTH_AUTO;
+ 	}
+ }
+ 
+ static void dtv_property_cache_submit(struct dvb_frontend *fe)
+ {
+ 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+ 
+ 	/* For legacy delivery systems we don't need the delivery_system to
+ 	 * be specified, but we populate the older structures from the cache
+ 	 * so we can call set_frontend on older drivers.
+ 	 */
+ 	if(is_legacy_delivery_system(c->delivery_system)) {
+ 
+ 		dprintk("%s() legacy, modulation = %d\n", __func__, c->modulation);
+ 		dtv_property_legacy_params_sync(fe);
+ 
+ 	} else {
+ 		dprintk("%s() adv, modulation = %d\n", __func__, c->modulation);
+ 
+ 		/* For advanced delivery systems / modulation types ...
+ 		 * we seed the lecacy dvb_frontend_parameters structure
+ 		 * so that the sanity checking code later in the IOCTL processing
+ 		 * can validate our basic frequency ranges, symbolrates, modulation
+ 		 * etc.
+ 		 */
+ 		dtv_property_adv_params_sync(fe);
+ 	}
+ }
+ 
+ static int dvb_frontend_ioctl_legacy(struct inode *inode, struct file *file,
+ 			unsigned int cmd, void *parg);
+ static int dvb_frontend_ioctl_properties(struct inode *inode, struct file *file,
+ 			unsigned int cmd, void *parg);
+ 
+ static int dtv_property_process_get(struct dvb_frontend *fe,
+ 				    struct dtv_property *tvp,
+ 				    struct inode *inode, struct file *file)
+ {
+ 	int r = 0;
+ 
+ 	/* Allow the frontend to validate incoming properties */
+ 	if (fe->ops.get_property)
+ 		r = fe->ops.get_property(fe, tvp);
+ 
+ 	if (r < 0)
+ 		return r;
+ 
+ 	switch(tvp->cmd) {
+ 	case DTV_FREQUENCY:
+ 		tvp->u.data = fe->dtv_property_cache.frequency;
+ 		break;
+ 	case DTV_MODULATION:
+ 		tvp->u.data = fe->dtv_property_cache.modulation;
+ 		break;
+ 	case DTV_BANDWIDTH_HZ:
+ 		tvp->u.data = fe->dtv_property_cache.bandwidth_hz;
+ 		break;
+ 	case DTV_INVERSION:
+ 		tvp->u.data = fe->dtv_property_cache.inversion;
+ 		break;
+ 	case DTV_SYMBOL_RATE:
+ 		tvp->u.data = fe->dtv_property_cache.symbol_rate;
+ 		break;
+ 	case DTV_INNER_FEC:
+ 		tvp->u.data = fe->dtv_property_cache.fec_inner;
+ 		break;
+ 	case DTV_PILOT:
+ 		tvp->u.data = fe->dtv_property_cache.pilot;
+ 		break;
+ 	case DTV_ROLLOFF:
+ 		tvp->u.data = fe->dtv_property_cache.rolloff;
+ 		break;
+ 	case DTV_DELIVERY_SYSTEM:
+ 		tvp->u.data = fe->dtv_property_cache.delivery_system;
+ 		break;
+ 	case DTV_VOLTAGE:
+ 		tvp->u.data = fe->dtv_property_cache.voltage;
+ 		break;
+ 	case DTV_TONE:
+ 		tvp->u.data = fe->dtv_property_cache.sectone;
+ 		break;
+ 	case DTV_API_VERSION:
+ 		tvp->u.data = (DVB_API_VERSION << 8) | DVB_API_VERSION_MINOR;
+ 		break;
+ 	case DTV_CODE_RATE_HP:
+ 		tvp->u.data = fe->dtv_property_cache.code_rate_HP;
+ 		break;
+ 	case DTV_CODE_RATE_LP:
+ 		tvp->u.data = fe->dtv_property_cache.code_rate_LP;
+ 		break;
+ 	case DTV_GUARD_INTERVAL:
+ 		tvp->u.data = fe->dtv_property_cache.guard_interval;
+ 		break;
+ 	case DTV_TRANSMISSION_MODE:
+ 		tvp->u.data = fe->dtv_property_cache.transmission_mode;
+ 		break;
+ 	case DTV_HIERARCHY:
+ 		tvp->u.data = fe->dtv_property_cache.hierarchy;
+ 		break;
+ 
+ 	/* ISDB-T Support here */
+ 	case DTV_ISDBT_PARTIAL_RECEPTION:
+ 		tvp->u.data = fe->dtv_property_cache.isdbt_partial_reception;
+ 		break;
+ 	case DTV_ISDBT_SOUND_BROADCASTING:
+ 		tvp->u.data = fe->dtv_property_cache.isdbt_sb_mode;
+ 		break;
+ 	case DTV_ISDBT_SB_SUBCHANNEL_ID:
+ 		tvp->u.data = fe->dtv_property_cache.isdbt_sb_subchannel;
+ 		break;
+ 	case DTV_ISDBT_SB_SEGMENT_IDX:
+ 		tvp->u.data = fe->dtv_property_cache.isdbt_sb_segment_idx;
+ 		break;
+ 	case DTV_ISDBT_SB_SEGMENT_COUNT:
+ 		tvp->u.data = fe->dtv_property_cache.isdbt_sb_segment_count;
+ 		break;
+ 	case DTV_ISDBT_LAYER_ENABLED:
+ 		tvp->u.data = fe->dtv_property_cache.isdbt_layer_enabled;
+ 		break;
+ 	case DTV_ISDBT_LAYERA_FEC:
+ 		tvp->u.data = fe->dtv_property_cache.layer[0].fec;
+ 		break;
+ 	case DTV_ISDBT_LAYERA_MODULATION:
+ 		tvp->u.data = fe->dtv_property_cache.layer[0].modulation;
+ 		break;
+ 	case DTV_ISDBT_LAYERA_SEGMENT_COUNT:
+ 		tvp->u.data = fe->dtv_property_cache.layer[0].segment_count;
+ 		break;
+ 	case DTV_ISDBT_LAYERA_TIME_INTERLEAVING:
+ 		tvp->u.data = fe->dtv_property_cache.layer[0].interleaving;
+ 		break;
+ 	case DTV_ISDBT_LAYERB_FEC:
+ 		tvp->u.data = fe->dtv_property_cache.layer[1].fec;
+ 		break;
+ 	case DTV_ISDBT_LAYERB_MODULATION:
+ 		tvp->u.data = fe->dtv_property_cache.layer[1].modulation;
+ 		break;
+ 	case DTV_ISDBT_LAYERB_SEGMENT_COUNT:
+ 		tvp->u.data = fe->dtv_property_cache.layer[1].segment_count;
+ 		break;
+ 	case DTV_ISDBT_LAYERB_TIME_INTERLEAVING:
+ 		tvp->u.data = fe->dtv_property_cache.layer[1].interleaving;
+ 		break;
+ 	case DTV_ISDBT_LAYERC_FEC:
+ 		tvp->u.data = fe->dtv_property_cache.layer[2].fec;
+ 		break;
+ 	case DTV_ISDBT_LAYERC_MODULATION:
+ 		tvp->u.data = fe->dtv_property_cache.layer[2].modulation;
+ 		break;
+ 	case DTV_ISDBT_LAYERC_SEGMENT_COUNT:
+ 		tvp->u.data = fe->dtv_property_cache.layer[2].segment_count;
+ 		break;
+ 	case DTV_ISDBT_LAYERC_TIME_INTERLEAVING:
+ 		tvp->u.data = fe->dtv_property_cache.layer[2].interleaving;
+ 		break;
+ 	case DTV_ISDBS_TS_ID:
+ 		tvp->u.data = fe->dtv_property_cache.isdbs_ts_id;
+ 		break;
+ 	default:
+ 		r = -1;
+ 	}
+ 
+ 	dtv_property_dump(tvp);
+ 
+ 	return r;
+ }
+ 
+ static int dtv_property_process_set(struct dvb_frontend *fe,
+ 				    struct dtv_property *tvp,
+ 				    struct inode *inode,
+ 				    struct file *file)
+ {
+ 	int r = 0;
+ 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+ 	dtv_property_dump(tvp);
+ 
+ 	/* Allow the frontend to validate incoming properties */
+ 	if (fe->ops.set_property)
+ 		r = fe->ops.set_property(fe, tvp);
+ 
+ 	if (r < 0)
+ 		return r;
+ 
+ 	switch(tvp->cmd) {
+ 	case DTV_CLEAR:
+ 		/* Reset a cache of data specific to the frontend here. This does
+ 		 * not effect hardware.
+ 		 */
+ 		dvb_frontend_clear_cache(fe);
+ 		dprintk("%s() Flushing property cache\n", __func__);
+ 		break;
+ 	case DTV_TUNE:
+ 		/* interpret the cache of data, build either a traditional frontend
+ 		 * tunerequest so we can pass validation in the FE_SET_FRONTEND
+ 		 * ioctl.
+ 		 */
+ 		fe->dtv_property_cache.state = tvp->cmd;
+ 		dprintk("%s() Finalised property cache\n", __func__);
+ 		dtv_property_cache_submit(fe);
+ 
+ 		r |= dvb_frontend_ioctl_legacy(inode, file, FE_SET_FRONTEND,
+ 			&fepriv->parameters);
+ 		break;
+ 	case DTV_FREQUENCY:
+ 		fe->dtv_property_cache.frequency = tvp->u.data;
+ 		break;
+ 	case DTV_MODULATION:
+ 		fe->dtv_property_cache.modulation = tvp->u.data;
+ 		break;
+ 	case DTV_BANDWIDTH_HZ:
+ 		fe->dtv_property_cache.bandwidth_hz = tvp->u.data;
+ 		break;
+ 	case DTV_INVERSION:
+ 		fe->dtv_property_cache.inversion = tvp->u.data;
+ 		break;
+ 	case DTV_SYMBOL_RATE:
+ 		fe->dtv_property_cache.symbol_rate = tvp->u.data;
+ 		break;
+ 	case DTV_INNER_FEC:
+ 		fe->dtv_property_cache.fec_inner = tvp->u.data;
+ 		break;
+ 	case DTV_PILOT:
+ 		fe->dtv_property_cache.pilot = tvp->u.data;
+ 		break;
+ 	case DTV_ROLLOFF:
+ 		fe->dtv_property_cache.rolloff = tvp->u.data;
+ 		break;
+ 	case DTV_DELIVERY_SYSTEM:
+ 		fe->dtv_property_cache.delivery_system = tvp->u.data;
+ 		break;
+ 	case DTV_VOLTAGE:
+ 		fe->dtv_property_cache.voltage = tvp->u.data;
+ 		r = dvb_frontend_ioctl_legacy(inode, file, FE_SET_VOLTAGE,
+ 			(void *)fe->dtv_property_cache.voltage);
+ 		break;
+ 	case DTV_TONE:
+ 		fe->dtv_property_cache.sectone = tvp->u.data;
+ 		r = dvb_frontend_ioctl_legacy(inode, file, FE_SET_TONE,
+ 			(void *)fe->dtv_property_cache.sectone);
+ 		break;
+ 	case DTV_CODE_RATE_HP:
+ 		fe->dtv_property_cache.code_rate_HP = tvp->u.data;
+ 		break;
+ 	case DTV_CODE_RATE_LP:
+ 		fe->dtv_property_cache.code_rate_LP = tvp->u.data;
+ 		break;
+ 	case DTV_GUARD_INTERVAL:
+ 		fe->dtv_property_cache.guard_interval = tvp->u.data;
+ 		break;
+ 	case DTV_TRANSMISSION_MODE:
+ 		fe->dtv_property_cache.transmission_mode = tvp->u.data;
+ 		break;
+ 	case DTV_HIERARCHY:
+ 		fe->dtv_property_cache.hierarchy = tvp->u.data;
+ 		break;
+ 
+ 	/* ISDB-T Support here */
+ 	case DTV_ISDBT_PARTIAL_RECEPTION:
+ 		fe->dtv_property_cache.isdbt_partial_reception = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_SOUND_BROADCASTING:
+ 		fe->dtv_property_cache.isdbt_sb_mode = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_SB_SUBCHANNEL_ID:
+ 		fe->dtv_property_cache.isdbt_sb_subchannel = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_SB_SEGMENT_IDX:
+ 		fe->dtv_property_cache.isdbt_sb_segment_idx = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_SB_SEGMENT_COUNT:
+ 		fe->dtv_property_cache.isdbt_sb_segment_count = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYER_ENABLED:
+ 		fe->dtv_property_cache.isdbt_layer_enabled = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERA_FEC:
+ 		fe->dtv_property_cache.layer[0].fec = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERA_MODULATION:
+ 		fe->dtv_property_cache.layer[0].modulation = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERA_SEGMENT_COUNT:
+ 		fe->dtv_property_cache.layer[0].segment_count = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERA_TIME_INTERLEAVING:
+ 		fe->dtv_property_cache.layer[0].interleaving = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERB_FEC:
+ 		fe->dtv_property_cache.layer[1].fec = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERB_MODULATION:
+ 		fe->dtv_property_cache.layer[1].modulation = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERB_SEGMENT_COUNT:
+ 		fe->dtv_property_cache.layer[1].segment_count = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERB_TIME_INTERLEAVING:
+ 		fe->dtv_property_cache.layer[1].interleaving = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERC_FEC:
+ 		fe->dtv_property_cache.layer[2].fec = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERC_MODULATION:
+ 		fe->dtv_property_cache.layer[2].modulation = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERC_SEGMENT_COUNT:
+ 		fe->dtv_property_cache.layer[2].segment_count = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBT_LAYERC_TIME_INTERLEAVING:
+ 		fe->dtv_property_cache.layer[2].interleaving = tvp->u.data;
+ 		break;
+ 	case DTV_ISDBS_TS_ID:
+ 		fe->dtv_property_cache.isdbs_ts_id = tvp->u.data;
+ 		break;
+ 	default:
+ 		r = -1;
+ 	}
+ 
+ 	return r;
+ }
+ 
  static int dvb_frontend_ioctl(struct inode *inode, struct file *file,
  			unsigned int cmd, void *parg)
  {
***************
*** 705,713 ****
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	int err = -EOPNOTSUPP;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
! 	if (!fe || fepriv->exit)
  		return -ENODEV;
  
  	if ((file->f_flags & O_ACCMODE) == O_RDONLY &&
--- 1502,1510 ----
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	int err = -EOPNOTSUPP;
  
! 	dprintk("%s (%d)\n", __func__, _IOC_NR(cmd));
  
! 	if (fepriv->exit)
  		return -ENODEV;
  
  	if ((file->f_flags & O_ACCMODE) == O_RDONLY &&
***************
*** 718,727 ****
--- 1515,1629 ----
  	if (down_interruptible (&fepriv->sem))
  		return -ERESTARTSYS;
  
+ 	if ((cmd == FE_SET_PROPERTY) || (cmd == FE_GET_PROPERTY))
+ 		err = dvb_frontend_ioctl_properties(inode, file, cmd, parg);
+ 	else {
+ 		fe->dtv_property_cache.state = DTV_UNDEFINED;
+ 		err = dvb_frontend_ioctl_legacy(inode, file, cmd, parg);
+ 	}
+ 
+ 	up(&fepriv->sem);
+ 	return err;
+ }
+ 
+ static int dvb_frontend_ioctl_properties(struct inode *inode, struct file *file,
+ 			unsigned int cmd, void *parg)
+ {
+ 	struct dvb_device *dvbdev = file->private_data;
+ 	struct dvb_frontend *fe = dvbdev->priv;
+ 	int err = 0;
+ 
+ 	struct dtv_properties *tvps = NULL;
+ 	struct dtv_property *tvp = NULL;
+ 	int i;
+ 
+ 	dprintk("%s\n", __func__);
+ 
+ 	if(cmd == FE_SET_PROPERTY) {
+ 		tvps = (struct dtv_properties __user *)parg;
+ 
+ 		dprintk("%s() properties.num = %d\n", __func__, tvps->num);
+ 		dprintk("%s() properties.props = %p\n", __func__, tvps->props);
+ 
+ 		/* Put an arbitrary limit on the number of messages that can
+ 		 * be sent at once */
+ 		if ((tvps->num == 0) || (tvps->num > DTV_IOCTL_MAX_MSGS))
+ 			return -EINVAL;
+ 
+ 		tvp = kmalloc(tvps->num * sizeof(struct dtv_property), GFP_KERNEL);
+ 		if (!tvp) {
+ 			err = -ENOMEM;
+ 			goto out;
+ 		}
+ 
+ 		if (copy_from_user(tvp, tvps->props, tvps->num * sizeof(struct dtv_property))) {
+ 			err = -EFAULT;
+ 			goto out;
+ 		}
+ 
+ 		for (i = 0; i < tvps->num; i++) {
+ 			(tvp + i)->result = dtv_property_process_set(fe, tvp + i, inode, file);
+ 			err |= (tvp + i)->result;
+ 		}
+ 
+ 		if(fe->dtv_property_cache.state == DTV_TUNE)
+ 			dprintk("%s() Property cache is full, tuning\n", __func__);
+ 
+ 	} else
+ 	if(cmd == FE_GET_PROPERTY) {
+ 
+ 		tvps = (struct dtv_properties __user *)parg;
+ 
+ 		dprintk("%s() properties.num = %d\n", __func__, tvps->num);
+ 		dprintk("%s() properties.props = %p\n", __func__, tvps->props);
+ 
+ 		/* Put an arbitrary limit on the number of messages that can
+ 		 * be sent at once */
+ 		if ((tvps->num == 0) || (tvps->num > DTV_IOCTL_MAX_MSGS))
+ 			return -EINVAL;
+ 
+ 		tvp = kmalloc(tvps->num * sizeof(struct dtv_property), GFP_KERNEL);
+ 		if (!tvp) {
+ 			err = -ENOMEM;
+ 			goto out;
+ 		}
+ 
+ 		if (copy_from_user(tvp, tvps->props, tvps->num * sizeof(struct dtv_property))) {
+ 			err = -EFAULT;
+ 			goto out;
+ 		}
+ 
+ 		for (i = 0; i < tvps->num; i++) {
+ 			(tvp + i)->result = dtv_property_process_get(fe, tvp + i, inode, file);
+ 			err |= (tvp + i)->result;
+ 		}
+ 
+ 		if (copy_to_user(tvps->props, tvp, tvps->num * sizeof(struct dtv_property))) {
+ 			err = -EFAULT;
+ 			goto out;
+ 		}
+ 
+ 	} else
+ 		err = -EOPNOTSUPP;
+ 
+ out:
+ 	kfree(tvp);
+ 	return err;
+ }
+ 
+ static int dvb_frontend_ioctl_legacy(struct inode *inode, struct file *file,
+ 			unsigned int cmd, void *parg)
+ {
+ 	struct dvb_device *dvbdev = file->private_data;
+ 	struct dvb_frontend *fe = dvbdev->priv;
+ 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+ 	int cb_err, err = -EOPNOTSUPP;
+ 
  	switch (cmd) {
  	case FE_GET_INFO: {
  		struct dvb_frontend_info* info = parg;
  		memcpy(info, &fe->ops.info, sizeof(struct dvb_frontend_info));
+ 		dvb_frontend_get_frequeny_limits(fe, &info->frequency_min, &info->frequency_max);
  
  		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn't
  		 * do it, it is done for it. */
***************
*** 729,741 ****
  		err = 0;
  		break;
  	}
- 
  	case FE_READ_STATUS: {
  		fe_status_t* status = parg;
  
  		/* if retune was requested but hasn't occured yet, prevent
  		 * that user get signal state from previous tuning */
! 		if(fepriv->state == FESTATE_RETUNE) {
  			err=0;
  			*status = 0;
  			break;
--- 1631,1643 ----
  		err = 0;
  		break;
  	}
  	case FE_READ_STATUS: {
  		fe_status_t* status = parg;
  
  		/* if retune was requested but hasn't occured yet, prevent
  		 * that user get signal state from previous tuning */
! 		if (fepriv->state == FESTATE_RETUNE ||
! 		    fepriv->state == FESTATE_ERROR) {
  			err=0;
  			*status = 0;
  			break;
***************
*** 830,842 ****
  			 * initialization, so parg is 8 bits and does not
  			 * include the initialization or start bit
  			 */
! 			unsigned long cmd = ((unsigned long) parg) << 1;
  			struct timeval nexttime;
  			struct timeval tv[10];
  			int i;
  			u8 last = 1;
  			if (dvb_frontend_debug)
! 				printk("%s switch command: 0x%04lx\n", __FUNCTION__, cmd);
  			do_gettimeofday(&nexttime);
  			if (dvb_frontend_debug)
  				memcpy(&tv[0], &nexttime, sizeof(struct timeval));
--- 1732,1744 ----
  			 * initialization, so parg is 8 bits and does not
  			 * include the initialization or start bit
  			 */
! 			unsigned long swcmd = ((unsigned long) parg) << 1;
  			struct timeval nexttime;
  			struct timeval tv[10];
  			int i;
  			u8 last = 1;
  			if (dvb_frontend_debug)
! 				printk("%s switch command: 0x%04lx\n", __func__, swcmd);
  			do_gettimeofday(&nexttime);
  			if (dvb_frontend_debug)
  				memcpy(&tv[0], &nexttime, sizeof(struct timeval));
***************
*** 849,866 ****
  			for (i = 0; i < 9; i++) {
  				if (dvb_frontend_debug)
  					do_gettimeofday(&tv[i + 1]);
! 				if ((cmd & 0x01) != last) {
  					/* set voltage to (last ? 13V : 18V) */
  					fe->ops.set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);
  					last = (last) ? 0 : 1;
  				}
! 				cmd = cmd >> 1;
  				if (i != 8)
  					dvb_frontend_sleep_until(&nexttime, 8000);
  			}
  			if (dvb_frontend_debug) {
  				printk("%s(%d): switch delay (should be 32k followed by all 8k\n",
! 					__FUNCTION__, fe->dvb->num);
  				for (i = 1; i < 10; i++)
  					printk("%d: %d\n", i, timeval_usec_diff(tv[i-1] , tv[i]));
  			}
--- 1751,1768 ----
  			for (i = 0; i < 9; i++) {
  				if (dvb_frontend_debug)
  					do_gettimeofday(&tv[i + 1]);
! 				if ((swcmd & 0x01) != last) {
  					/* set voltage to (last ? 13V : 18V) */
  					fe->ops.set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);
  					last = (last) ? 0 : 1;
  				}
! 				swcmd = swcmd >> 1;
  				if (i != 8)
  					dvb_frontend_sleep_until(&nexttime, 8000);
  			}
  			if (dvb_frontend_debug) {
  				printk("%s(%d): switch delay (should be 32k followed by all 8k\n",
! 					__func__, fe->dvb->num);
  				for (i = 1; i < 10; i++)
  					printk("%d: %d\n", i, timeval_usec_diff(tv[i-1] , tv[i]));
  			}
***************
*** 883,890 ****
  	case FE_SET_FRONTEND: {
  		struct dvb_frontend_tune_settings fetunesettings;
  
! 		memcpy (&fepriv->parameters, parg,
! 			sizeof (struct dvb_frontend_parameters));
  
  		memset(&fetunesettings, 0, sizeof(struct dvb_frontend_tune_settings));
  		memcpy(&fetunesettings.parameters, parg,
--- 1785,1805 ----
  	case FE_SET_FRONTEND: {
  		struct dvb_frontend_tune_settings fetunesettings;
  
! 		if(fe->dtv_property_cache.state == DTV_TUNE) {
! 			if (dvb_frontend_check_parameters(fe, &fepriv->parameters) < 0) {
! 				err = -EINVAL;
! 				break;
! 			}
! 		} else {
! 			if (dvb_frontend_check_parameters(fe, parg) < 0) {
! 				err = -EINVAL;
! 				break;
! 			}
! 
! 			memcpy (&fepriv->parameters, parg,
! 				sizeof (struct dvb_frontend_parameters));
! 			dtv_property_cache_sync(fe, &fepriv->parameters);
! 		}
  
  		memset(&fetunesettings, 0, sizeof(struct dvb_frontend_tune_settings));
  		memcpy(&fetunesettings.parameters, parg,
***************
*** 939,944 ****
--- 1854,1863 ----
  			fepriv->min_delay = (dvb_override_tune_delay * HZ) / 1000;
  
  		fepriv->state = FESTATE_RETUNE;
+ 
+ 		/* Request the search algorithm to search */
+ 		fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
+ 
  		dvb_frontend_wakeup(fe);
  		dvb_frontend_add_event(fe, 0);
  		fepriv->status = 0;
***************
*** 963,979 ****
  		break;
  	};
  
! 	up (&fepriv->sem);
  	return err;
  }
  
  static unsigned int dvb_frontend_poll(struct file *file, struct poll_table_struct *wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_frontend *fe = dvbdev->priv;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
  	poll_wait (file, &fepriv->events.wait_queue, wait);
  
--- 1882,1899 ----
  		break;
  	};
  
! 
  	return err;
  }
  
+ 
  static unsigned int dvb_frontend_poll(struct file *file, struct poll_table_struct *wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_frontend *fe = dvbdev->priv;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
! 	dprintk ("%s\n", __func__);
  
  	poll_wait (file, &fepriv->events.wait_queue, wait);
  
***************
*** 988,1009 ****
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_frontend *fe = dvbdev->priv;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	int ret;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
! 	if ((ret = dvb_generic_open (inode, file)) < 0)
! 		return ret;
  
! 	if (fe->ops.ts_bus_ctrl) {
! 		if ((ret = fe->ops.ts_bus_ctrl (fe, 1)) < 0) {
! 			dvb_generic_release (inode, file);
! 			return ret;
  		}
  	}
  
! 	if ((file->f_flags & O_ACCMODE) != O_RDONLY) {
  
  		/* normal tune mode when opened R/W */
  		fepriv->tune_mode_flags &= ~FE_TUNE_MODE_ONESHOT;
  		fepriv->tone = -1;
--- 1908,1967 ----
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_frontend *fe = dvbdev->priv;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+ 	struct dvb_adapter *adapter = fe->dvb;
  	int ret;
  
! 	dprintk ("> %s\n", __func__);
! 	adapter->mfe_shared = 0;
  
! 	if (adapter->mfe_shared) {
! 		mutex_lock (&adapter->mfe_lock);
  
! 		if (adapter->mfe_dvbdev == NULL)
! 			adapter->mfe_dvbdev = dvbdev;
! 
! 		else if (adapter->mfe_dvbdev != dvbdev) {
! 			struct dvb_device
! 				*mfedev = adapter->mfe_dvbdev;
! 			struct dvb_frontend
! 				*mfe = mfedev->priv;
! 			struct dvb_frontend_private
! 				*mfepriv = mfe->frontend_priv;
! 			int mferetry = (dvb_mfe_wait_time << 1);
! 
! 			mutex_unlock (&adapter->mfe_lock);
! 			while (mferetry-- && (mfedev->users != -1 ||
! 					mfepriv->thread != NULL)) {
! 				if(msleep_interruptible(500)) {
! 					if(signal_pending(current))
! 						return -EINTR;
! 				}
! 			}
! 
! 			mutex_lock (&adapter->mfe_lock);
! 			if(adapter->mfe_dvbdev != dvbdev) {
! 				mfedev = adapter->mfe_dvbdev;
! 				mfe = mfedev->priv;
! 				mfepriv = mfe->frontend_priv;
! 				if (mfedev->users != -1 ||
! 						mfepriv->thread != NULL) {
! 					mutex_unlock (&adapter->mfe_lock);
! 					return -EBUSY;
! 				}
! 				adapter->mfe_dvbdev = dvbdev;
! 			}
  		}
  	}
  
! 	if (dvbdev->users == -1 && fe->ops.ts_bus_ctrl) {
! 		if ((ret = fe->ops.ts_bus_ctrl(fe, 1)) < 0)
! 			goto err0;
! 	}
  
+ 	if ((ret = dvb_generic_open (inode, file)) < 0)
+ 		goto err1;
+ 
+ 	if ((file->f_flags & O_ACCMODE) != O_RDONLY) {
  		/* normal tune mode when opened R/W */
  		fepriv->tune_mode_flags &= ~FE_TUNE_MODE_ONESHOT;
  		fepriv->tone = -1;
***************
*** 1011,1022 ****
  
  		ret = dvb_frontend_start (fe);
  		if (ret)
! 			dvb_generic_release (inode, file);
  
  		/*  empty event queue */
  		fepriv->events.eventr = fepriv->events.eventw = 0;
  	}
  
  	return ret;
  }
  
--- 1969,1993 ----
  
  		ret = dvb_frontend_start (fe);
  		if (ret)
! 			goto err2;
  
  		/*  empty event queue */
  		fepriv->events.eventr = fepriv->events.eventw = 0;
  	}
  
+ 	if (adapter->mfe_shared)
+ 		mutex_unlock (&adapter->mfe_lock);
+ 	return ret;
+ 
+ err2:
+ 	dvb_generic_release(inode, file);
+ err1:
+ 	if (dvbdev->users == -1 && fe->ops.ts_bus_ctrl)
+ 		fe->ops.ts_bus_ctrl(fe, 0);
+ err0:
+ 	if (adapter->mfe_shared)
+ 		mutex_unlock (&adapter->mfe_lock);
+ 	dprintk ("%s <\n", __func__);
  	return ret;
  }
  
***************
*** 1027,1051 ****
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	int ret;
  
! 	dprintk ("%s\n", __FUNCTION__);
  
  	if ((file->f_flags & O_ACCMODE) != O_RDONLY)
  		fepriv->release_jiffies = jiffies;
  
- 	if (fe->ops.ts_bus_ctrl)
- 		fe->ops.ts_bus_ctrl (fe, 0);
- 
  	ret = dvb_generic_release (inode, file);
  
! 	if (dvbdev->users==-1 && fepriv->exit==1) {
! 		fops_put(file->f_op);
! 		file->f_op = NULL;
! 		wake_up(&dvbdev->wait_queue);
  	}
  	return ret;
  }
  
! static struct file_operations dvb_frontend_fops = {
  	.owner		= THIS_MODULE,
  	.ioctl		= dvb_generic_ioctl,
  	.poll		= dvb_frontend_poll,
--- 1998,2024 ----
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	int ret;
  
! 	dprintk ("%s\n", __func__);
  
  	if ((file->f_flags & O_ACCMODE) != O_RDONLY)
  		fepriv->release_jiffies = jiffies;
  
  	ret = dvb_generic_release (inode, file);
  
! 	if (dvbdev->users == -1) {
! 		if (fepriv->exit == 1) {
! 			fops_put(file->f_op);
! 			file->f_op = NULL;
! 			wake_up(&dvbdev->wait_queue);
! 		}
! 		if (fe->ops.ts_bus_ctrl)
! 			fe->ops.ts_bus_ctrl(fe, 0);
  	}
+ 
  	return ret;
  }
  
! static const struct file_operations dvb_frontend_fops = {
  	.owner		= THIS_MODULE,
  	.ioctl		= dvb_generic_ioctl,
  	.poll		= dvb_frontend_poll,
***************
*** 1065,1071 ****
  		.kernel_ioctl = dvb_frontend_ioctl
  	};
  
! 	dprintk ("%s\n", __FUNCTION__);
  
  	if (mutex_lock_interruptible(&frontend_mutex))
  		return -ERESTARTSYS;
--- 2038,2044 ----
  		.kernel_ioctl = dvb_frontend_ioctl
  	};
  
! 	dprintk ("%s\n", __func__);
  
  	if (mutex_lock_interruptible(&frontend_mutex))
  		return -ERESTARTSYS;
***************
*** 1080,1091 ****
  	init_MUTEX (&fepriv->sem);
  	init_waitqueue_head (&fepriv->wait_queue);
  	init_waitqueue_head (&fepriv->events.wait_queue);
! 	init_MUTEX (&fepriv->events.sem);
  	fe->dvb = dvb;
  	fepriv->inversion = INVERSION_OFF;
  
! 	printk ("DVB: registering frontend %i (%s)...\n",
  		fe->dvb->num,
  		fe->ops.info.name);
  
  	dvb_register_device (fe->dvb, &fepriv->dvbdev, &dvbdev_template,
--- 2053,2065 ----
  	init_MUTEX (&fepriv->sem);
  	init_waitqueue_head (&fepriv->wait_queue);
  	init_waitqueue_head (&fepriv->events.wait_queue);
! 	mutex_init(&fepriv->events.mtx);
  	fe->dvb = dvb;
  	fepriv->inversion = INVERSION_OFF;
  
! 	printk ("DVB: registering adapter %i frontend %i (%s)...\n",
  		fe->dvb->num,
+ 		fe->id,
  		fe->ops.info.name);
  
  	dvb_register_device (fe->dvb, &fepriv->dvbdev, &dvbdev_template,
***************
*** 1099,1105 ****
  int dvb_unregister_frontend(struct dvb_frontend* fe)
  {
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
! 	dprintk ("%s\n", __FUNCTION__);
  
  	mutex_lock(&frontend_mutex);
  	dvb_frontend_stop (fe);
--- 2073,2079 ----
  int dvb_unregister_frontend(struct dvb_frontend* fe)
  {
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
! 	dprintk ("%s\n", __func__);
  
  	mutex_lock(&frontend_mutex);
  	dvb_frontend_stop (fe);
***************
*** 1119,1125 ****
  }
  EXPORT_SYMBOL(dvb_unregister_frontend);
  
! #ifdef CONFIG_DVB_CORE_ATTACH
  void dvb_frontend_detach(struct dvb_frontend* fe)
  {
  	void *ptr;
--- 2093,2099 ----
  }
  EXPORT_SYMBOL(dvb_unregister_frontend);
  
! #ifdef CONFIG_MEDIA_ATTACH
  void dvb_frontend_detach(struct dvb_frontend* fe)
  {
  	void *ptr;
***************
*** 1132,1137 ****
--- 2106,2115 ----
  		fe->ops.tuner_ops.release(fe);
  		symbol_put_addr(fe->ops.tuner_ops.release);
  	}
+ 	if (fe->ops.analog_ops.release) {
+ 		fe->ops.analog_ops.release(fe);
+ 		symbol_put_addr(fe->ops.analog_ops.release);
+ 	}
  	ptr = (void*)fe->ops.release;
  	if (ptr) {
  		fe->ops.release(fe);
***************
*** 1145,1150 ****
--- 2123,2130 ----
  		fe->ops.release_sec(fe);
  	if (fe->ops.tuner_ops.release)
  		fe->ops.tuner_ops.release(fe);
+ 	if (fe->ops.analog_ops.release)
+ 		fe->ops.analog_ops.release(fe);
  	if (fe->ops.release)
  		fe->ops.release(fe);
  }
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_frontend.h linux-sh4/drivers/media/dvb/dvb-core/dvb_frontend.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_frontend.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_frontend.h	Wed May 19 21:14:13 2010
***************
*** 35,40 ****
--- 35,41 ----
  #include <linux/module.h>
  #include <linux/errno.h>
  #include <linux/delay.h>
+ #include <linux/mutex.h>
  
  #include <linux/dvb/frontend.h>
  
***************
*** 61,66 ****
--- 62,193 ----
  	u32 bandwidth_step;
  };
  
+ struct analog_parameters {
+ 	unsigned int frequency;
+ 	unsigned int mode;
+ 	unsigned int audmode;
+ 	u64 std;
+ };
+ 
+ enum dvbfe_modcod {
+ 	DVBFE_MODCOD_DUMMY_PLFRAME	= 0,
+ 	DVBFE_MODCOD_QPSK_1_4,
+ 	DVBFE_MODCOD_QPSK_1_3,
+ 	DVBFE_MODCOD_QPSK_2_5,
+ 	DVBFE_MODCOD_QPSK_1_2,
+ 	DVBFE_MODCOD_QPSK_3_5,
+ 	DVBFE_MODCOD_QPSK_2_3,
+ 	DVBFE_MODCOD_QPSK_3_4,
+ 	DVBFE_MODCOD_QPSK_4_5,
+ 	DVBFE_MODCOD_QPSK_5_6,
+ 	DVBFE_MODCOD_QPSK_8_9,
+ 	DVBFE_MODCOD_QPSK_9_10,
+ 	DVBFE_MODCOD_8PSK_3_5,
+ 	DVBFE_MODCOD_8PSK_2_3,
+ 	DVBFE_MODCOD_8PSK_3_4,
+ 	DVBFE_MODCOD_8PSK_5_6,
+ 	DVBFE_MODCOD_8PSK_8_9,
+ 	DVBFE_MODCOD_8PSK_9_10,
+ 	DVBFE_MODCOD_16APSK_2_3,
+ 	DVBFE_MODCOD_16APSK_3_4,
+ 	DVBFE_MODCOD_16APSK_4_5,
+ 	DVBFE_MODCOD_16APSK_5_6,
+ 	DVBFE_MODCOD_16APSK_8_9,
+ 	DVBFE_MODCOD_16APSK_9_10,
+ 	DVBFE_MODCOD_32APSK_3_4,
+ 	DVBFE_MODCOD_32APSK_4_5,
+ 	DVBFE_MODCOD_32APSK_5_6,
+ 	DVBFE_MODCOD_32APSK_8_9,
+ 	DVBFE_MODCOD_32APSK_9_10,
+ 	DVBFE_MODCOD_RESERVED_1,
+ 	DVBFE_MODCOD_BPSK_1_3,
+ 	DVBFE_MODCOD_BPSK_1_4,
+ 	DVBFE_MODCOD_RESERVED_2
+ };
+ 
+ enum tuner_param {
+ 	DVBFE_TUNER_FREQUENCY		= (1 <<  0),
+ 	DVBFE_TUNER_TUNERSTEP		= (1 <<  1),
+ 	DVBFE_TUNER_IFFREQ			= (1 <<  2),
+ 	DVBFE_TUNER_BANDWIDTH		= (1 <<  3),
+ 	DVBFE_TUNER_REFCLOCK		= (1 <<  4),
+ 	DVBFE_TUNER_IQSENSE			= (1 <<  5),
+ 	DVBFE_TUNER_DUMMY			= (1 << 31)
+ };
+ 
+ /*
+  * ALGO_HW: (Hardware Algorithm)
+  * ----------------------------------------------------------------
+  * Devices that support this algorithm do everything in hardware
+  * and no software support is needed to handle them.
+  * Requesting these devices to LOCK is the only thing required,
+  * device is supposed to do everything in the hardware.
+  *
+  * ALGO_SW: (Software Algorithm)
+  * ----------------------------------------------------------------
+  * These are dumb devices, that require software to do everything
+  *
+  * ALGO_CUSTOM: (Customizable Agorithm)
+  * ----------------------------------------------------------------
+  * Devices having this algorithm can be customized to have specific
+  * algorithms in the frontend driver, rather than simply doing a
+  * software zig-zag. In this case the zigzag maybe hardware assisted
+  * or it maybe completely done in hardware. In all cases, usage of
+  * this algorithm, in conjunction with the search and track
+  * callbacks, utilizes the driver specific algorithm.
+  *
+  * ALGO_RECOVERY: (Recovery Algorithm)
+  * ----------------------------------------------------------------
+  * These devices have AUTO recovery capabilities from LOCK failure
+  */
+ enum dvbfe_algo {
+ 	DVBFE_ALGO_HW			= (1 <<  0),
+ 	DVBFE_ALGO_SW			= (1 <<  1),
+ 	DVBFE_ALGO_CUSTOM		= (1 <<  2),
+ 	DVBFE_ALGO_RECOVERY		= (1 << 31)
+ };
+ 
+ struct tuner_state {
+ 	u32 frequency;
+ 	u32 tunerstep;
+ 	u32 ifreq;
+ 	u32 bandwidth;
+ 	u32 iqsense;
+ 	u32 refclock;
+ };
+ 
+ /*
+  * search callback possible return status
+  *
+  * DVBFE_ALGO_SEARCH_SUCCESS
+  * The frontend search algorithm completed and returned succesfully
+  *
+  * DVBFE_ALGO_SEARCH_ASLEEP
+  * The frontend search algorithm is sleeping
+  *
+  * DVBFE_ALGO_SEARCH_FAILED
+  * The frontend search for a signal failed
+  *
+  * DVBFE_ALGO_SEARCH_INVALID
+  * The frontend search algorith was probably supplied with invalid
+  * parameters and the search is an invalid one
+  *
+  * DVBFE_ALGO_SEARCH_ERROR
+  * The frontend search algorithm failed due to some error
+  *
+  * DVBFE_ALGO_SEARCH_AGAIN
+  * The frontend search algorithm was requested to search again
+  */
+ enum dvbfe_search {
+ 	DVBFE_ALGO_SEARCH_SUCCESS	= (1 <<  0),
+ 	DVBFE_ALGO_SEARCH_ASLEEP	= (1 <<  1),
+ 	DVBFE_ALGO_SEARCH_FAILED	= (1 <<  2),
+ 	DVBFE_ALGO_SEARCH_INVALID	= (1 <<  3),
+ 	DVBFE_ALGO_SEARCH_AGAIN		= (1 <<  4),
+ 	DVBFE_ALGO_SEARCH_ERROR		= (1 << 31),
+ };
+ 
+ 
  struct dvb_tuner_ops {
  
  	struct dvb_tuner_info info;
***************
*** 71,90 ****
--- 198,252 ----
  
  	/** This is for simple PLLs - set all parameters in one go. */
  	int (*set_params)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p);
+ 	int (*set_analog_params)(struct dvb_frontend *fe, struct analog_parameters *p);
  
  	/** This is support for demods like the mt352 - fills out the supplied buffer with what to write. */
  	int (*calc_regs)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p, u8 *buf, int buf_len);
  
+ 	/** This is to allow setting tuner-specific configs */
+ 	int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
+ 
  	int (*get_frequency)(struct dvb_frontend *fe, u32 *frequency);
  	int (*get_bandwidth)(struct dvb_frontend *fe, u32 *bandwidth);
  
  #define TUNER_STATUS_LOCKED 1
+ #define TUNER_STATUS_STEREO 2
  	int (*get_status)(struct dvb_frontend *fe, u32 *status);
+ 	int (*get_rf_strength)(struct dvb_frontend *fe, u16 *strength);
  
  	/** These are provided seperately from set_params in order to facilitate silicon
  	 * tuners which require sophisticated tuning loops, controlling each parameter seperately. */
  	int (*set_frequency)(struct dvb_frontend *fe, u32 frequency);
  	int (*set_bandwidth)(struct dvb_frontend *fe, u32 bandwidth);
+ 
+ 	/*
+ 	 * These are provided seperately from set_params in order to facilitate silicon
+ 	 * tuners which require sophisticated tuning loops, controlling each parameter seperately.
+ 	 */
+ 	int (*set_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
+ 	int (*get_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
+ };
+ 
+ struct analog_demod_info {
+ 	char *name;
+ };
+ 
+ struct analog_demod_ops {
+ 
+ 	struct analog_demod_info info;
+ 
+ 	void (*set_params)(struct dvb_frontend *fe,
+ 			   struct analog_parameters *params);
+ 	int  (*has_signal)(struct dvb_frontend *fe);
+ 	int  (*is_stereo)(struct dvb_frontend *fe);
+ 	int  (*get_afc)(struct dvb_frontend *fe);
+ 	void (*tuner_status)(struct dvb_frontend *fe);
+ 	void (*standby)(struct dvb_frontend *fe);
+ 	void (*release)(struct dvb_frontend *fe);
+ 	int  (*i2c_gate_ctrl)(struct dvb_frontend *fe, int enable);
+ 
+ 	/** This is to allow setting tuner-specific configuration */
+ 	int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
  };
  
  struct dvb_frontend_ops {
***************
*** 100,112 ****
  	int (*write)(struct dvb_frontend* fe, u8* buf, int len);
  
  	/* if this is set, it overrides the default swzigzag */
! 	int (*tune)(struct dvb_frontend* fe,
! 		    struct dvb_frontend_parameters* params,
! 		    unsigned int mode_flags,
! 		    unsigned int *delay,
! 		    fe_status_t *status);
  	/* get frontend tuning algorithm from the module */
! 	int (*get_frontend_algo)(struct dvb_frontend *fe);
  
  	/* these two are only used for the swzigzag code */
  	int (*set_frontend)(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
--- 262,270 ----
  	int (*write)(struct dvb_frontend* fe, u8* buf, int len);
  
  	/* if this is set, it overrides the default swzigzag */
! 	int (*tune)(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
  	/* get frontend tuning algorithm from the module */
! 	enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend *fe);
  
  	/* these two are only used for the swzigzag code */
  	int (*set_frontend)(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
***************
*** 131,137 ****
--- 289,305 ----
  	int (*i2c_gate_ctrl)(struct dvb_frontend* fe, int enable);
  	int (*ts_bus_ctrl)(struct dvb_frontend* fe, int acquire);
  
+ 	/* These callbacks are for devices that implement their own
+ 	 * tuning algorithms, rather than a simple swzigzag
+ 	 */
+ 	enum dvbfe_search (*search)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p);
+ 	int (*track)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p);
+ 
  	struct dvb_tuner_ops tuner_ops;
+ 	struct analog_demod_ops analog_ops;
+ 
+ 	int (*set_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
+ 	int (*get_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
  };
  
  #define MAX_EVENT 8
***************
*** 142,165 ****
  	int			  eventr;
  	int			  overflow;
  	wait_queue_head_t	  wait_queue;
! 	struct semaphore	  sem;
  };
  
  struct dvb_frontend {
  	struct dvb_frontend_ops ops;
  	struct dvb_adapter *dvb;
! 	void* demodulator_priv;
! 	void* tuner_priv;
! 	void* frontend_priv;
! 	void* sec_priv;
  };
  
! extern int dvb_register_frontend(struct dvb_adapter* dvb,
! 				 struct dvb_frontend* fe);
  
! extern int dvb_unregister_frontend(struct dvb_frontend* fe);
  
! extern void dvb_frontend_detach(struct dvb_frontend* fe);
  
  extern void dvb_frontend_reinitialise(struct dvb_frontend *fe);
  
--- 310,381 ----
  	int			  eventr;
  	int			  overflow;
  	wait_queue_head_t	  wait_queue;
! 	struct mutex		  mtx;
! };
! 
! struct dtv_frontend_properties {
! 
! 	/* Cache State */
! 	u32			state;
! 
! 	u32			frequency;
! 	fe_modulation_t		modulation;
! 
! 	fe_sec_voltage_t	voltage;
! 	fe_sec_tone_mode_t	sectone;
! 	fe_spectral_inversion_t	inversion;
! 	fe_code_rate_t		fec_inner;
! 	fe_transmit_mode_t	transmission_mode;
! 	u32			bandwidth_hz;	/* 0 = AUTO */
! 	fe_guard_interval_t	guard_interval;
! 	fe_hierarchy_t		hierarchy;
! 	u32			symbol_rate;
! 	fe_code_rate_t		code_rate_HP;
! 	fe_code_rate_t		code_rate_LP;
! 
! 	fe_pilot_t		pilot;
! 	fe_rolloff_t		rolloff;
! 
! 	fe_delivery_system_t	delivery_system;
! 
! 	/* ISDB-T specifics */
! 	u8			isdbt_partial_reception;
! 	u8			isdbt_sb_mode;
! 	u8			isdbt_sb_subchannel;
! 	u32			isdbt_sb_segment_idx;
! 	u32			isdbt_sb_segment_count;
! 	u8			isdbt_layer_enabled;
! 	struct {
! 	    u8			segment_count;
! 	    fe_code_rate_t	fec;
! 	    fe_modulation_t	modulation;
! 	    u8			interleaving;
! 	} layer[3];
! 
! 	/* ISDB-T specifics */
! 	u32			isdbs_ts_id;
  };
  
  struct dvb_frontend {
  	struct dvb_frontend_ops ops;
  	struct dvb_adapter *dvb;
! 	void *demodulator_priv;
! 	void *tuner_priv;
! 	void *frontend_priv;
! 	void *sec_priv;
! 	void *analog_demod_priv;
! 	struct dtv_frontend_properties dtv_property_cache;
! #define DVB_FRONTEND_COMPONENT_TUNER 0
! 	int (*callback)(void *adapter_priv, int component, int cmd, int arg);
! 	int id;
  };
  
! extern int dvb_register_frontend(struct dvb_adapter *dvb,
! 				 struct dvb_frontend *fe);
  
! extern int dvb_unregister_frontend(struct dvb_frontend *fe);
  
! extern void dvb_frontend_detach(struct dvb_frontend *fe);
  
  extern void dvb_frontend_reinitialise(struct dvb_frontend *fe);
  
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_net.c linux-sh4/drivers/media/dvb/dvb-core/dvb_net.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_net.c	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_net.c	Wed May 19 21:13:20 2010
***************
*** 62,68 ****
--- 62,70 ----
  #include <linux/uio.h>
  #include <asm/uaccess.h>
  #include <linux/crc32.h>
+ #include "compat.h"
  #include <linux/mutex.h>
+ #include <linux/sched.h>
  
  #include "dvb_demux.h"
  #include "dvb_net.h"
***************
*** 125,133 ****
--- 127,139 ----
  
  struct dvb_net_priv {
  	int in_use;
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  	struct net_device_stats stats;
+ #endif
  	u16 pid;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
  	struct net_device *net;
+ #endif
  	struct dvb_net *host;
  	struct dmx_demux *demux;
  	struct dmx_section_feed *secfeed;
***************
*** 168,180 ****
   *  stolen from eth.c out of the linux kernel, hacked for dvb-device
   *  by Michael Holzt <kju@debian.org>
   */
! static unsigned short dvb_net_eth_type_trans(struct sk_buff *skb,
  				      struct net_device *dev)
  {
  	struct ethhdr *eth;
  	unsigned char *rawp;
  
  	skb_reset_mac_header(skb);
  	skb_pull(skb,dev->hard_header_len);
  	eth = eth_hdr(skb);
  
--- 174,190 ----
   *  stolen from eth.c out of the linux kernel, hacked for dvb-device
   *  by Michael Holzt <kju@debian.org>
   */
! static __be16 dvb_net_eth_type_trans(struct sk_buff *skb,
  				      struct net_device *dev)
  {
  	struct ethhdr *eth;
  	unsigned char *rawp;
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+ 	skb->mac.raw=skb->data;
+ #else
  	skb_reset_mac_header(skb);
+ #endif
  	skb_pull(skb,dev->hard_header_len);
  	eth = eth_hdr(skb);
  
***************
*** 277,286 ****
  			if(ext_len >= 0) {
  				p->ule_next_hdr += ext_len;
  				if (!p->ule_bridged) {
! 					p->ule_sndu_type = ntohs(*(unsigned short *)p->ule_next_hdr);
  					p->ule_next_hdr += 2;
  				} else {
! 					p->ule_sndu_type = ntohs(*(unsigned short *)(p->ule_next_hdr + ((p->ule_dbit ? 2 : 3) * ETH_ALEN)));
  					/* This assures the extension handling loop will terminate. */
  				}
  			}
--- 287,296 ----
  			if(ext_len >= 0) {
  				p->ule_next_hdr += ext_len;
  				if (!p->ule_bridged) {
! 					p->ule_sndu_type = ntohs(*(__be16 *)p->ule_next_hdr);
  					p->ule_next_hdr += 2;
  				} else {
! 					p->ule_sndu_type = ntohs(*(__be16 *)(p->ule_next_hdr + ((p->ule_dbit ? 2 : 3) * ETH_ALEN)));
  					/* This assures the extension handling loop will terminate. */
  				}
  			}
***************
*** 294,300 ****
  		if (ule_optional_ext_handlers[htype])
  			(void)ule_optional_ext_handlers[htype]( p );
  		p->ule_next_hdr += ext_len;
! 		p->ule_sndu_type = ntohs( *(unsigned short *)(p->ule_next_hdr-2) );
  		/*
  		 * note: the length of the next header type is included in the
  		 * length of THIS optional extension header
--- 304,310 ----
  		if (ule_optional_ext_handlers[htype])
  			(void)ule_optional_ext_handlers[htype]( p );
  		p->ule_next_hdr += ext_len;
! 		p->ule_sndu_type = ntohs( *(__be16 *)(p->ule_next_hdr-2) );
  		/*
  		 * note: the length of the next header type is included in the
  		 * length of THIS optional extension header
***************
*** 345,351 ****
   */
  static void dvb_net_ule( struct net_device *dev, const u8 *buf, size_t buf_len )
  {
! 	struct dvb_net_priv *priv = dev->priv;
  	unsigned long skipped = 0L;
  	const u8 *ts, *ts_end, *from_where = NULL;
  	u8 ts_remain = 0, how_much = 0, new_ts = 1;
--- 355,361 ----
   */
  static void dvb_net_ule( struct net_device *dev, const u8 *buf, size_t buf_len )
  {
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  	unsigned long skipped = 0L;
  	const u8 *ts, *ts_end, *from_where = NULL;
  	u8 ts_remain = 0, how_much = 0, new_ts = 1;
***************
*** 354,367 ****
  #ifdef ULE_DEBUG
  	/* The code inside ULE_DEBUG keeps a history of the last 100 TS cells processed. */
  	static unsigned char ule_hist[100*TS_SZ];
! 	static unsigned char *ule_where = ule_hist, ule_dump = 0;
  #endif
  
- 	if (dev == NULL) {
- 		printk( KERN_ERR "NO netdev struct!\n" );
- 		return;
- 	}
- 
  	/* For all TS cells in current buffer.
  	 * Appearently, we are called for every single TS cell.
  	 */
--- 364,372 ----
  #ifdef ULE_DEBUG
  	/* The code inside ULE_DEBUG keeps a history of the last 100 TS cells processed. */
  	static unsigned char ule_hist[100*TS_SZ];
! 	static unsigned char *ule_where = ule_hist, ule_dump;
  #endif
  
  	/* For all TS cells in current buffer.
  	 * Appearently, we are called for every single TS cell.
  	 */
***************
*** 389,396 ****
--- 394,406 ----
  				if (priv->ule_skb) {
  					dev_kfree_skb( priv->ule_skb );
  					/* Prepare for next SNDU. */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  					priv->stats.rx_errors++;
  					priv->stats.rx_frame_errors++;
+ #else
+ 					dev->stats.rx_errors++;
+ 					dev->stats.rx_frame_errors++;
+ #endif
  				}
  				reset_ule(priv);
  				priv->need_pusi = 1;
***************
*** 443,450 ****
--- 453,465 ----
  					dev_kfree_skb( priv->ule_skb );
  					/* Prepare for next SNDU. */
  					// reset_ule(priv);  moved to below.
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  					priv->stats.rx_errors++;
  					priv->stats.rx_frame_errors++;
+ #else
+ 					dev->stats.rx_errors++;
+ 					dev->stats.rx_frame_errors++;
+ #endif
  				}
  				reset_ule(priv);
  				/* skip to next PUSI. */
***************
*** 465,472 ****
  						/* Drop partly decoded SNDU, reset state, resync on PUSI. */
  						if (priv->ule_skb) {
  							dev_kfree_skb( priv->ule_skb );
! 							((struct dvb_net_priv *) dev->priv)->stats.rx_errors++;
! 							((struct dvb_net_priv *) dev->priv)->stats.rx_frame_errors++;
  						}
  						reset_ule(priv);
  						priv->need_pusi = 1;
--- 480,492 ----
  						/* Drop partly decoded SNDU, reset state, resync on PUSI. */
  						if (priv->ule_skb) {
  							dev_kfree_skb( priv->ule_skb );
! #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
! 							priv->stats.rx_errors++;
! 							priv->stats.rx_frame_errors++;
! #else
! 							dev->stats.rx_errors++;
! 							dev->stats.rx_frame_errors++;
! #endif
  						}
  						reset_ule(priv);
  						priv->need_pusi = 1;
***************
*** 482,489 ****
--- 502,514 ----
  				if (priv->ule_sndu_remain > 183) {
  					/* Current SNDU lacks more data than there could be available in the
  					 * current TS cell. */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  					priv->stats.rx_errors++;
  					priv->stats.rx_length_errors++;
+ #else
+ 					dev->stats.rx_errors++;
+ 					dev->stats.rx_length_errors++;
+ #endif
  					printk(KERN_WARNING "%lu: Expected %d more SNDU bytes, but "
  					       "got PUSI (pf %d, ts_remain %d).  Flushing incomplete payload.\n",
  					       priv->ts_count, priv->ule_sndu_remain, ts[4], ts_remain);
***************
*** 525,532 ****
--- 550,562 ----
  				if (priv->ule_sndu_len < 5) {
  					printk(KERN_WARNING "%lu: Invalid ULE SNDU length %u. "
  					       "Resyncing.\n", priv->ts_count, priv->ule_sndu_len);
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  					priv->stats.rx_errors++;
  					priv->stats.rx_length_errors++;
+ #else
+ 					dev->stats.rx_errors++;
+ 					dev->stats.rx_length_errors++;
+ #endif
  					priv->ule_sndu_len = 0;
  					priv->need_pusi = 1;
  					new_ts = 1;
***************
*** 578,584 ****
  			if (priv->ule_skb == NULL) {
  				printk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n",
  				       dev->name);
! 				((struct dvb_net_priv *)dev->priv)->stats.rx_dropped++;
  				return;
  			}
  
--- 608,618 ----
  			if (priv->ule_skb == NULL) {
  				printk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n",
  				       dev->name);
! #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
! 				priv->stats.rx_dropped++;
! #else
! 				dev->stats.rx_dropped++;
! #endif
  				return;
  			}
  
***************
*** 599,607 ****
  		/* Check for complete payload. */
  		if (priv->ule_sndu_remain <= 0) {
  			/* Check CRC32, we've got it in our skb already. */
! 			unsigned short ulen = htons(priv->ule_sndu_len);
! 			unsigned short utype = htons(priv->ule_sndu_type);
  			const u8 *tail;
  			struct kvec iov[3] = {
  				{ &ulen, sizeof ulen },
  				{ &utype, sizeof utype },
--- 633,643 ----
  		/* Check for complete payload. */
  		if (priv->ule_sndu_remain <= 0) {
  			/* Check CRC32, we've got it in our skb already. */
! 			__be16 ulen = htons(priv->ule_sndu_len);
! 			__be16 utype = htons(priv->ule_sndu_type);
! #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
  			const u8 *tail;
+ #endif
  			struct kvec iov[3] = {
  				{ &ulen, sizeof ulen },
  				{ &utype, sizeof utype },
***************
*** 611,625 ****
  			if (priv->ule_dbit) {
  				/* Set D-bit for CRC32 verification,
  				 * if it was set originally. */
! 				ulen |= 0x0080;
  			}
  
  			ule_crc = iov_crc32(ule_crc, iov, 3);
  			tail = skb_tail_pointer(priv->ule_skb);
  			expected_crc = *(tail - 4) << 24 |
  				       *(tail - 3) << 16 |
  				       *(tail - 2) << 8 |
  				       *(tail - 1);
  			if (ule_crc != expected_crc) {
  				printk(KERN_WARNING "%lu: CRC32 check FAILED: %08x / %08x, SNDU len %d type %#x, ts_remain %d, next 2: %x.\n",
  				       priv->ts_count, ule_crc, expected_crc, priv->ule_sndu_len, priv->ule_sndu_type, ts_remain, ts_remain > 2 ? *(unsigned short *)from_where : 0);
--- 647,668 ----
  			if (priv->ule_dbit) {
  				/* Set D-bit for CRC32 verification,
  				 * if it was set originally. */
! 				ulen |= htons(0x8000);
  			}
  
  			ule_crc = iov_crc32(ule_crc, iov, 3);
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+ 			expected_crc = *((u8 *)priv->ule_skb->tail - 4) << 24 |
+ 				       *((u8 *)priv->ule_skb->tail - 3) << 16 |
+ 				       *((u8 *)priv->ule_skb->tail - 2) << 8 |
+ 				       *((u8 *)priv->ule_skb->tail - 1);
+ #else
  			tail = skb_tail_pointer(priv->ule_skb);
  			expected_crc = *(tail - 4) << 24 |
  				       *(tail - 3) << 16 |
  				       *(tail - 2) << 8 |
  				       *(tail - 1);
+ #endif
  			if (ule_crc != expected_crc) {
  				printk(KERN_WARNING "%lu: CRC32 check FAILED: %08x / %08x, SNDU len %d type %#x, ts_remain %d, next 2: %x.\n",
  				       priv->ts_count, ule_crc, expected_crc, priv->ule_sndu_len, priv->ule_sndu_type, ts_remain, ts_remain > 2 ? *(unsigned short *)from_where : 0);
***************
*** 642,649 ****
--- 685,697 ----
  				ule_dump = 1;
  #endif
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  				priv->stats.rx_errors++;
  				priv->stats.rx_crc_errors++;
+ #else
+ 				dev->stats.rx_errors++;
+ 				dev->stats.rx_crc_errors++;
+ #endif
  				dev_kfree_skb(priv->ule_skb);
  			} else {
  				/* CRC32 verified OK. */
***************
*** 686,692 ****
  							drop = 1;
  						/* else: destination address matches the MAC address of our receiver device */
  					}
! 					/* else: promiscious mode; pass everything up the stack */
  
  					if (drop) {
  #ifdef ULE_DEBUG
--- 734,740 ----
  							drop = 1;
  						/* else: destination address matches the MAC address of our receiver device */
  					}
! 					/* else: promiscuous mode; pass everything up the stack */
  
  					if (drop) {
  #ifdef ULE_DEBUG
***************
*** 698,706 ****
--- 746,758 ----
  					}
  					else
  					{
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+ 						memcpy(dest_addr,  priv->ule_skb->data, ETH_ALEN);
+ #else
  						skb_copy_from_linear_data(priv->ule_skb,
  							      dest_addr,
  							      ETH_ALEN);
+ #endif
  						skb_pull(priv->ule_skb, ETH_ALEN);
  					}
  				}
***************
*** 749,756 ****
--- 801,813 ----
  				 * receive the packet anyhow. */
  				/* if (priv->ule_dbit && skb->pkt_type == PACKET_OTHERHOST)
  					priv->ule_skb->pkt_type = PACKET_HOST; */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  				priv->stats.rx_packets++;
  				priv->stats.rx_bytes += priv->ule_skb->len;
+ #else
+ 				dev->stats.rx_packets++;
+ 				dev->stats.rx_bytes += priv->ule_skb->len;
+ #endif
  				netif_rx(priv->ule_skb);
  			}
  			sndu_done:
***************
*** 789,796 ****
  {
  	struct net_device *dev = feed->priv;
  
! 	if (buffer2 != 0)
! 		printk(KERN_WARNING "buffer2 not 0: %p.\n", buffer2);
  	if (buffer1_len > 32768)
  		printk(KERN_WARNING "length > 32k: %zu.\n", buffer1_len);
  	/* printk("TS callback: %u bytes, %u TS cells @ %p.\n",
--- 846,853 ----
  {
  	struct net_device *dev = feed->priv;
  
! 	if (buffer2)
! 		printk(KERN_WARNING "buffer2 not NULL: %p.\n", buffer2);
  	if (buffer1_len > 32768)
  		printk(KERN_WARNING "length > 32k: %zu.\n", buffer1_len);
  	/* printk("TS callback: %u bytes, %u TS cells @ %p.\n",
***************
*** 800,811 ****
  }
  
  
! static void dvb_net_sec(struct net_device *dev, const u8 *pkt, int
! pkt_len)
  {
  	u8 *eth;
  	struct sk_buff *skb;
! 	struct net_device_stats *stats = &(((struct dvb_net_priv *) dev->priv)->stats);
  	int snap = 0;
  
  	/* note: pkt_len includes a 32bit checksum */
--- 857,873 ----
  }
  
  
! static void dvb_net_sec(struct net_device *dev,
! 			const u8 *pkt, int pkt_len)
  {
  	u8 *eth;
  	struct sk_buff *skb;
! #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
! 	struct net_device_stats *stats =
! 		&((struct dvb_net_priv *) netdev_priv(dev))->stats;
! #else
! 	struct net_device_stats *stats = &dev->stats;
! #endif
  	int snap = 0;
  
  	/* note: pkt_len includes a 32bit checksum */
***************
*** 818,824 ****
  	}
  /* it seems some ISPs manage to screw up here, so we have to
   * relax the error checks... */
! #if 0
  	if ((pkt[5] & 0xfd) != 0xc1) {
  		/* drop scrambled or broken packets */
  #else
--- 880,886 ----
  	}
  /* it seems some ISPs manage to screw up here, so we have to
   * relax the error checks... */
! #if 0 /* keep */
  	if ((pkt[5] & 0xfd) != 0xc1) {
  		/* drop scrambled or broken packets */
  #else
***************
*** 910,916 ****
  static int dvb_net_tx(struct sk_buff *skb, struct net_device *dev)
  {
  	dev_kfree_skb(skb);
! 	return 0;
  }
  
  static u8 mask_normal[6]={0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
--- 972,978 ----
  static int dvb_net_tx(struct sk_buff *skb, struct net_device *dev)
  {
  	dev_kfree_skb(skb);
! 	return NETDEV_TX_OK;
  }
  
  static u8 mask_normal[6]={0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
***************
*** 922,928 ****
  		   struct dmx_section_filter **secfilter,
  		   u8 *mac, u8 *mac_mask)
  {
! 	struct dvb_net_priv *priv = dev->priv;
  	int ret;
  
  	*secfilter=NULL;
--- 984,990 ----
  		   struct dmx_section_filter **secfilter,
  		   u8 *mac, u8 *mac_mask)
  {
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  	int ret;
  
  	*secfilter=NULL;
***************
*** 954,964 ****
  	(*secfilter)->filter_mask[10] = mac_mask[1];
  	(*secfilter)->filter_mask[11]=mac_mask[0];
  
! 	dprintk("%s: filter mac=%02x %02x %02x %02x %02x %02x\n",
! 	       dev->name, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
! 	dprintk("%s: filter mask=%02x %02x %02x %02x %02x %02x\n",
! 	       dev->name, mac_mask[0], mac_mask[1], mac_mask[2],
! 	       mac_mask[3], mac_mask[4], mac_mask[5]);
  
  	return 0;
  }
--- 1016,1023 ----
  	(*secfilter)->filter_mask[10] = mac_mask[1];
  	(*secfilter)->filter_mask[11]=mac_mask[0];
  
! 	dprintk("%s: filter mac=%pM\n", dev->name, mac);
! 	dprintk("%s: filter mask=%pM\n", dev->name, mac_mask);
  
  	return 0;
  }
***************
*** 966,986 ****
  static int dvb_net_feed_start(struct net_device *dev)
  {
  	int ret = 0, i;
! 	struct dvb_net_priv *priv = dev->priv;
  	struct dmx_demux *demux = priv->demux;
  	unsigned char *mac = (unsigned char *) dev->dev_addr;
  
! 	dprintk("%s: rx_mode %i\n", __FUNCTION__, priv->rx_mode);
  	mutex_lock(&priv->mutex);
  	if (priv->tsfeed || priv->secfeed || priv->secfilter || priv->multi_secfilter[0])
! 		printk("%s: BUG %d\n", __FUNCTION__, __LINE__);
  
  	priv->secfeed=NULL;
  	priv->secfilter=NULL;
  	priv->tsfeed = NULL;
  
  	if (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {
! 		dprintk("%s: alloc secfeed\n", __FUNCTION__);
  		ret=demux->allocate_section_feed(demux, &priv->secfeed,
  					 dvb_net_sec_callback);
  		if (ret<0) {
--- 1025,1045 ----
  static int dvb_net_feed_start(struct net_device *dev)
  {
  	int ret = 0, i;
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  	struct dmx_demux *demux = priv->demux;
  	unsigned char *mac = (unsigned char *) dev->dev_addr;
  
! 	dprintk("%s: rx_mode %i\n", __func__, priv->rx_mode);
  	mutex_lock(&priv->mutex);
  	if (priv->tsfeed || priv->secfeed || priv->secfilter || priv->multi_secfilter[0])
! 		printk("%s: BUG %d\n", __func__, __LINE__);
  
  	priv->secfeed=NULL;
  	priv->secfilter=NULL;
  	priv->tsfeed = NULL;
  
  	if (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {
! 		dprintk("%s: alloc secfeed\n", __func__);
  		ret=demux->allocate_section_feed(demux, &priv->secfeed,
  					 dvb_net_sec_callback);
  		if (ret<0) {
***************
*** 998,1035 ****
  		}
  
  		if (priv->rx_mode != RX_MODE_PROMISC) {
! 			dprintk("%s: set secfilter\n", __FUNCTION__);
  			dvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_normal);
  		}
  
  		switch (priv->rx_mode) {
  		case RX_MODE_MULTI:
  			for (i = 0; i < priv->multi_num; i++) {
! 				dprintk("%s: set multi_secfilter[%d]\n", __FUNCTION__, i);
  				dvb_net_filter_sec_set(dev, &priv->multi_secfilter[i],
  						       priv->multi_macs[i], mask_normal);
  			}
  			break;
  		case RX_MODE_ALL_MULTI:
  			priv->multi_num=1;
! 			dprintk("%s: set multi_secfilter[0]\n", __FUNCTION__);
  			dvb_net_filter_sec_set(dev, &priv->multi_secfilter[0],
  					       mac_allmulti, mask_allmulti);
  			break;
  		case RX_MODE_PROMISC:
  			priv->multi_num=0;
! 			dprintk("%s: set secfilter\n", __FUNCTION__);
  			dvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_promisc);
  			break;
  		}
  
! 		dprintk("%s: start filtering\n", __FUNCTION__);
  		priv->secfeed->start_filtering(priv->secfeed);
  	} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {
  		struct timespec timeout = { 0, 10000000 }; // 10 msec
  
  		/* we have payloads encapsulated in TS */
! 		dprintk("%s: alloc tsfeed\n", __FUNCTION__);
  		ret = demux->allocate_ts_feed(demux, &priv->tsfeed, dvb_net_ts_callback);
  		if (ret < 0) {
  			printk("%s: could not allocate ts feed\n", dev->name);
--- 1057,1094 ----
  		}
  
  		if (priv->rx_mode != RX_MODE_PROMISC) {
! 			dprintk("%s: set secfilter\n", __func__);
  			dvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_normal);
  		}
  
  		switch (priv->rx_mode) {
  		case RX_MODE_MULTI:
  			for (i = 0; i < priv->multi_num; i++) {
! 				dprintk("%s: set multi_secfilter[%d]\n", __func__, i);
  				dvb_net_filter_sec_set(dev, &priv->multi_secfilter[i],
  						       priv->multi_macs[i], mask_normal);
  			}
  			break;
  		case RX_MODE_ALL_MULTI:
  			priv->multi_num=1;
! 			dprintk("%s: set multi_secfilter[0]\n", __func__);
  			dvb_net_filter_sec_set(dev, &priv->multi_secfilter[0],
  					       mac_allmulti, mask_allmulti);
  			break;
  		case RX_MODE_PROMISC:
  			priv->multi_num=0;
! 			dprintk("%s: set secfilter\n", __func__);
  			dvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_promisc);
  			break;
  		}
  
! 		dprintk("%s: start filtering\n", __func__);
  		priv->secfeed->start_filtering(priv->secfeed);
  	} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {
  		struct timespec timeout = { 0, 10000000 }; // 10 msec
  
  		/* we have payloads encapsulated in TS */
! 		dprintk("%s: alloc tsfeed\n", __func__);
  		ret = demux->allocate_ts_feed(demux, &priv->tsfeed, dvb_net_ts_callback);
  		if (ret < 0) {
  			printk("%s: could not allocate ts feed\n", dev->name);
***************
*** 1053,1059 ****
  			goto error;
  		}
  
! 		dprintk("%s: start filtering\n", __FUNCTION__);
  		priv->tsfeed->start_filtering(priv->tsfeed);
  	} else
  		ret = -EINVAL;
--- 1112,1118 ----
  			goto error;
  		}
  
! 		dprintk("%s: start filtering\n", __func__);
  		priv->tsfeed->start_filtering(priv->tsfeed);
  	} else
  		ret = -EINVAL;
***************
*** 1065,1084 ****
  
  static int dvb_net_feed_stop(struct net_device *dev)
  {
! 	struct dvb_net_priv *priv = dev->priv;
  	int i, ret = 0;
  
! 	dprintk("%s\n", __FUNCTION__);
  	mutex_lock(&priv->mutex);
  	if (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {
  		if (priv->secfeed) {
  			if (priv->secfeed->is_filtering) {
! 				dprintk("%s: stop secfeed\n", __FUNCTION__);
  				priv->secfeed->stop_filtering(priv->secfeed);
  			}
  
  			if (priv->secfilter) {
! 				dprintk("%s: release secfilter\n", __FUNCTION__);
  				priv->secfeed->release_filter(priv->secfeed,
  							      priv->secfilter);
  				priv->secfilter=NULL;
--- 1124,1143 ----
  
  static int dvb_net_feed_stop(struct net_device *dev)
  {
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  	int i, ret = 0;
  
! 	dprintk("%s\n", __func__);
  	mutex_lock(&priv->mutex);
  	if (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {
  		if (priv->secfeed) {
  			if (priv->secfeed->is_filtering) {
! 				dprintk("%s: stop secfeed\n", __func__);
  				priv->secfeed->stop_filtering(priv->secfeed);
  			}
  
  			if (priv->secfilter) {
! 				dprintk("%s: release secfilter\n", __func__);
  				priv->secfeed->release_filter(priv->secfeed,
  							      priv->secfilter);
  				priv->secfilter=NULL;
***************
*** 1087,1093 ****
  			for (i=0; i<priv->multi_num; i++) {
  				if (priv->multi_secfilter[i]) {
  					dprintk("%s: release multi_filter[%d]\n",
! 						__FUNCTION__, i);
  					priv->secfeed->release_filter(priv->secfeed,
  								      priv->multi_secfilter[i]);
  					priv->multi_secfilter[i] = NULL;
--- 1146,1152 ----
  			for (i=0; i<priv->multi_num; i++) {
  				if (priv->multi_secfilter[i]) {
  					dprintk("%s: release multi_filter[%d]\n",
! 						__func__, i);
  					priv->secfeed->release_filter(priv->secfeed,
  								      priv->multi_secfilter[i]);
  					priv->multi_secfilter[i] = NULL;
***************
*** 1101,1107 ****
  	} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {
  		if (priv->tsfeed) {
  			if (priv->tsfeed->is_filtering) {
! 				dprintk("%s: stop tsfeed\n", __FUNCTION__);
  				priv->tsfeed->stop_filtering(priv->tsfeed);
  			}
  			priv->demux->release_ts_feed(priv->demux, priv->tsfeed);
--- 1160,1166 ----
  	} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {
  		if (priv->tsfeed) {
  			if (priv->tsfeed->is_filtering) {
! 				dprintk("%s: stop tsfeed\n", __func__);
  				priv->tsfeed->stop_filtering(priv->tsfeed);
  			}
  			priv->demux->release_ts_feed(priv->demux, priv->tsfeed);
***************
*** 1118,1124 ****
  
  static int dvb_set_mc_filter (struct net_device *dev, struct dev_mc_list *mc)
  {
! 	struct dvb_net_priv *priv = dev->priv;
  
  	if (priv->multi_num == DVB_NET_MULTICAST_MAX)
  		return -ENOMEM;
--- 1177,1183 ----
  
  static int dvb_set_mc_filter (struct net_device *dev, struct dev_mc_list *mc)
  {
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  
  	if (priv->multi_num == DVB_NET_MULTICAST_MAX)
  		return -ENOMEM;
***************
*** 1130,1144 ****
--- 1189,1220 ----
  }
  
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+ static void wq_set_multicast_list (void *data)
+ #else
  static void wq_set_multicast_list (struct work_struct *work)
+ #endif
  {
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+ 	struct net_device *dev = data;
+ 	struct dvb_net_priv *priv = netdev_priv(dev);
+ #else
  	struct dvb_net_priv *priv =
  		container_of(work, struct dvb_net_priv, set_multicast_list_wq);
  	struct net_device *dev = priv->net;
+ #endif
  
  	dvb_net_feed_stop(dev);
  	priv->rx_mode = RX_MODE_UNI;
+ #ifdef OLD_XMIT_LOCK	/* Kernels equal or lower than 2.6.17 */
+ 	spin_lock_bh(&dev->xmit_lock);
+ #else
+ #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 26)
  	netif_tx_lock_bh(dev);
+ #else
+ 	netif_addr_lock_bh(dev);
+ #endif
+ #endif
  
  	if (dev->flags & IFF_PROMISC) {
  		dprintk("%s: promiscuous mode\n", dev->name);
***************
*** 1163,1185 ****
  		}
  	}
  
  	netif_tx_unlock_bh(dev);
  	dvb_net_feed_start(dev);
  }
  
  
  static void dvb_net_set_multicast_list (struct net_device *dev)
  {
! 	struct dvb_net_priv *priv = dev->priv;
  	schedule_work(&priv->set_multicast_list_wq);
  }
  
  
  static void wq_restart_net_feed (struct work_struct *work)
  {
  	struct dvb_net_priv *priv =
  		container_of(work, struct dvb_net_priv, restart_net_feed_wq);
  	struct net_device *dev = priv->net;
  
  	if (netif_running(dev)) {
  		dvb_net_feed_stop(dev);
--- 1239,1277 ----
  		}
  	}
  
+ #ifdef OLD_XMIT_LOCK	/* Kernels equal or lower than 2.6.17 */
+ 	spin_unlock_bh(&dev->xmit_lock);
+ #else
+ #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 26)
  	netif_tx_unlock_bh(dev);
+ #else
+ 	netif_addr_unlock_bh(dev);
+ #endif
+ #endif
  	dvb_net_feed_start(dev);
  }
  
  
  static void dvb_net_set_multicast_list (struct net_device *dev)
  {
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  	schedule_work(&priv->set_multicast_list_wq);
  }
  
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+ static void wq_restart_net_feed (void *data)
+ #else
  static void wq_restart_net_feed (struct work_struct *work)
+ #endif
  {
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+ 	struct net_device *dev = data;
+ #else
  	struct dvb_net_priv *priv =
  		container_of(work, struct dvb_net_priv, restart_net_feed_wq);
  	struct net_device *dev = priv->net;
+ #endif
  
  	if (netif_running(dev)) {
  		dvb_net_feed_stop(dev);
***************
*** 1190,1196 ****
  
  static int dvb_net_set_mac (struct net_device *dev, void *p)
  {
! 	struct dvb_net_priv *priv = dev->priv;
  	struct sockaddr *addr=p;
  
  	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
--- 1282,1288 ----
  
  static int dvb_net_set_mac (struct net_device *dev, void *p)
  {
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  	struct sockaddr *addr=p;
  
  	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
***************
*** 1204,1210 ****
  
  static int dvb_net_open(struct net_device *dev)
  {
! 	struct dvb_net_priv *priv = dev->priv;
  
  	priv->in_use++;
  	dvb_net_feed_start(dev);
--- 1296,1302 ----
  
  static int dvb_net_open(struct net_device *dev)
  {
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  
  	priv->in_use++;
  	dvb_net_feed_start(dev);
***************
*** 1214,1243 ****
  
  static int dvb_net_stop(struct net_device *dev)
  {
! 	struct dvb_net_priv *priv = dev->priv;
  
  	priv->in_use--;
  	return dvb_net_feed_stop(dev);
  }
  
  static struct net_device_stats * dvb_net_get_stats(struct net_device *dev)
  {
! 	return &((struct dvb_net_priv*) dev->priv)->stats;
  }
  
  static void dvb_net_setup(struct net_device *dev)
  {
  	ether_setup(dev);
  
  	dev->open		= dvb_net_open;
  	dev->stop		= dvb_net_stop;
  	dev->hard_start_xmit	= dvb_net_tx;
  	dev->get_stats		= dvb_net_get_stats;
  	dev->set_multicast_list = dvb_net_set_multicast_list;
  	dev->set_mac_address    = dvb_net_set_mac;
  	dev->mtu		= 4096;
  	dev->mc_count           = 0;
! 	dev->hard_header_cache  = NULL;
  	dev->flags |= IFF_NOARP;
  }
  
--- 1306,1366 ----
  
  static int dvb_net_stop(struct net_device *dev)
  {
! 	struct dvb_net_priv *priv = netdev_priv(dev);
  
  	priv->in_use--;
  	return dvb_net_feed_stop(dev);
  }
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  static struct net_device_stats * dvb_net_get_stats(struct net_device *dev)
  {
! 	return &((struct dvb_net_priv *) netdev_priv(dev))->stats;
  }
+ #endif
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+ static const struct header_ops dvb_header_ops = {
+ 	.create		= eth_header,
+ 	.parse		= eth_header_parse,
+ 	.rebuild	= eth_rebuild_header,
+ };
+ #endif
+ 
+ 
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)
+ static const struct net_device_ops dvb_netdev_ops = {
+ 	.ndo_open		= dvb_net_open,
+ 	.ndo_stop		= dvb_net_stop,
+ 	.ndo_start_xmit		= dvb_net_tx,
+ 	.ndo_set_multicast_list = dvb_net_set_multicast_list,
+ 	.ndo_set_mac_address    = dvb_net_set_mac,
+ 	.ndo_change_mtu		= eth_change_mtu,
+ 	.ndo_validate_addr	= eth_validate_addr,
+ };
+ #endif
  
  static void dvb_net_setup(struct net_device *dev)
  {
  	ether_setup(dev);
  
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+ 	dev->header_ops		= &dvb_header_ops;
+ #else
+ 	dev->hard_header_cache  = NULL;
+ #endif
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
  	dev->open		= dvb_net_open;
  	dev->stop		= dvb_net_stop;
  	dev->hard_start_xmit	= dvb_net_tx;
  	dev->get_stats		= dvb_net_get_stats;
  	dev->set_multicast_list = dvb_net_set_multicast_list;
  	dev->set_mac_address    = dvb_net_set_mac;
+ #else
+ 	dev->netdev_ops		= &dvb_netdev_ops;
+ #endif
  	dev->mtu		= 4096;
  	dev->mc_count           = 0;
! 
  	dev->flags |= IFF_NOARP;
  }
  
***************
*** 1285,1292 ****
  
  	dvbnet->device[if_num] = net;
  
! 	priv = net->priv;
  	priv->net = net;
  	priv->demux = dvbnet->demux;
  	priv->pid = pid;
  	priv->rx_mode = RX_MODE_UNI;
--- 1408,1417 ----
  
  	dvbnet->device[if_num] = net;
  
! 	priv = netdev_priv(net);
! #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
  	priv->net = net;
+ #endif
  	priv->demux = dvbnet->demux;
  	priv->pid = pid;
  	priv->rx_mode = RX_MODE_UNI;
***************
*** 1295,1302 ****
--- 1420,1432 ----
  	priv->feedtype = feedtype;
  	reset_ule(priv);
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+ 	INIT_WORK(&priv->set_multicast_list_wq, wq_set_multicast_list, net);
+ 	INIT_WORK(&priv->restart_net_feed_wq, wq_restart_net_feed, net);
+ #else
  	INIT_WORK(&priv->set_multicast_list_wq, wq_set_multicast_list);
  	INIT_WORK(&priv->restart_net_feed_wq, wq_restart_net_feed);
+ #endif
  	mutex_init(&priv->mutex);
  
  	net->base_addr = pid;
***************
*** 1318,1324 ****
  
  	if (!dvbnet->state[num])
  		return -EINVAL;
! 	priv = net->priv;
  	if (priv->in_use)
  		return -EBUSY;
  
--- 1448,1454 ----
  
  	if (!dvbnet->state[num])
  		return -EINVAL;
! 	priv = netdev_priv(net);
  	if (priv->in_use)
  		return -EBUSY;
  
***************
*** 1374,1380 ****
  
  		netdev = dvbnet->device[dvbnetif->if_num];
  
! 		priv_data = netdev->priv;
  		dvbnetif->pid=priv_data->pid;
  		dvbnetif->feedtype=priv_data->feedtype;
  		break;
--- 1504,1510 ----
  
  		netdev = dvbnet->device[dvbnetif->if_num];
  
! 		priv_data = netdev_priv(netdev);
  		dvbnetif->pid=priv_data->pid;
  		dvbnetif->feedtype=priv_data->feedtype;
  		break;
***************
*** 1425,1431 ****
  
  		netdev = dvbnet->device[dvbnetif->if_num];
  
! 		priv_data = netdev->priv;
  		dvbnetif->pid=priv_data->pid;
  		break;
  	}
--- 1555,1561 ----
  
  		netdev = dvbnet->device[dvbnetif->if_num];
  
! 		priv_data = netdev_priv(netdev);
  		dvbnetif->pid=priv_data->pid;
  		break;
  	}
***************
*** 1446,1463 ****
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_net *dvbnet = dvbdev->priv;
  
! 	if (!dvbdev)
! 		return -ENODEV;
! 
! 	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
! 		dvbdev->readers++;
! 	} else {
! 		dvbdev->writers++;
! 	}
! 
! 	dvbdev->users++;
  
! 	if(dvbdev->users == 1 && dvbnet->exit==1) {
  		fops_put(file->f_op);
  		file->f_op = NULL;
  		wake_up(&dvbdev->wait_queue);
--- 1576,1584 ----
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_net *dvbnet = dvbdev->priv;
  
! 	dvb_generic_release(inode, file);
  
! 	if(dvbdev->users == 1 && dvbnet->exit == 1) {
  		fops_put(file->f_op);
  		file->f_op = NULL;
  		wake_up(&dvbdev->wait_queue);
***************
*** 1466,1472 ****
  }
  
  
! static struct file_operations dvb_net_fops = {
  	.owner = THIS_MODULE,
  	.ioctl = dvb_net_ioctl,
  	.open =	dvb_generic_open,
--- 1587,1593 ----
  }
  
  
! static const struct file_operations dvb_net_fops = {
  	.owner = THIS_MODULE,
  	.ioctl = dvb_net_ioctl,
  	.open =	dvb_generic_open,
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_ringbuffer.c linux-sh4/drivers/media/dvb/dvb-core/dvb_ringbuffer.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_ringbuffer.c	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_ringbuffer.c	Wed May 19 21:10:10 2010
***************
*** 90,96 ****
  	rbuf->error = 0;
  }
  
! 
  
  void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf)
  {
--- 90,100 ----
  	rbuf->error = 0;
  }
  
! void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf)
! {
! 	rbuf->pread = rbuf->pwrite = 0;
! 	rbuf->error = 0;
! }
  
  void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf)
  {
***************
*** 103,137 ****
  	wake_up(&rbuf->queue);
  }
  
! 
! 
! ssize_t dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len, int usermem)
  {
  	size_t todo = len;
  	size_t split;
  
  	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
  	if (split > 0) {
! 		if (!usermem)
! 			memcpy(buf, rbuf->data+rbuf->pread, split);
! 		else
! 			if (copy_to_user(buf, rbuf->data+rbuf->pread, split))
! 				return -EFAULT;
  		buf += split;
  		todo -= split;
  		rbuf->pread = 0;
  	}
! 	if (!usermem)
! 		memcpy(buf, rbuf->data+rbuf->pread, todo);
! 	else
! 		if (copy_to_user(buf, rbuf->data+rbuf->pread, todo))
! 			return -EFAULT;
  
  	rbuf->pread = (rbuf->pread + todo) % rbuf->size;
  
  	return len;
  }
  
  
  
  ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t len)
--- 107,149 ----
  	wake_up(&rbuf->queue);
  }
  
! ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf, u8 __user *buf, size_t len)
  {
  	size_t todo = len;
  	size_t split;
  
  	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
  	if (split > 0) {
! 		if (copy_to_user(buf, rbuf->data+rbuf->pread, split))
! 			return -EFAULT;
  		buf += split;
  		todo -= split;
  		rbuf->pread = 0;
  	}
! 	if (copy_to_user(buf, rbuf->data+rbuf->pread, todo))
! 		return -EFAULT;
  
  	rbuf->pread = (rbuf->pread + todo) % rbuf->size;
  
  	return len;
  }
  
+ void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len)
+ {
+ 	size_t todo = len;
+ 	size_t split;
+ 
+ 	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
+ 	if (split > 0) {
+ 		memcpy(buf, rbuf->data+rbuf->pread, split);
+ 		buf += split;
+ 		todo -= split;
+ 		rbuf->pread = 0;
+ 	}
+ 	memcpy(buf, rbuf->data+rbuf->pread, todo);
+ 
+ 	rbuf->pread = (rbuf->pread + todo) % rbuf->size;
+ }
  
  
  ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t len)
***************
*** 167,174 ****
  	return status;
  }
  
! ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
! 				int offset, u8* buf, size_t len, int usermem)
  {
  	size_t todo;
  	size_t split;
--- 179,186 ----
  	return status;
  }
  
! ssize_t dvb_ringbuffer_pkt_read_user(struct dvb_ringbuffer *rbuf, size_t idx,
! 				int offset, u8 __user *buf, size_t len)
  {
  	size_t todo;
  	size_t split;
***************
*** 183,203 ****
  	todo = len;
  	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
  	if (split > 0) {
! 		if (!usermem)
! 			memcpy(buf, rbuf->data+idx, split);
! 		else
! 			if (copy_to_user(buf, rbuf->data+idx, split))
! 				return -EFAULT;
  		buf += split;
  		todo -= split;
  		idx = 0;
  	}
! 	if (!usermem)
! 		memcpy(buf, rbuf->data+idx, todo);
! 	else
! 		if (copy_to_user(buf, rbuf->data+idx, todo))
! 			return -EFAULT;
  
  	return len;
  }
  
--- 195,234 ----
  	todo = len;
  	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
  	if (split > 0) {
! 		if (copy_to_user(buf, rbuf->data+idx, split))
! 			return -EFAULT;
  		buf += split;
  		todo -= split;
  		idx = 0;
  	}
! 	if (copy_to_user(buf, rbuf->data+idx, todo))
! 		return -EFAULT;
! 
! 	return len;
! }
! 
! ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
! 				int offset, u8* buf, size_t len)
! {
! 	size_t todo;
! 	size_t split;
! 	size_t pktlen;
  
+ 	pktlen = rbuf->data[idx] << 8;
+ 	pktlen |= rbuf->data[(idx + 1) % rbuf->size];
+ 	if (offset > pktlen) return -EINVAL;
+ 	if ((offset + len) > pktlen) len = pktlen - offset;
+ 
+ 	idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
+ 	todo = len;
+ 	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
+ 	if (split > 0) {
+ 		memcpy(buf, rbuf->data+idx, split);
+ 		buf += split;
+ 		todo -= split;
+ 		idx = 0;
+ 	}
+ 	memcpy(buf, rbuf->data+idx, todo);
  	return len;
  }
  
***************
*** 261,271 ****
  EXPORT_SYMBOL(dvb_ringbuffer_empty);
  EXPORT_SYMBOL(dvb_ringbuffer_free);
  EXPORT_SYMBOL(dvb_ringbuffer_avail);
- EXPORT_SYMBOL(dvb_ringbuffer_flush);
  EXPORT_SYMBOL(dvb_ringbuffer_flush_spinlock_wakeup);
  EXPORT_SYMBOL(dvb_ringbuffer_read);
  EXPORT_SYMBOL(dvb_ringbuffer_write);
- EXPORT_SYMBOL(dvb_ringbuffer_pkt_write);
- EXPORT_SYMBOL(dvb_ringbuffer_pkt_read);
- EXPORT_SYMBOL(dvb_ringbuffer_pkt_dispose);
- EXPORT_SYMBOL(dvb_ringbuffer_pkt_next);
--- 292,298 ----
  EXPORT_SYMBOL(dvb_ringbuffer_empty);
  EXPORT_SYMBOL(dvb_ringbuffer_free);
  EXPORT_SYMBOL(dvb_ringbuffer_avail);
  EXPORT_SYMBOL(dvb_ringbuffer_flush_spinlock_wakeup);
+ EXPORT_SYMBOL(dvb_ringbuffer_read_user);
  EXPORT_SYMBOL(dvb_ringbuffer_read);
  EXPORT_SYMBOL(dvb_ringbuffer_write);
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_ringbuffer.h linux-sh4/drivers/media/dvb/dvb-core/dvb_ringbuffer.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_ringbuffer.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_ringbuffer.h	Wed May 19 21:10:18 2010
***************
*** 61,67 ****
  **     *** read min. 1000, max. <bufsize> bytes ***
  **     avail = dvb_ringbuffer_avail(rbuf);
  **     if (avail >= 1000)
! **         count = dvb_ringbuffer_read(rbuf, buffer, min(avail, bufsize), 0);
  **     else
  **         ...
  **
--- 61,67 ----
  **     *** read min. 1000, max. <bufsize> bytes ***
  **     avail = dvb_ringbuffer_avail(rbuf);
  **     if (avail >= 1000)
! **         count = dvb_ringbuffer_read(rbuf, buffer, min(avail, bufsize));
  **     else
  **         ...
  **
***************
*** 69,74 ****
--- 69,75 ----
  **     to lock read or write operations.
  **     Two or more readers must be locked against each other.
  **     Flushing the buffer counts as a read operation.
+ **     Resetting the buffer counts as a read and write operation.
  **     Two or more writers must be locked against each other.
  */
  
***************
*** 85,90 ****
--- 86,98 ----
  extern ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf);
  
  
+ /*
+ ** Reset the read and write pointers to zero and flush the buffer
+ ** This counts as a read and write operation
+ */
+ extern void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf);
+ 
+ 
  /* read routines & macros */
  /* ---------------------- */
  /* flush buffer */
***************
*** 106,113 ****
  ** <usermem> specifies whether <buf> resides in user space
  ** returns number of bytes transferred or -EFAULT
  */
! extern ssize_t dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf,
! 				   size_t len, int usermem);
  
  
  /* write routines & macros */
--- 114,123 ----
  ** <usermem> specifies whether <buf> resides in user space
  ** returns number of bytes transferred or -EFAULT
  */
! extern ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf,
! 				   u8 __user *buf, size_t len);
! extern void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf,
! 				   u8 *buf, size_t len);
  
  
  /* write routines & macros */
***************
*** 149,156 ****
   * <usermem> Set to 1 if <buf> is in userspace.
   * returns Number of bytes read, or -EFAULT.
   */
  extern ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
! 				       int offset, u8* buf, size_t len, int usermem);
  
  /**
   * Dispose of a packet in the ring buffer.
--- 159,168 ----
   * <usermem> Set to 1 if <buf> is in userspace.
   * returns Number of bytes read, or -EFAULT.
   */
+ extern ssize_t dvb_ringbuffer_pkt_read_user(struct dvb_ringbuffer *rbuf, size_t idx,
+ 				       int offset, u8 __user *buf, size_t len);
  extern ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
! 				       int offset, u8 *buf, size_t len);
  
  /**
   * Dispose of a packet in the ring buffer.
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvbdev.c linux-sh4/drivers/media/dvb/dvb-core/dvbdev.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvbdev.c	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvbdev.c	Wed May 19 21:12:14 2010
***************
*** 25,38 ****
  #include <linux/errno.h>
  #include <linux/string.h>
  #include <linux/module.h>
- #include <linux/moduleparam.h>
  #include <linux/kernel.h>
  #include <linux/init.h>
  #include <linux/slab.h>
  #include <linux/device.h>
  #include <linux/fs.h>
  #include <linux/cdev.h>
  #include <linux/mutex.h>
  #include "dvbdev.h"
  
  static int dvbdev_debug;
--- 25,39 ----
  #include <linux/errno.h>
  #include <linux/string.h>
  #include <linux/module.h>
  #include <linux/kernel.h>
  #include <linux/init.h>
  #include <linux/slab.h>
  #include <linux/device.h>
  #include <linux/fs.h>
  #include <linux/cdev.h>
+ #include "compat.h"
  #include <linux/mutex.h>
+ #include <linux/smp_lock.h>
  #include "dvbdev.h"
  
  static int dvbdev_debug;
***************
*** 47,95 ****
  
  static const char * const dnames[] = {
  	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
! 	"net", "osd"
  };
  
! #define DVB_MAX_ADAPTERS	8
  #define DVB_MAX_IDS		4
  #define nums2minor(num,type,id)	((num << 6) | (id << 4) | type)
  #define MAX_DVB_MINORS		(DVB_MAX_ADAPTERS*64)
  
  static struct class *dvb_class;
  
! static struct dvb_device* dvbdev_find_device (int minor)
! {
! 	struct list_head *entry;
! 
! 	list_for_each (entry, &dvb_adapter_list) {
! 		struct list_head *entry0;
! 		struct dvb_adapter *adap;
! 		adap = list_entry (entry, struct dvb_adapter, list_head);
! 		list_for_each (entry0, &adap->device_list) {
! 			struct dvb_device *dev;
! 			dev = list_entry (entry0, struct dvb_device, list_head);
! 			if (nums2minor(adap->num, dev->type, dev->id) == minor)
! 				return dev;
! 		}
! 	}
! 
! 	return NULL;
! }
! 
  
  static int dvb_device_open(struct inode *inode, struct file *file)
  {
  	struct dvb_device *dvbdev;
  
! 	dvbdev = dvbdev_find_device (iminor(inode));
  
  	if (dvbdev && dvbdev->fops) {
  		int err = 0;
  		const struct file_operations *old_fops;
  
  		file->private_data = dvbdev;
  		old_fops = file->f_op;
  		file->f_op = fops_get(dvbdev->fops);
  		if(file->f_op->open)
  			err = file->f_op->open(inode,file);
  		if (err) {
--- 48,97 ----
  
  static const char * const dnames[] = {
  	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
! 	"net", "osd", "ci"
  };
  
! #ifdef CONFIG_DVB_DYNAMIC_MINORS
! #define MAX_DVB_MINORS		256
! #define DVB_MAX_IDS		MAX_DVB_MINORS
! #else
  #define DVB_MAX_IDS		4
  #define nums2minor(num,type,id)	((num << 6) | (id << 4) | type)
  #define MAX_DVB_MINORS		(DVB_MAX_ADAPTERS*64)
+ #endif
  
  static struct class *dvb_class;
  
! static struct dvb_device *dvb_minors[MAX_DVB_MINORS];
! static DECLARE_RWSEM(minor_rwsem);
  
  static int dvb_device_open(struct inode *inode, struct file *file)
  {
  	struct dvb_device *dvbdev;
  
! 	lock_kernel();
! 	down_read(&minor_rwsem);
! 	dvbdev = dvb_minors[iminor(inode)];
  
  	if (dvbdev && dvbdev->fops) {
  		int err = 0;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
  		const struct file_operations *old_fops;
+ #else
+ 		struct file_operations *old_fops;
+ #endif
  
  		file->private_data = dvbdev;
  		old_fops = file->f_op;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
  		file->f_op = fops_get(dvbdev->fops);
+ #else
+ 		file->f_op = (struct file_operations *)fops_get(dvbdev->fops);
+ #endif
+ 		if (file->f_op == NULL) {
+ 			file->f_op = old_fops;
+ 			goto fail;
+ 		}
  		if(file->f_op->open)
  			err = file->f_op->open(inode,file);
  		if (err) {
***************
*** 97,118 ****
  			file->f_op = fops_get(old_fops);
  		}
  		fops_put(old_fops);
  		return err;
  	}
  	return -ENODEV;
  }
  
  
! static struct file_operations dvb_device_fops =
  {
  	.owner =	THIS_MODULE,
  	.open =		dvb_device_open,
  };
  
! static struct cdev dvb_device_cdev = {
! 	.kobj   = {.name = "dvb", },
! 	.owner  =       THIS_MODULE,
! };
  
  int dvb_generic_open(struct inode *inode, struct file *file)
  {
--- 99,122 ----
  			file->f_op = fops_get(old_fops);
  		}
  		fops_put(old_fops);
+ 		up_read(&minor_rwsem);
+ 		unlock_kernel();
  		return err;
  	}
+ fail:
+ 	up_read(&minor_rwsem);
+ 	unlock_kernel();
  	return -ENODEV;
  }
  
  
! static const struct file_operations dvb_device_fops =
  {
  	.owner =	THIS_MODULE,
  	.open =		dvb_device_open,
  };
  
! static struct cdev dvb_device_cdev;
  
  int dvb_generic_open(struct inode *inode, struct file *file)
  {
***************
*** 180,192 ****
  	u32 id = 0;
  
  	while (id < DVB_MAX_IDS) {
! 		struct list_head *entry;
! 		list_for_each (entry, &adap->device_list) {
! 			struct dvb_device *dev;
! 			dev = list_entry (entry, struct dvb_device, list_head);
  			if (dev->type == type && dev->id == id)
  				goto skip;
- 		}
  		return id;
  skip:
  		id++;
--- 184,193 ----
  	u32 id = 0;
  
  	while (id < DVB_MAX_IDS) {
! 		struct dvb_device *dev;
! 		list_for_each_entry(dev, &adap->device_list, list_head)
  			if (dev->type == type && dev->id == id)
  				goto skip;
  		return id;
  skip:
  		id++;
***************
*** 200,206 ****
--- 201,212 ----
  {
  	struct dvb_device *dvbdev;
  	struct file_operations *dvbdevfops;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+ 	struct device *clsdev;
+ #else
  	struct class_device *clsdev;
+ #endif
+ 	int minor;
  	int id;
  
  	mutex_lock(&dvbdev_register_lock);
***************
*** 208,214 ****
  	if ((id = dvbdev_get_free_id (adap, type)) < 0){
  		mutex_unlock(&dvbdev_register_lock);
  		*pdvbdev = NULL;
! 		printk(KERN_ERR "%s: couldn't find free device id\n", __FUNCTION__);
  		return -ENFILE;
  	}
  
--- 214,220 ----
  	if ((id = dvbdev_get_free_id (adap, type)) < 0){
  		mutex_unlock(&dvbdev_register_lock);
  		*pdvbdev = NULL;
! 		printk(KERN_ERR "%s: couldn't find free device id\n", __func__);
  		return -ENFILE;
  	}
  
***************
*** 235,260 ****
  	dvbdev->fops = dvbdevfops;
  	init_waitqueue_head (&dvbdev->wait_queue);
  
! 	memcpy(dvbdev->fops, template->fops, sizeof(struct file_operations));
! 	dvbdev->fops->owner = adap->module;
  
  	list_add_tail (&dvbdev->list_head, &adap->device_list);
  
  	mutex_unlock(&dvbdev_register_lock);
  
! 	clsdev = class_device_create(dvb_class, NULL, MKDEV(DVB_MAJOR,
! 				     nums2minor(adap->num, type, id)),
! 				     adap->device, "dvb%d.%s%d", adap->num,
! 				     dnames[type], id);
  	if (IS_ERR(clsdev)) {
  		printk(KERN_ERR "%s: failed to create device dvb%d.%s%d (%ld)\n",
! 		       __FUNCTION__, adap->num, dnames[type], id, PTR_ERR(clsdev));
  		return PTR_ERR(clsdev);
  	}
  
  	dprintk(KERN_DEBUG "DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
! 		adap->num, dnames[type], id, nums2minor(adap->num, type, id),
! 		nums2minor(adap->num, type, id));
  
  	return 0;
  }
--- 241,294 ----
  	dvbdev->fops = dvbdevfops;
  	init_waitqueue_head (&dvbdev->wait_queue);
  
! 	memcpy(dvbdevfops, template->fops, sizeof(struct file_operations));
! 	dvbdevfops->owner = adap->module;
  
  	list_add_tail (&dvbdev->list_head, &adap->device_list);
  
+ 	down_write(&minor_rwsem);
+ #ifdef CONFIG_DVB_DYNAMIC_MINORS
+ 	for (minor = 0; minor < MAX_DVB_MINORS; minor++)
+ 		if (dvb_minors[minor] == NULL)
+ 			break;
+ 
+ 	if (minor == MAX_DVB_MINORS) {
+ 		kfree(dvbdevfops);
+ 		kfree(dvbdev);
+ 		mutex_unlock(&dvbdev_register_lock);
+ 		return -EINVAL;
+ 	}
+ #else
+ 	minor = nums2minor(adap->num, type, id);
+ #endif
+ 
+ 	dvbdev->minor = minor;
+ 	dvb_minors[minor] = dvbdev;
+ 	up_write(&minor_rwsem);
+ 
  	mutex_unlock(&dvbdev_register_lock);
  
! #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27)
! 	clsdev = device_create(dvb_class, adap->device,
! 			       MKDEV(DVB_MAJOR, minor),
! 			       dvbdev, "dvb%d.%s%d", adap->num, dnames[type], id);
! #elif LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 27)
! 	clsdev = device_create_drvdata(dvb_class, adap->device,
! 			       MKDEV(DVB_MAJOR, minor),
! 			       dvbdev, "dvb%d.%s%d", adap->num, dnames[type], id);
! #else
! 	clsdev = device_create(dvb_class, adap->device,
! 			       MKDEV(DVB_MAJOR, minor),
! 			       "dvb%d.%s%d", adap->num, dnames[type], id);
! #endif
  	if (IS_ERR(clsdev)) {
  		printk(KERN_ERR "%s: failed to create device dvb%d.%s%d (%ld)\n",
! 		       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));
  		return PTR_ERR(clsdev);
  	}
  
  	dprintk(KERN_DEBUG "DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
! 		adap->num, dnames[type], id, minor, minor);
  
  	return 0;
  }
***************
*** 266,273 ****
  	if (!dvbdev)
  		return;
  
! 	class_device_destroy(dvb_class, MKDEV(DVB_MAJOR, nums2minor(dvbdev->adapter->num,
! 					dvbdev->type, dvbdev->id)));
  
  	list_del (&dvbdev->list_head);
  	kfree (dvbdev->fops);
--- 300,310 ----
  	if (!dvbdev)
  		return;
  
! 	down_write(&minor_rwsem);
! 	dvb_minors[dvbdev->minor] = NULL;
! 	up_write(&minor_rwsem);
! 
! 	device_destroy(dvb_class, MKDEV(DVB_MAJOR, dvbdev->minor));
  
  	list_del (&dvbdev->list_head);
  	kfree (dvbdev->fops);
***************
*** 275,295 ****
  }
  EXPORT_SYMBOL(dvb_unregister_device);
  
  
  static int dvbdev_get_free_adapter_num (void)
  {
  	int num = 0;
  
  	while (num < DVB_MAX_ADAPTERS) {
! 		struct list_head *entry;
! 		list_for_each (entry, &dvb_adapter_list) {
! 			struct dvb_adapter *adap;
! 			adap = list_entry (entry, struct dvb_adapter, list_head);
! 			if (adap->num == num)
! 				goto skip;
! 		}
! 		return num;
! skip:
  		num++;
  	}
  
--- 312,336 ----
  }
  EXPORT_SYMBOL(dvb_unregister_device);
  
+ static int dvbdev_check_free_adapter_num(int num)
+ {
+ 	struct list_head *entry;
+ 	list_for_each(entry, &dvb_adapter_list) {
+ 		struct dvb_adapter *adap;
+ 		adap = list_entry(entry, struct dvb_adapter, list_head);
+ 		if (adap->num == num)
+ 			return 0;
+ 	}
+ 	return 1;
+ }
  
  static int dvbdev_get_free_adapter_num (void)
  {
  	int num = 0;
  
  	while (num < DVB_MAX_ADAPTERS) {
! 		if (dvbdev_check_free_adapter_num(num))
! 			return num;
  		num++;
  	}
  
***************
*** 297,309 ****
  }
  
  
! int dvb_register_adapter(struct dvb_adapter *adap, const char *name, struct module *module, struct device *device)
  {
! 	int num;
  
  	mutex_lock(&dvbdev_register_lock);
  
! 	if ((num = dvbdev_get_free_adapter_num ()) < 0) {
  		mutex_unlock(&dvbdev_register_lock);
  		return -ENFILE;
  	}
--- 338,365 ----
  }
  
  
! int dvb_register_adapter(struct dvb_adapter *adap, const char *name,
! 			 struct module *module, struct device *device,
! 			 short *adapter_nums)
  {
! 	int i, num;
  
  	mutex_lock(&dvbdev_register_lock);
  
! 	for (i = 0; i < DVB_MAX_ADAPTERS; ++i) {
! 		num = adapter_nums[i];
! 		if (num >= 0  &&  num < DVB_MAX_ADAPTERS) {
! 		/* use the one the driver asked for */
! 			if (dvbdev_check_free_adapter_num(num))
! 				break;
! 		} else {
! 			num = dvbdev_get_free_adapter_num();
! 			break;
! 		}
! 		num = -1;
! 	}
! 
! 	if (num < 0) {
  		mutex_unlock(&dvbdev_register_lock);
  		return -ENFILE;
  	}
***************
*** 317,327 ****
--- 373,387 ----
  	adap->name = name;
  	adap->module = module;
  	adap->device = device;
+ 	adap->mfe_shared = 0;
+ 	adap->mfe_dvbdev = NULL;
+ 	mutex_init (&adap->mfe_lock);
  
  	list_add_tail (&adap->list_head, &dvb_adapter_list);
  
  	mutex_unlock(&dvbdev_register_lock);
  
+ 	printk(KERN_INFO "DVB: adapter (%s) registerd num=%d\n", name, num);
  	return num;
  }
  EXPORT_SYMBOL(dvb_register_adapter);
***************
*** 401,406 ****
--- 461,493 ----
  	return err;
  }
  
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+ static int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	struct dvb_device *dvbdev = dev_get_drvdata(dev);
+ 
+ 	add_uevent_var(env, "DVB_ADAPTER_NUM=%d", dvbdev->adapter->num);
+ 	add_uevent_var(env, "DVB_DEVICE_TYPE=%s", dnames[dvbdev->type]);
+ 	add_uevent_var(env, "DVB_DEVICE_NUM=%d", dvbdev->id);
+ 	return 0;
+ }
+ #endif
+ 
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31)
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+ static char *dvb_nodename(struct device *dev)
+ #else
+ static char *dvb_devnode(struct device *dev, mode_t *mode)
+ #endif
+ {
+ 	struct dvb_device *dvbdev = dev_get_drvdata(dev);
+ 
+ 	return kasprintf(GFP_KERNEL, "dvb/adapter%d/%s%d",
+ 		dvbdev->adapter->num, dnames[dvbdev->type], dvbdev->id);
+ }
+ 
+ 
+ #endif
  static int __init init_dvbdev(void)
  {
  	int retval;
***************
*** 411,417 ****
--- 498,509 ----
  		return retval;
  	}
  
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
  	cdev_init(&dvb_device_cdev, &dvb_device_fops);
+ #else
+ 	cdev_init(&dvb_device_cdev,
+ 			(struct file_operations *)&dvb_device_fops);
+ #endif
  	if ((retval = cdev_add(&dvb_device_cdev, dev, MAX_DVB_MINORS)) != 0) {
  		printk(KERN_ERR "dvb-core: unable register character device\n");
  		goto error;
***************
*** 422,427 ****
--- 514,527 ----
  		retval = PTR_ERR(dvb_class);
  		goto error;
  	}
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+ 	dvb_class->dev_uevent = dvb_uevent;
+ #endif
+ #if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 31)
+ 	dvb_class->nodename = dvb_nodename;
+ #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31)
+ 	dvb_class->devnode = dvb_devnode;
+ #endif
  	return 0;
  
  error:
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvbdev.h linux-sh4/drivers/media/dvb/dvb-core/dvbdev.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvbdev.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/drivers/media/dvb/dvb-core/dvbdev.h	Wed May 19 21:12:42 2010
***************
*** 27,36 ****
  #include <linux/poll.h>
  #include <linux/fs.h>
  #include <linux/list.h>
- #include <linux/smp_lock.h>
  
  #define DVB_MAJOR 212
  
  #define DVB_DEVICE_VIDEO      0
  #define DVB_DEVICE_AUDIO      1
  #define DVB_DEVICE_SEC        2
--- 27,43 ----
  #include <linux/poll.h>
  #include <linux/fs.h>
  #include <linux/list.h>
  
  #define DVB_MAJOR 212
  
+ #if defined(CONFIG_DVB_MAX_ADAPTERS) && CONFIG_DVB_MAX_ADAPTERS > 0
+   #define DVB_MAX_ADAPTERS CONFIG_DVB_MAX_ADAPTERS
+ #else
+   #define DVB_MAX_ADAPTERS 8
+ #endif
+ 
+ #define DVB_UNSET (-1)
+ 
  #define DVB_DEVICE_VIDEO      0
  #define DVB_DEVICE_AUDIO      1
  #define DVB_DEVICE_SEC        2
***************
*** 40,46 ****
--- 47,61 ----
  #define DVB_DEVICE_CA         6
  #define DVB_DEVICE_NET        7
  #define DVB_DEVICE_OSD        8
+ #define DVB_DEVICE_CI         9
  
+ #define DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr) \
+ 	static short adapter_nr[] = \
+ 		{[0 ... (DVB_MAX_ADAPTERS - 1)] = DVB_UNSET }; \
+ 	module_param_array(adapter_nr, short, NULL, 0444); \
+ 	MODULE_PARM_DESC(adapter_nr, "DVB adapter numbers")
+ 
+ struct dvb_frontend;
  
  struct dvb_adapter {
  	int num;
***************
*** 53,66 ****
  	struct device *device;
  
  	struct module *module;
  };
  
  
  struct dvb_device {
  	struct list_head list_head;
! 	struct file_operations *fops;
  	struct dvb_adapter *adapter;
  	int type;
  	u32 id;
  
  	/* in theory, 'users' can vanish now,
--- 68,112 ----
  	struct device *device;
  
  	struct module *module;
+ 
+ 	int mfe_shared;			/* indicates mutually exclusive frontends */
+ 	struct dvb_device *mfe_dvbdev;	/* frontend device in use */
+ 	struct mutex mfe_lock;		/* access lock for thread creation */
+ 
+ 	/* Allow the adapter/bridge driver to perform an action before and/or
+ 	 * after the core handles an ioctl:
+ 	 *
+ 	 * DVB_FE_IOCTL_PRE indicates that the ioctl has not yet been handled.
+ 	 * DVB_FE_IOCTL_POST indicates that the ioctl has been handled.
+ 	 *
+ 	 * When DVB_FE_IOCTL_PRE is passed to the callback as the stage arg:
+ 	 *
+ 	 * return 0 to allow dvb-core to handle the ioctl.
+ 	 * return a positive int to prevent dvb-core from handling the ioctl,
+ 	 * 	and exit without error.
+ 	 * return a negative int to prevent dvb-core from handling the ioctl,
+ 	 * 	and return that value as an error.
+ 	 *
+ 	 * When DVB_FE_IOCTL_POST is passed to the callback as the stage arg:
+ 	 *
+ 	 * return 0 to allow the dvb_frontend ioctl handler to exit normally.
+ 	 * return a negative int to cause the dvb_frontend ioctl handler to
+ 	 * 	return that value as an error.
+ 	 */
+ #define DVB_FE_IOCTL_PRE 0
+ #define DVB_FE_IOCTL_POST 1
+ 	int (*fe_ioctl_override)(struct dvb_frontend *fe,
+ 				 unsigned int cmd, void *parg,
+ 				 unsigned int stage);
  };
  
  
  struct dvb_device {
  	struct list_head list_head;
! 	const struct file_operations *fops;
  	struct dvb_adapter *adapter;
  	int type;
+ 	int minor;
  	u32 id;
  
  	/* in theory, 'users' can vanish now,
***************
*** 78,84 ****
  };
  
  
! extern int dvb_register_adapter (struct dvb_adapter *adap, const char *name, struct module *module, struct device *device);
  extern int dvb_unregister_adapter (struct dvb_adapter *adap);
  
  extern int dvb_register_device (struct dvb_adapter *adap,
--- 124,132 ----
  };
  
  
! extern int dvb_register_adapter(struct dvb_adapter *adap, const char *name,
! 				struct module *module, struct device *device,
! 				short *adapter_nums);
  extern int dvb_unregister_adapter (struct dvb_adapter *adap);
  
  extern int dvb_register_device (struct dvb_adapter *adap,
***************
*** 104,110 ****
  			    unsigned int cmd, void *arg));
  
  /** generic DVB attach function. */
! #ifdef CONFIG_DVB_CORE_ATTACH
  #define dvb_attach(FUNCTION, ARGS...) ({ \
  	void *__r = NULL; \
  	typeof(&FUNCTION) __a = symbol_request(FUNCTION); \
--- 152,158 ----
  			    unsigned int cmd, void *arg));
  
  /** generic DVB attach function. */
! #ifdef CONFIG_MEDIA_ATTACH
  #define dvb_attach(FUNCTION, ARGS...) ({ \
  	void *__r = NULL; \
  	typeof(&FUNCTION) __a = symbol_request(FUNCTION); \

diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/ca.h linux-sh4/include/linux/dvb/ca.h
*** linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/ca.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/include/linux/dvb/ca.h	Fri Mar  5 02:31:46 2010
***************
*** 39,44 ****
--- 39,45 ----
  	unsigned int flags;
  #define CA_CI_MODULE_PRESENT 1 /* module (or card) inserted */
  #define CA_CI_MODULE_READY   2
+ #define CA_CI_MODULE_INVALID 3
  } ca_slot_info_t;
  
  
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/dmx.h linux-sh4/include/linux/dvb/dmx.h
*** linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/dmx.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/include/linux/dvb/dmx.h	Fri Mar  5 02:32:29 2010
***************
*** 39,47 ****
  	DMX_OUT_DECODER, /* Streaming directly to decoder. */
  	DMX_OUT_TAP,     /* Output going to a memory buffer */
  			 /* (to be retrieved via the read command).*/
! 	DMX_OUT_TS_TAP   /* Output multiplexed into a new TS  */
  			 /* (to be retrieved by reading from the */
  			 /* logical DVR device).                 */
  } dmx_output_t;
  
  
--- 39,48 ----
  	DMX_OUT_DECODER, /* Streaming directly to decoder. */
  	DMX_OUT_TAP,     /* Output going to a memory buffer */
  			 /* (to be retrieved via the read command).*/
! 	DMX_OUT_TS_TAP,  /* Output multiplexed into a new TS  */
  			 /* (to be retrieved by reading from the */
  			 /* logical DVR device).                 */
+ 	DMX_OUT_TSDEMUX_TAP /* Like TS_TAP but retrieved from the DMX device */
  } dmx_output_t;
  
  
***************
*** 150,154 ****
--- 151,157 ----
  #define DMX_GET_CAPS             _IOR('o', 48, dmx_caps_t)
  #define DMX_SET_SOURCE           _IOW('o', 49, dmx_source_t)
  #define DMX_GET_STC              _IOWR('o', 50, struct dmx_stc)
+ #define DMX_ADD_PID              _IOW('o', 51, __u16)
+ #define DMX_REMOVE_PID           _IOW('o', 52, __u16)
  
  #endif /*_DVBDMX_H_*/
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/frontend.h linux-sh4/include/linux/dvb/frontend.h
*** linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/frontend.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/include/linux/dvb/frontend.h	Fri Mar  5 22:00:46 2010
***************
*** 28,34 ****
  
  #include <asm/types.h>
  
- 
  typedef enum fe_type {
  	FE_QPSK,
  	FE_QAM,
--- 28,33 ----
***************
*** 39,45 ****
  
  typedef enum fe_caps {
  	FE_IS_STUPID			= 0,
! 	FE_CAN_INVERSION_AUTO		= 0x1,
  	FE_CAN_FEC_1_2			= 0x2,
  	FE_CAN_FEC_2_3			= 0x4,
  	FE_CAN_FEC_3_4			= 0x8,
--- 38,44 ----
  
  typedef enum fe_caps {
  	FE_IS_STUPID			= 0,
! 	FE_CAN_INVERSION_AUTO	= 0x1,
  	FE_CAN_FEC_1_2			= 0x2,
  	FE_CAN_FEC_2_3			= 0x4,
  	FE_CAN_FEC_3_4			= 0x8,
***************
*** 49,55 ****
  	FE_CAN_FEC_7_8			= 0x80,
  	FE_CAN_FEC_8_9			= 0x100,
  	FE_CAN_FEC_AUTO			= 0x200,
! 	FE_CAN_QPSK			= 0x400,
  	FE_CAN_QAM_16			= 0x800,
  	FE_CAN_QAM_32			= 0x1000,
  	FE_CAN_QAM_64			= 0x2000,
--- 48,54 ----
  	FE_CAN_FEC_7_8			= 0x80,
  	FE_CAN_FEC_8_9			= 0x100,
  	FE_CAN_FEC_AUTO			= 0x200,
! 	FE_CAN_QPSK				= 0x400,
  	FE_CAN_QAM_16			= 0x800,
  	FE_CAN_QAM_32			= 0x1000,
  	FE_CAN_QAM_64			= 0x2000,
***************
*** 60,70 ****
  	FE_CAN_BANDWIDTH_AUTO		= 0x40000,
  	FE_CAN_GUARD_INTERVAL_AUTO	= 0x80000,
  	FE_CAN_HIERARCHY_AUTO		= 0x100000,
! 	FE_CAN_8VSB			= 0x200000,
  	FE_CAN_16VSB			= 0x400000,
! 	FE_NEEDS_BENDING		= 0x20000000, // not supported anymore, don't use (frontend requires frequency bending)
! 	FE_CAN_RECOVER			= 0x40000000, // frontend can recover from a cable unplug automatically
! 	FE_CAN_MUTE_TS			= 0x80000000  // frontend can stop spurious TS data output
  } fe_caps_t;
  
  
--- 59,71 ----
  	FE_CAN_BANDWIDTH_AUTO		= 0x40000,
  	FE_CAN_GUARD_INTERVAL_AUTO	= 0x80000,
  	FE_CAN_HIERARCHY_AUTO		= 0x100000,
! 	FE_CAN_8VSB				= 0x200000,
  	FE_CAN_16VSB			= 0x400000,
! 	FE_HAS_EXTENDED_CAPS	= 0x800000,   /* We need more bitspace for newer APIs, indicate this. */
! 	FE_CAN_2G_MODULATION	= 0x10000000, /* frontend supports "2nd generation modulation" (DVB-S2) */
! 	FE_NEEDS_BENDING		= 0x20000000, /* not supported anymore, don't use (frontend requires frequency bending) */
! 	FE_CAN_RECOVER			= 0x40000000, /* frontend can recover from a cable unplug automatically */
! 	FE_CAN_MUTE_TS			= 0x80000000  /* frontend can stop spurious TS data output */
  } fe_caps_t;
  
  
***************
*** 120,134 ****
  
  
  typedef enum fe_status {
! 	FE_HAS_SIGNAL	= 0x01,   /*  found something above the noise level */
! 	FE_HAS_CARRIER	= 0x02,   /*  found a DVB signal  */
! 	FE_HAS_VITERBI	= 0x04,   /*  FEC is stable  */
! 	FE_HAS_SYNC	= 0x08,   /*  found sync bytes  */
! 	FE_HAS_LOCK	= 0x10,   /*  everything's working... */
! 	FE_TIMEDOUT	= 0x20,   /*  no lock within the last ~2 seconds */
! 	FE_REINIT	= 0x40    /*  frontend was reinitialized,  */
! } fe_status_t;			  /*  application is recommended to reset */
! 				  /*  DiSEqC, tone and parameters */
  
  typedef enum fe_spectral_inversion {
  	INVERSION_OFF,
--- 121,135 ----
  
  
  typedef enum fe_status {
! 	FE_HAS_SIGNAL	= 0x01,   /* found something above the noise level */
! 	FE_HAS_CARRIER	= 0x02,   /* found a DVB signal  */
! 	FE_HAS_VITERBI	= 0x04,   /* FEC is stable  */
! 	FE_HAS_SYNC	= 0x08,   /* found sync bytes  */
! 	FE_HAS_LOCK	= 0x10,   /* everything's working... */
! 	FE_TIMEDOUT	= 0x20,   /* no lock within the last ~2 seconds */
! 	FE_REINIT	= 0x40    /* frontend was reinitialized,  */
! } fe_status_t;			  /* application is recommended to reset */
! 				  /* DiSEqC, tone and parameters */
  
  typedef enum fe_spectral_inversion {
  	INVERSION_OFF,
***************
*** 147,153 ****
  	FEC_6_7,
  	FEC_7_8,
  	FEC_8_9,
! 	FEC_AUTO
  } fe_code_rate_t;
  
  
--- 148,156 ----
  	FEC_6_7,
  	FEC_7_8,
  	FEC_8_9,
! 	FEC_AUTO,
! 	FEC_3_5,
! 	FEC_9_10,
  } fe_code_rate_t;
  
  
***************
*** 160,172 ****
  	QAM_256,
  	QAM_AUTO,
  	VSB_8,
! 	VSB_16
  } fe_modulation_t;
  
  typedef enum fe_transmit_mode {
  	TRANSMISSION_MODE_2K,
  	TRANSMISSION_MODE_8K,
! 	TRANSMISSION_MODE_AUTO
  } fe_transmit_mode_t;
  
  typedef enum fe_bandwidth {
--- 163,180 ----
  	QAM_256,
  	QAM_AUTO,
  	VSB_8,
! 	VSB_16,
! 	PSK_8,
! 	APSK_16,
! 	APSK_32,
! 	DQPSK,
  } fe_modulation_t;
  
  typedef enum fe_transmit_mode {
  	TRANSMISSION_MODE_2K,
  	TRANSMISSION_MODE_8K,
! 	TRANSMISSION_MODE_AUTO,
! 	TRANSMISSION_MODE_4K
  } fe_transmit_mode_t;
  
  typedef enum fe_bandwidth {
***************
*** 239,244 ****
--- 247,380 ----
  	struct dvb_frontend_parameters parameters;
  };
  
+ /* S2API Commands */
+ #define DTV_UNDEFINED		0
+ #define DTV_TUNE			1
+ #define DTV_CLEAR			2
+ #define DTV_FREQUENCY		3
+ #define DTV_MODULATION		4
+ #define DTV_BANDWIDTH_HZ	5
+ #define DTV_INVERSION		6
+ #define DTV_DISEQC_MASTER	7
+ #define DTV_SYMBOL_RATE		8
+ #define DTV_INNER_FEC		9
+ #define DTV_VOLTAGE			10
+ #define DTV_TONE			11
+ #define DTV_PILOT			12
+ #define DTV_ROLLOFF			13
+ #define DTV_DISEQC_SLAVE_REPLY	14
+ 
+ /* Basic enumeration set for querying unlimited capabilities */
+ #define DTV_FE_CAPABILITY_COUNT	15
+ #define DTV_FE_CAPABILITY	16
+ #define DTV_DELIVERY_SYSTEM	17
+ 
+ /* ISDB-T and ISDB-Tsb */
+ #define DTV_ISDBT_PARTIAL_RECEPTION	18
+ #define DTV_ISDBT_SOUND_BROADCASTING	19
+ 
+ #define DTV_ISDBT_SB_SUBCHANNEL_ID	20
+ #define DTV_ISDBT_SB_SEGMENT_IDX	21
+ #define DTV_ISDBT_SB_SEGMENT_COUNT	22
+ 
+ #define DTV_ISDBT_LAYERA_FEC			23
+ #define DTV_ISDBT_LAYERA_MODULATION		24
+ #define DTV_ISDBT_LAYERA_SEGMENT_COUNT		25
+ #define DTV_ISDBT_LAYERA_TIME_INTERLEAVING	26
+ 
+ #define DTV_ISDBT_LAYERB_FEC			27
+ #define DTV_ISDBT_LAYERB_MODULATION		28
+ #define DTV_ISDBT_LAYERB_SEGMENT_COUNT		29
+ #define DTV_ISDBT_LAYERB_TIME_INTERLEAVING	30
+ 
+ #define DTV_ISDBT_LAYERC_FEC			31
+ #define DTV_ISDBT_LAYERC_MODULATION		32
+ #define DTV_ISDBT_LAYERC_SEGMENT_COUNT		33
+ #define DTV_ISDBT_LAYERC_TIME_INTERLEAVING	34
+ 
+ #define DTV_API_VERSION		35
+ 
+ #define DTV_CODE_RATE_HP	36
+ #define DTV_CODE_RATE_LP	37
+ #define DTV_GUARD_INTERVAL	38
+ #define DTV_TRANSMISSION_MODE	39
+ #define DTV_HIERARCHY		40
+ 
+ #define DTV_ISDBT_LAYER_ENABLED	41
+ 
+ #define DTV_ISDBS_TS_ID		42
+ 
+ #define DTV_MAX_COMMAND				DTV_ISDBS_TS_ID
+ 
+ typedef enum fe_pilot {
+ 	PILOT_ON,
+ 	PILOT_OFF,
+ 	PILOT_AUTO,
+ } fe_pilot_t;
+ 
+ typedef enum fe_rolloff {
+ 	ROLLOFF_35, /* Implied value in DVB-S, default for DVB-S2 */
+ 	ROLLOFF_20,
+ 	ROLLOFF_25,
+ 	ROLLOFF_AUTO,
+ } fe_rolloff_t;
+ 
+ typedef enum fe_delivery_system {
+ 	SYS_UNDEFINED,
+ 	SYS_DVBC_ANNEX_AC,
+ 	SYS_DVBC_ANNEX_B,
+ 	SYS_DVBT,
+ 	SYS_DSS,
+ 	SYS_DVBS,
+ 	SYS_DVBS2,
+ 	SYS_DVBH,
+ 	SYS_ISDBT,
+ 	SYS_ISDBS,
+ 	SYS_ISDBC,
+ 	SYS_ATSC,
+ 	SYS_ATSCMH,
+ 	SYS_DMBTH,
+ 	SYS_CMMB,
+ 	SYS_DAB,
+ } fe_delivery_system_t;
+ 
+ struct dtv_cmds_h {
+ 	char	*name;		/* A display name for debugging purposes */
+ 
+ 	__u32	cmd;		/* A unique ID */
+ 
+ 	/* Flags */
+ 	__u32	set:1;		/* Either a set or get property */
+ 	__u32	buffer:1;	/* Does this property use the buffer? */
+ 	__u32	reserved:30;	/* Align */
+ };
+ 
+ struct dtv_property {
+ 	__u32 cmd;
+ 	__u32 reserved[3];
+ 	union {
+ 		__u32 data;
+ 		struct {
+ 			__u8 data[32];
+ 			__u32 len;
+ 			__u32 reserved1[3];
+ 			void *reserved2;
+ 		} buffer;
+ 	} u;
+ 	int result;
+ } __attribute__ ((packed));
+ 
+ /* num of properties cannot exceed DTV_IOCTL_MAX_MSGS per ioctl */
+ #define DTV_IOCTL_MAX_MSGS 64
+ 
+ struct dtv_properties {
+ 	__u32 num;
+ 	struct dtv_property *props;
+ };
+ 
+ #define FE_SET_PROPERTY		   _IOW('o', 82, struct dtv_properties)
+ #define FE_GET_PROPERTY		   _IOR('o', 83, struct dtv_properties)
+ 
  
  /**
   * When set, this flag will disable any zigzagging or other "normal" tuning
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/version.h linux-sh4/include/linux/dvb/version.h
*** linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/version.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/include/linux/dvb/version.h	Sat Feb 27 10:18:52 2010
***************
*** 23,29 ****
  #ifndef _DVBVERSION_H_
  #define _DVBVERSION_H_
  
! #define DVB_API_VERSION 3
! #define DVB_API_VERSION_MINOR 2
  
  #endif /*_DVBVERSION_H_*/
--- 23,29 ----
  #ifndef _DVBVERSION_H_
  #define _DVBVERSION_H_
  
! #define DVB_API_VERSION 5
! #define DVB_API_VERSION_MINOR 1
  
  #endif /*_DVBVERSION_H_*/
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/video.h linux-sh4/include/linux/dvb/video.h
*** linux-sh4-2.6.23.17_stm23_0119_orig2/include/linux/dvb/video.h	Tue Oct  9 22:31:38 2007
--- linux-sh4/include/linux/dvb/video.h	Fri Mar  5 02:34:45 2010
***************
*** 25,35 ****
  #define _DVBVIDEO_H_
  
  #include <linux/compiler.h>
- 
  #ifdef __KERNEL__
  #include <linux/types.h>
  #else
- #include <asm/types.h>
  #include <stdint.h>
  #include <time.h>
  #endif
--- 25,33 ----
***************
*** 103,113 ****
  /* The structure must be zeroed before use by the application
     This ensures it can be extended safely in the future. */
  struct video_command {
! 	__u32 cmd;
! 	__u32 flags;
  	union {
  		struct {
! 			__u64 pts;
  		} stop;
  
  		struct {
--- 101,111 ----
  /* The structure must be zeroed before use by the application
     This ensures it can be extended safely in the future. */
  struct video_command {
! 	unsigned int cmd;
! 	unsigned int flags;
  	union {
  		struct {
! 			unsigned long long pts;
  		} stop;
  
  		struct {
***************
*** 116,131 ****
  			   -1 specifies backward single stepping,
  			   >1: playback at speed/1000 of the normal speed,
  			   <-1: reverse playback at (-speed/1000) of the normal speed. */
! 			__s32 speed;
! 			__u32 format;
  		} play;
  
  		struct {
! 			__u32 data[16];
  		} raw;
  	};
  };
- 
  /* FIELD_UNKNOWN can be used if the hardware does not know whether
     the Vsync is for an odd, even or progressive (i.e. non-interlaced)
     field. */
--- 114,134 ----
  			   -1 specifies backward single stepping,
  			   >1: playback at speed/1000 of the normal speed,
  			   <-1: reverse playback at (-speed/1000) of the normal speed. */
! 			int          speed;
! 			unsigned int format;
  		} play;
  
  		struct {
! 			unsigned int data[16];
  		} raw;
+ 
+ 		struct {
+ 			unsigned int    option; /* really dvb_option_t but like this so don't modify kernel sources too much */
+ 			unsigned int    value;
+ 		} option;
+ 
  	};
  };
  /* FIELD_UNKNOWN can be used if the hardware does not know whether
     the Vsync is for an odd, even or progressive (i.e. non-interlaced)
     field. */
