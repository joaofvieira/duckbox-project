diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/epld.c linux/arch/sh/boards/st/stb7109eref/epld.c
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/epld.c	1970-01-01 01:00:00.000000000 +0100
--- linux/arch/sh/boards/st/stb7109eref/epld.c	2008-11-29 11:39:33.000000000 +0100
***************
*** 0 ****
--- 1,77 ----
+ /*
+  * Copyright (C) 2007 STMicroelectronics Limited
+  * Author: Stuart Menefy <stuart.menefy@st.com>
+  *
+  * May be copied or modified under the terms of the GNU General Public
+  * License.  See linux/COPYING for more information.
+  */
+ 
+ #include <linux/kernel.h>
+ #include <linux/platform_device.h>
+ #include <asm/io.h>
+ #include "epld.h"
+ 
+ #define DRIVER_NAME "epld"
+ 
+ static void __iomem *epld_base;
+ static int epld_opsize;
+ 
+ void epld_write(unsigned long value, unsigned long offset)
+ {
+ 	if (epld_opsize == 16)
+ 		writew(value, epld_base + offset);
+ 	else
+ 		writeb(value, epld_base + offset);
+ }
+ 
+ unsigned long epld_read(unsigned long offset)
+ {
+ 	if (epld_opsize == 16)
+ 		return readw(epld_base + offset);
+ 	else
+ 		return readb(epld_base + offset);
+ }
+ 
+ void __init epld_early_init(struct platform_device *pdev)
+ {
+ 	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+ 	struct plat_epld_data *data = pdev->dev.platform_data;
+ 
+ 	epld_base = ioremap(pdev->resource[0].start, size);
+ 	if (!epld_base)
+ 		panic("Unable to ioremap EPLD");
+ 
+ 	if (data) {
+ 		epld_opsize = data->opsize;
+ 	}
+ }
+ 
+ static int __init epld_probe(struct platform_device *pdev)
+ {
+ 	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+ 
+ 	if (!request_mem_region(pdev->resource[0].start, size, pdev->name))
+ 		return -EBUSY;
+ 
+ 	if (epld_base)
+ 		return 0;
+ 
+ 	epld_early_init(pdev);
+ 
+ 	return 0;
+ }
+ 
+ static struct platform_driver epld_driver = {
+ 	.probe		= epld_probe,
+ 	.driver	= {
+ 		.name	= DRIVER_NAME,
+ 		.owner	= THIS_MODULE,
+ 	},
+ };
+ 
+ static int __init epld_init(void)
+ {
+ 	return platform_driver_register(&epld_driver);
+ }
+ 
+ arch_initcall(epld_init);
diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/epld.h linux/arch/sh/boards/st/stb7109eref/epld.h
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/epld.h	1970-01-01 01:00:00.000000000 +0100
--- linux/arch/sh/boards/st/stb7109eref/epld.h	2008-11-29 11:39:33.000000000 +0100
***************
*** 0 ****
--- 1,15 ----
+ 
+ #define EPLD_FLASH              0x400000
+ 
+ #define EPLD_BASE               0x03000000
+ #define EPLD_SIZE               0x00800000
+ 
+ void epld_write(unsigned long value, unsigned long offset);
+ unsigned long epld_read(unsigned long offset);
+ void epld_early_init(struct platform_device *device);
+ 
+ void harp_init_irq(void);
+ 
+ struct plat_epld_data {
+ 	int opsize;
+ };
diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/mach.c linux/arch/sh/boards/st/stb7109eref/mach.c
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/mach.c	2008-11-18 20:48:20.000000000 +0100
--- linux/arch/sh/boards/st/stb7109eref/mach.c	2008-11-29 11:39:33.000000000 +0100
***************
*** 21,26 ****
--- 21,28 ----
  #include <asm/led.h>
  #include <asm/machvec_init.h>
  
+ #define ILC_EXT_MDINT           70
+ 
  static void __iomem *stb7109eref_ioport_map(unsigned long port, unsigned int size)
  {
  #ifdef CONFIG_BLK_DEV_ST40IDE
***************
*** 45,54 ****
  
  	/* Set the ILC to route external interrupts to the the INTC */
  	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
- 	ilc_route_external(70, 4, 1);	/* MDINT */
  	ilc_route_external(ILC_EXT_IRQ1, 5, 0);	/* VoIP */
  	ilc_route_external(ILC_EXT_IRQ2, 6, 0);	/* ATA */
! 	ilc_route_external(ILC_EXT_IRQ3, 7, 0);	/* SMC Ethernet */
  
  	make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
  	make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
--- 47,55 ----
  
  	/* Set the ILC to route external interrupts to the the INTC */
  	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
  	ilc_route_external(ILC_EXT_IRQ1, 5, 0);	/* VoIP */
  	ilc_route_external(ILC_EXT_IRQ2, 6, 0);	/* ATA */
! 	ilc_route_external(ILC_EXT_MDINT,7, 0);	/* STE10Xp */
  
  	make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
  	make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/Makefile linux/arch/sh/boards/st/stb7109eref/Makefile
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/Makefile	2008-11-18 20:48:20.000000000 +0100
--- linux/arch/sh/boards/st/stb7109eref/Makefile	2008-11-29 11:39:33.000000000 +0100
***************
*** 1,5 ****
  #
! # Makefile for STMicroelectronics STb7109E Reference board
  #
  
! obj-y := setup.o mach.o
--- 1,5 ----
  #
! # Makefile for TF7700
  #
  
! obj-y := setup.o mach.o epld.o
diff -rcN linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/setup.c linux/arch/sh/boards/st/stb7109eref/setup.c
*** linux-2.6.17.14_stm22_0040_orig_2/arch/sh/boards/st/stb7109eref/setup.c	2008-11-18 20:48:23.000000000 +0100
--- linux/arch/sh/boards/st/stb7109eref/setup.c	2009-01-07 16:16:35.000000000 +0100
***************
*** 1,5 ****
  /*
!  * arch/sh/boards/st/stb7109eref/setup.c
   *
   * Copyright (C) 2005 STMicroelectronics Limited
   * Author: Stuart Menefy (stuart.menefy@st.com)
--- 1,5 ----
  /*
!  * arch/sh/boards/st/stb7109ref/setup.c
   *
   * Copyright (C) 2005 STMicroelectronics Limited
   * Author: Stuart Menefy (stuart.menefy@st.com)
***************
*** 7,13 ****
   * May be copied or modified under the terms of the GNU General Public
   * License.  See linux/COPYING for more information.
   *
!  * STMicroelectronics STb7109E Reference board support.
   */
  
  #include <linux/config.h>
--- 7,15 ----
   * May be copied or modified under the terms of the GNU General Public
   * License.  See linux/COPYING for more information.
   *
!  * STMicroelectronics STb7100 Reference board support.
!  *
!  * The STb7100ref code was adapted to TF7700 mainboard.
   */
  
  #include <linux/config.h>
***************
*** 16,77 ****
  #include <linux/stpio.h>
  #include <linux/st_soc.h>
  #include <linux/delay.h>
  #include <linux/platform_device.h>
  #include <linux/mtd/physmap.h>
  #include <asm/io.h>
  
! #include <linux/stm/710x_fdma.h>
! #include <linux/stm/7109_cut2_fdma2_firmware.h>
! #include <linux/stm/7109_cut3_fdma2_firmware.h>
! 
! #define SYSCONF_BASE 0xb9001000
! #define SYSCONF_DEVICEID	(SYSCONF_BASE + 0x000)
! #define SYSCONF_SYS_STA(n)	(SYSCONF_BASE + 0x008 + ((n) * 4))
! #define SYSCONF_SYS_CFG(n)	(SYSCONF_BASE + 0x100 + ((n) * 4))
! 
! #ifdef CONFIG_STMMAC_ETH
! #define MAC_SPEED_SEL	    0x00100000 /* MAC is running at 100 Mbps speed */
! #define PHY_CLK_EXT	    0x00080000 /* PHY clock is external (RMII mode)*/
! #define MII_MODE	    0x00040000 /* RMII interface activated */
! #define	ETH_IF_ON	    0x00010000 /* ETH interface on */
! #define DVO_ETH_PAD_DISABLE 0x00020000 /* DVO eth pad disable */
! #define STB7109ETH_RESOURCE_NAME	"stb7109eth"
  
! /* ETH MAC pad configuration */
! static void stb7109eth_hw_setup(void)
! {
! 	unsigned long sysconf;
  
! 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
! 	sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
! 
! #ifdef CONFIG_PHY_RMII
! 	sysconf |= MII_MODE; /* RMII selected*/
! #else
! 	sysconf &= ~MII_MODE; /* MII selected */
! #endif
! #ifdef CONFIG_STMMAC_EXT_CLK
!         sysconf |= PHY_CLK_EXT;
! #endif
! 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
  
! 	/* STe101P: enable the external interrupts */
! 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(10));
! 	sysconf |= 0x0000000f;
! 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(10));
! 
!        /* Configure e/net PHY clock */
! #ifndef CONFIG_STMMAC_EXT_CLK
! 	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_ALT_OUT);
! #else
! 	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_IN);
! #endif
  
! 	return;
  }
- #else
- static void stb7109eth_hw_setup(void) { }
- #endif
  
  /*
   * Initialize the board
--- 18,93 ----
  #include <linux/stpio.h>
  #include <linux/st_soc.h>
  #include <linux/delay.h>
+ #include <linux/bpa2.h>
  #include <linux/platform_device.h>
  #include <linux/mtd/physmap.h>
  #include <asm/io.h>
+ #include "../stx710x-common-setup.h"
+ #include "epld.h"
  
! #define ASC2_INTEN ((unsigned int*)(0xb8032010))
! #define ASC3_INTEN ((unsigned int*)(0xb8033010))
! #define ASC3BaseAddress 0xb8033000
! #define ASC_TX_BUFF     0x004
! #define ASC_INT_STA     0x014
! #define ASC_INT_STA_THE   0x04
! 
! 
! /* additional info:
! 
! LMI_SYS:
! 0x04000000-0x07FFFFFF = 64MB RAM for linux
! 
! LMI_VID:
! 0x10000000-0x103FFFFF = 4MB RAM for ST231-0 (video delta)
! 0x10400000-0x107FFFFF = 4MB RAM for ST231-1 (audio delta)
! 0x10800000-0x13FFFFFF = 56MB RAM for allocator
! */
! 
! //FIXME
! 
! const char *LMI_VID_partalias[] = { "BPA2_Region1", "coredisplay-video", "v4l2-video-buffers", "gfx-memory", NULL };
! const char *LMI_SYS_partalias[] = { "BPA2_Region0", "bigphysarea",  NULL };
! 
! static struct bpa2_partition_desc bpa2_parts_table[] = {
!         {
!                 .name  = "LMI_VID",
!                 .start = 0x10800000,
!                 .size  = 0x03800000,
!                 .flags = 0,
!                 .aka   = LMI_VID_partalias
!         },
!         {
!                 .name  = "LMI_SYS",
!                 .start = 0,
!                 .size  = 0x01600000,
!                 .flags = 0,
!                 .aka   = LMI_SYS_partalias
!         }
! };
  
! /* prototypes */
! static void phy_reset(void* bus);
! static void send_fp_byte(unsigned char Data);
! static void system_power_off(void);
  
! static void send_fp_byte(unsigned char Data)
! {
! 	unsigned char *ASC_3_TX_BUFF = (unsigned char*)(ASC3BaseAddress + ASC_TX_BUFF);
! 	unsigned int *ASC_3_INT_STA = (unsigned int*)(ASC3BaseAddress + ASC_INT_STA);
! 	unsigned long Counter = 100000;
  
! 	while (((*ASC_3_INT_STA & ASC_INT_STA_THE) == 0) && --Counter);
! 	*ASC_3_TX_BUFF = Data;
! }
  
! static void system_power_off(void)
! {
! 	send_fp_byte(0x02);
! 	send_fp_byte(0x21);
! 	send_fp_byte(0x01);
! 	send_fp_byte(0x03);
  }
  
  /*
   * Initialize the board
***************
*** 79,126 ****
  void __init platform_setup(void)
  {
  	unsigned long sysconf;
! 	unsigned long chip_revision;
! 	static struct stpio_pin *ethreset;
  
! 	printk("STMicroelectronics STb7109E Reference board initialisation\n");
  
  	sysconf = ctrl_inl(SYSCONF_DEVICEID);
  	chip_revision = (sysconf >> 28) + 1;
- 	printk("STb7109 version %ld.x\n", chip_revision);
  
! 	/* Route UART2 instead of SCI to PIO4 */
! 	/* Set ssc2_mux_sel = 0 */
  	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
- 	sysconf &= ~(1<<3);
- 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
  
! 	/* Permanently enable Flash VPP */
! 	{
! 		static struct stpio_pin *pin;
! 		pin = stpio_request_pin(2,7, "VPP", STPIO_OUT);
! 		stpio_set_pin(pin, 1);
! 	}
  
! 	/* Reset the SMSC 91C111 Ethernet chip */
! 	ethreset = stpio_request_pin(2, 6, "SMSC_RST", STPIO_OUT);
! 	stpio_set_pin(ethreset, 0);
! 	udelay(1);
! 	stpio_set_pin(ethreset, 1);
! 	udelay(1);
! 	stpio_set_pin(ethreset, 0);
  
! 	/* The ST40RTC sources its clock from clock */
! 	/* generator B */
! 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(8));
! 	ctrl_outl(sysconf | 0x2, SYSCONF_SYS_CFG(8));
! 
! 	/* Work around for USB over-current detection chip being
! 	 * active low, and the 7109 being active high */
! 	if (chip_revision < 2) {
! 		static struct stpio_pin *pin;
! 		pin = stpio_request_pin(5,6, "USBOC", STPIO_OUT);
! 		stpio_set_pin(pin, 0);
! 	}
  
  	/* Currently all STB1 chips have problems with the sleep instruction,
  	 * so disable it here.
--- 95,165 ----
  void __init platform_setup(void)
  {
  	unsigned long sysconf;
! 	unsigned long chip_revision, chip_7109;
! 	static struct stpio_pin *usbpower, *pin;
  
! 	printk("Topfield TF7700 initialization\n");
  
  	sysconf = ctrl_inl(SYSCONF_DEVICEID);
+ 	chip_7109 = (((sysconf >> 12) & 0x3ff) == 0x02c);
  	chip_revision = (sysconf >> 28) + 1;
  
! 	if (chip_7109)
! 		printk("STb7109 version %ld.x\n", chip_revision);
! 	else
! 		printk("STb7100 version %ld.x\n", chip_revision);
! 
  	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
  
! 	/* SCIF_PIO_OUT_EN=0 */
! 	/* Route UART2 and PWM to PIO4 instead of SCIF */
! 	sysconf &= ~(1<<0);
  
! 	/* Set SSC2_MUX_SEL = 0 */
! 	/* Treat SSC2 as I2C instead of SSC */
! 	sysconf &= ~(1<<3);
  
! 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
! 
!         /* disable interrupts to prevent a system lockup */
!         printk("disabling ASC IRQ enable flags to prevent a lockup\n");
!         *ASC2_INTEN = *ASC2_INTEN & ~0x000001fe;
!         *ASC3_INTEN = *ASC3_INTEN & ~0x000001fe;
! 
!         /* The Audio DAC (UDA1334ATS) uses GPIO pin 2-4 as an active-high
! 	   mute signal */
!         pin = stpio_request_pin(2, 4, "DACMUTE", STPIO_OUT);
!         stpio_set_pin(pin, 0);
! 
! 	/* reset the PHY */
! 	phy_reset(NULL);
! 
! 	/* assign power-off function */
! 	pm_power_off = system_power_off; 
! 	/*
! 	 * There have been two changes to the USB power enable signal:
! 	 *
! 	 * - 7100 upto and including cut 3.0 and 7109 1.0 generated an
! 	 *   active high enables signal. From 7100 cut 3.1 and 7109 cut 2.0
! 	 *   the signal changed to active low.
! 	 *
! 	 * - The 710x ref board (mb442) has always used power distribution
! 	 *   chips which have active high enables signals (on rev A and B
! 	 *   this was a TI TPS2052, rev C used the ST equivalent a ST2052).
! 	 *   However rev A and B had a pull up on the enables signal, while
! 	 *   rev C changed this to a pull down.
! 	 *
! 	 * The net effect of all this is that the easiest way to drive
! 	 * this signal is ignore the USB hardware and drive it as a PIO
! 	 * pin.
! 	 *
! 	 * (Note the USB over current input on the 710x changed from active
! 	 * high to low at the same cuts, but board revs A and B had a resistor
! 	 * option to select an inverted output from the TPS2052, so no
! 	 * software work around is required.)
! 	 */
! 	usbpower = stpio_request_pin(5,7, "USBPWR", STPIO_OUT);
! 	stpio_set_pin(usbpower, 0);
  
  	/* Currently all STB1 chips have problems with the sleep instruction,
  	 * so disable it here.
***************
*** 129,188 ****
  
  	stb7109eth_hw_setup();
  
! 	/* Configure the pio pins for LIRC */
! 	stpio_request_pin(3, 3, "IR", STPIO_IN);
! 	stpio_request_pin(3, 4, "IR", STPIO_IN);
! 	stpio_request_pin(3, 5, "IR", STPIO_ALT_OUT);
! 	stpio_request_pin(3, 6, "IR", STPIO_ALT_OUT);
  }
  
  const char *get_system_type(void)
  {
! 	return "STb7109E Reference board";
  }
  
  static struct resource ssc_resource[] = {
  	[0] = {
! 	       .start = 0xB8040000,
! 	       .end = 0xB8040000 + 0x108,
! 	       .flags = IORESOURCE_MEM,
! 	      },
  	[1] = {
! 	       .start = 0xB8041000,
! 	       .end = 0xB8041000 + 0x108,
! 	       .flags = IORESOURCE_MEM,
! 	      },
  	[2] = {
! 	       .start = 0xB8042000,
! 	       .end = 0xB8042000 + 0x108,
! 	       .flags = IORESOURCE_MEM,
! 	      },
  	[3] = {
! 	       .start = 119,
! 	       .end = 119,
! 	       .flags = IORESOURCE_IRQ,
! 	      },
  	[4] = {
! 	       .start = 118,
! 	       .end = 118,
! 	       .flags = IORESOURCE_IRQ,
! 	      },
  	[5] = {
! 	       .start = 117,
! 	       .end = 117,
! 	       .flags = IORESOURCE_IRQ,
! 	      },
  };
  
  static struct plat_ssc_pio_t ssc_pio[] = {
  	{2, 0, 2, 1, 0xff, 0xff},
! 	{3, 0, 3, 1, 3, 2},
  	{4, 0, 4, 1, 0xff, 0xff},
  };
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
  		(SSC_I2C_CAPABILITY << (0*2)) |
! 		((SSC_SPI_CAPABILITY | SSC_I2C_CAPABILITY) << (1*2)) |
  		(SSC_I2C_CAPABILITY << (2*2)),
  	.pio         = ssc_pio
  };
--- 168,236 ----
  
  	stb7109eth_hw_setup();
  
! #ifdef CONFIG_STM_PWM
! 	stpio_request_pin(4, 7, "PWM", STPIO_ALT_OUT);
! #endif
! //FIXME
! 	printk("LOAD bpa2_parts_table\n");
!         bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
! 	printk("END bpa2_parts_table\n");
  }
  
  const char *get_system_type(void)
  {
! 	return "Topfield TF77000";
  }
  
+ /* FIXME:
+    TF7700 has only 2 i2c busses on PIO 2 and PIO 3.
+    The i2c-st40-pio.c defines 3 i2c busses by default.
+    Since the third bus does not have any side effects we provide
+    resource for all three busses. */
  static struct resource ssc_resource[] = {
  	[0] = {
! 		.start = 0xB8040000,
! 		.end = 0xB8040000 + 0x108,
! 		.flags = IORESOURCE_MEM,
! 	},
  	[1] = {
! 		.start = 0xB8041000,
! 		.end = 0xB8041000 + 0x108,
! 		.flags = IORESOURCE_MEM,
! 	},
  	[2] = {
! 		.start = 0xB8042000,
! 		.end = 0xB8042000 + 0x108,
! 		.flags = IORESOURCE_MEM,
! 	},
  	[3] = {
! 		.start = 119,
! 		.end = 119,
! 		.flags = IORESOURCE_IRQ,
! 	},
  	[4] = {
! 		.start = 118,
! 		.end = 118,
! 		.flags = IORESOURCE_IRQ,
! 	},
! /*
  	[5] = {
! 		.start = 117,
! 		.end = 117,
! 		.flags = IORESOURCE_IRQ,
! 	},
! */
  };
  
  static struct plat_ssc_pio_t ssc_pio[] = {
  	{2, 0, 2, 1, 0xff, 0xff},
! 	{3, 0, 3, 1, 0xff, 0xff},
  	{4, 0, 4, 1, 0xff, 0xff},
  };
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
  		(SSC_I2C_CAPABILITY << (0*2)) |
! 		(SSC_I2C_CAPABILITY << (1*2)) |
  		(SSC_I2C_CAPABILITY << (2*2)),
  	.pio         = ssc_pio
  };
***************
*** 192,234 ****
  	.num_resources = ARRAY_SIZE(ssc_resource),
  	.resource = ssc_resource,
  	.dev = {
! 		 .platform_data = &ssc_private_info
  	}
  };
- static struct plat_lirc_data lirc_private_info = {
- 	/* For the 7100, the clock settings will be calculated by the driver
- 	 * from the system clock
- 	 */
- 	.irbclock	= 0, /* use current_cpu data */
- 	.irbclkdiv	= 0, /* automatically calculate */
- 	.irbperiodmult	= 0,
- 	.irbperioddiv	= 0,
- 	.irbontimemult	= 0,
- 	.irbontimediv	= 0,
- 	.irbrxmaxperiod = 0x5000,
- 	.irbversion	= 2,
- 	.sysclkdiv	= 2,
- 	.rxpolarity	= 1
- };
- 
- static struct resource smc91x_resources[] = {
- 	[0] = {
- 		.start	= 0xa2000300,
- 		.end	= 0xa2000300 + 0xff,
- 		.flags	= IORESOURCE_MEM,
- 	},
- 	[1] = {
- 		.start	= IRL3_IRQ,
- 		.end	= IRL3_IRQ,
- 		.flags	= IORESOURCE_IRQ,
- 	},
- };
  
  static struct resource st40_ohci_resources[] = {
  	/*this lot for the ohci block*/
  	[0] = {
  		.start = 0xb9100000 + 0xffc00,
! 		.end  =	 0xb9100000 +0xffcff,
  		.flags = IORESOURCE_MEM,
  	},
  	[1] = {
--- 240,254 ----
  	.num_resources = ARRAY_SIZE(ssc_resource),
  	.resource = ssc_resource,
  	.dev = {
! 		.platform_data = &ssc_private_info
  	}
  };
  
  static struct resource st40_ohci_resources[] = {
  	/*this lot for the ohci block*/
  	[0] = {
  		.start = 0xb9100000 + 0xffc00,
! 		.end  =  0xb9100000 +0xffcff,
  		.flags = IORESOURCE_MEM,
  	},
  	[1] = {
***************
*** 237,242 ****
--- 257,263 ----
  			.flags = IORESOURCE_IRQ,
  	}
  };
+ 
  static struct resource st40_ehci_resources[] = {
  	/*now this for the ehci*/
  	[0] =  {
***************
*** 255,264 ****
  static struct resource wdt_resource[] = {
  	/* Watchdog timer only needs a register address */
  	[0] = {
! 	       .start = 0xFFC00008,
! 	       .end = 0xFFC00010,
! 	       .flags = IORESOURCE_MEM,
! 	      }
  };
  
  struct platform_device wdt_device = {
--- 276,285 ----
  static struct resource wdt_resource[] = {
  	/* Watchdog timer only needs a register address */
  	[0] = {
! 		.start = 0xFFC00008,
! 		.end = 0xFFC00010,
! 		.flags = IORESOURCE_MEM,
! 	}
  };
  
  struct platform_device wdt_device = {
***************
*** 268,289 ****
  	.resource = wdt_resource,
  };
  
- 
- static struct resource lirc_resource[]= {
- 	/* This is the main LIRC register block, as defined by the spec */
-        [0] = {
- 		.start = 0x18018000,
- 		.end   = 0x18018000 + 0xa0,
- 		.flags = IORESOURCE_MEM
- 	},
- 	/* The LIRC block has one interrupt */
- 	[1] = {
- 		.start = 125,
- 		.end   = 125,
- 		.flags = IORESOURCE_IRQ
- 	},
- };
- 
  static u64 st40_dma_mask = 0xfffffff;
  
  static struct platform_device  st40_ohci_devices = {
--- 289,294 ----
***************
*** 292,297 ****
--- 297,303 ----
  	.dev = {
  		.dma_mask = &st40_dma_mask,
  		.coherent_dma_mask = 0xffffffful,
+ 		.platform_data = &usb_wrapper,
  	},
  	.num_resources = ARRAY_SIZE(st40_ohci_resources),
  	.resource = st40_ohci_resources,
***************
*** 303,326 ****
  	.dev = {
  		.dma_mask = &st40_dma_mask,
  		.coherent_dma_mask = 0xffffffful,
  	},
  	.num_resources = ARRAY_SIZE(st40_ehci_resources),
  	.resource = st40_ehci_resources,
  };
  
! static struct platform_device smc91x_device = {
! 	.name		= "smc91x",
! 	.id		= 0,
! 	.num_resources	= ARRAY_SIZE(smc91x_resources),
! 	.resource	= smc91x_resources,
! };
  
  static struct plat_stmmacenet_data eth7109_private_data = {
  	.bus_id = 0,
! 	.phy_addr = 14,
! 	.phy_mask = 1,
  	.phy_name = "ste100p",
! 	.pbl = 1,
  };
  
  static struct platform_device stb7109eth_device = {
--- 309,345 ----
  	.dev = {
  		.dma_mask = &st40_dma_mask,
  		.coherent_dma_mask = 0xffffffful,
+ 		.platform_data = &usb_wrapper,
  	},
  	.num_resources = ARRAY_SIZE(st40_ehci_resources),
  	.resource = st40_ehci_resources,
  };
  
! static void phy_reset(void* bus)
! {
! 	static struct stpio_pin *phyreset;
! 
!         printk ("Resetting the network PHY\n");
! 
! 	if (phyreset == NULL) {
! 		phyreset = stpio_request_pin(5, 3, "Phy reset", STPIO_OUT);
! 	}
! 
! 	stpio_set_pin(phyreset, 1);
! 	udelay(1);
! 	stpio_set_pin(phyreset, 0);
! 	udelay(1000);
! 	stpio_set_pin(phyreset, 1);
! }
  
  static struct plat_stmmacenet_data eth7109_private_data = {
  	.bus_id = 0,
! 	.phy_addr = 0,
! 	.phy_mask = 0,
  	.phy_name = "ste100p",
! 	//.pbl = 1,
! 	.fix_mac_speed = fix_mac_speed,
! 	//.phy_reset = phy_reset,
  };
  
  static struct platform_device stb7109eth_device = {
***************
*** 351,385 ****
  	}
  };
  
- 
- static struct resource ste101p_resources[] = {
-         [0] = {
-                 .flags  = IORESOURCE_DISABLED,
-         },
-         [1] = {
-                 .start  = IRL0_IRQ,
-                 .end    = IRL0_IRQ,
-                 .flags  = IORESOURCE_IRQ,
-         },
- };
- 
- static struct platform_device ste101p_device = {
-         .name           = "ste101p",
-         .id             = 0,
-         .num_resources  = ARRAY_SIZE(ste101p_resources),
-         .resource       = ste101p_resources,
- };
- 
- static struct platform_device lirc_device = {
- 	.name		= "lirc",
- 	.id		= -1,
- 	.num_resources	= ARRAY_SIZE(lirc_resource),
- 	.resource	= lirc_resource,
- 	.dev = {
- 		   .platform_data = &lirc_private_info
- 	}
- };
- 
  static struct resource sata_resource[]= {
  	[0] = {
  		.start = 0x18000000 + 0x01209000,
--- 370,375 ----
***************
*** 406,460 ****
  	}
  };
  
! static struct resource rtc_resource[]= {
  	[0] = {
! 		.start = 0xffc80000,
! 		.end   = 0xffc80000 + 0x40,
! 		.flags = IORESOURCE_MEM
  	},
- /* Be careful the
-  * arch/sh/kernel/cpu/irq_ipr.c
-  * must be update with the right value
-  */
  	[1] = {
! 		.start = 20,/* Alarm IRQ   */
! 		.flags = IORESOURCE_IRQ
! 	},
! 	[2] = {
! 		.start = 21,/* Periodic IRQ*/
! 		.flags = IORESOURCE_IRQ
! 	},
  };
! static struct platform_device rtc_device = {
! 	.name		= "rtc",
  	.id		= -1,
! 	.num_resources	= ARRAY_SIZE(rtc_resource),
! 	.resource	= rtc_resource,
  };
  
! #ifdef CONFIG_MTD_PHYSMAP
! static struct mtd_partition mtd_parts_table[3] = {
  	{
! 	 .name = "Boot firmware",
! 	 .size = 0x00040000,
  	 .offset = 0x00000000,
  	 },
  	{
  	 .name = "Kernel",
! 	 .size = 0x00100000,
! 	 .offset = 0x00040000,
! 
  	 },
  	{
  	 .name = "Root FS",
! 	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
! 	 .offset = 0x00140000,
  	 }
  };
  
  static struct physmap_flash_data physmap_flash_data = {
  	.width		= 2,
! 	.set_vpp	= NULL,
  	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
  	.parts		= mtd_parts_table
  };
--- 396,474 ----
  	}
  };
  
! static struct resource stm_pwm_resource[]= {
  	[0] = {
! 		.start	= 0x18010000,
! 		.end	= 0x18010000 + 0x67,
! 		.flags	= IORESOURCE_MEM
  	},
  	[1] = {
! 		.start	= 126,
! 		.flags	= IORESOURCE_IRQ
! 	}
  };
! 
! static struct plat_stm_pwm_data pwm_private_info = {
! 	.flags		= PLAT_STM_PWM_OUT1,
! };
! 
! static struct platform_device stm_pwm_device = {
! 	.name		= "stm-pwm",
  	.id		= -1,
! 	.num_resources	= ARRAY_SIZE(stm_pwm_resource),
! 	.resource	= stm_pwm_resource,
! 	.dev = {
! 		.platform_data = &pwm_private_info,
! 	}
  };
  
! #ifdef CONFIG_MTD_PARTITIONS
! static struct mtd_partition mtd_parts_table[] = {
  	{
! 	 .name = "Boot loader",
! 	 .size = 0x00030000,
  	 .offset = 0x00000000,
+ 	 .mask_flags = MTD_WRITEABLE
+ 	 },
+ 	{
+ 	 .name = "U-Boot",
+ 	 .size = 0x00020000,
+ 	 .offset = MTDPART_OFS_NXTBLK,
+ 	 .mask_flags = MTD_WRITEABLE
+ 	 },
+ 	{
+ 	 .name = "U-Boot settings",
+ 	 .size = 0x00010000,
+ 	 .offset = MTDPART_OFS_NXTBLK,
  	 },
  	{
  	 .name = "Kernel",
! 	 .size = 0x00010000,
! 	 .offset = MTDPART_OFS_NXTBLK
  	 },
  	{
  	 .name = "Root FS",
! 	 .size = MTDPART_SIZ_FULL,
! 	 .offset = MTDPART_OFS_NXTBLK
  	 }
  };
  
+ static void mtd_set_vpp(struct map_info *map, int vpp)
+ {
+         /* Bit 0: VPP enable
+          * Bit 1: Reset (not used in later EPLD versions)
+          */
+ 
+         if (vpp) {
+                 epld_write(3, EPLD_FLASH);
+         } else {
+                 epld_write(2, EPLD_FLASH);
+         }
+ }
+ 
  static struct physmap_flash_data physmap_flash_data = {
  	.width		= 2,
! 	.set_vpp	= mtd_set_vpp,
  	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
  	.parts		= mtd_parts_table
  };
***************
*** 473,732 ****
  	.name		= "physmap-flash",
  	.id		= -1,
  	.dev		= {
! 		.platform_data	= physmap_flash_data_addr,
  	},
  	.num_resources	= 1,
  	.resource	= &physmap_flash_resource,
  };
- /*
- Re							RnW,    Opcode,  Transfer Incr addr,   Hold_off Initiator), */
- /*        						1-32   	cnt 1-4  On/Off       0-2        Used) */
- static  fdmareq_RequestConfig_t stb7109_fdma_req_config[]= {
- /*=========================== 7109 ============================================*/
- 
- /*  {  Req  RnW, 						Opcode,    TransferCount  Inc,       Hold_off        Initiator), */
- /*  {               						1-32       1-4            On/Off       0-2           Used) */
- /*0*/	{STB7109_FDMA_REQ_UNUSED,			UNUSED, UNUSED,    1,     	  UNUSED,      0,     	     1 },/* NOT CONNECTED */
- /*1*/	{STB7109_FDMA_DMA_REQ_HDMI_AVI,			READ,   OPCODE_8,  1,             DISABLE_FLG, 0,            1 },  /* Video HDMI */
- /*2*/	{STB7109_FDMA_REQ_DISEQC_HALF_EMPTY,		WRITE,  OPCODE_4,  2,             DISABLE_FLG, 0,            1 },  /* DiseqC half empty */
- /*3*/	{STB7109_FDMA_REQ_DISEQC_HALF_FULL,		READ,   OPCODE_4,  2,             DISABLE_FLG, 0,            1 },  /* DiseqC half full */
- /*4*/	{STB7109_FDMA_REQ_SH4_SCIF_RX,			READ,   OPCODE_4,  2,             DISABLE_FLG, 0,            1 },  /* SH4/SCIF */
- /*5*/	{STB7109_FDMA_REQ_SH4_SCIF_TX,			WRITE,  OPCODE_4,  2,             DISABLE_FLG, 0,            1 },  /* SH4/SCIF */
- /*6*/	{STB7109_FDMA_REQ_SSC_0_RX,			READ,   OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 0 rxbuff full */
- /*7*/	{STB7109_FDMA_REQ_SSC_1_RX,			READ,   OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 1 rxbuff full */
- /*8*/	{STB7109_FDMA_REQ_SSC_2_RX,			READ,   OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 2 rxbuff full */
- /*9*/	{STB7109_FDMA_REQ_SSC_0_TX,			WRITE,  OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 0 txbuff empty */
- /*10*/	{STB7109_FDMA_REQ_SSC_1_TX,			WRITE,  OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 1 txbuff empty */
- /*11*/	{STB7109_FDMA_REQ_SSC_2_TX,			WRITE,  OPCODE_2,  4,             DISABLE_FLG, 0,            1 },  /* SSC 1 txbuff empty */
- /*12*/  {STB7109_FDMA_REQ_UART_0_RX,			READ,   OPCODE_1,  4,             DISABLE_FLG, 0,            1 },  /* UART 0 rx half full */
- /*13*/	{STB7109_FDMA_REQ_UART_1_RX,			READ,   OPCODE_1,  4,             DISABLE_FLG, 0,            1 },  /* UART 1 rx half full */
- /*14*/	{STB7109_FDMA_REQ_UART_2_RX,			READ,   OPCODE_1,  4,             DISABLE_FLG, 0,            1 },  /* UART 2 rx half full */
- /*15*/	{STB7109_FDMA_REQ_UART_3_RX,			READ,   OPCODE_1,  4,             DISABLE_FLG, 0,            1 },  /* UART 3 rx half full */
- /*16*/	{STB7109_FDMA_REQ_UART_0_TX,			WRITE,  OPCODE_1,  1,             DISABLE_FLG, 0,            1 },  /* UART 0 tx half empty */
- /*17*/	{STB7109_FDMA_REQ_UART_1_TX,			WRITE,  OPCODE_1,  1,             DISABLE_FLG, 0,            1 },  /* UART 1 tx half empty */
- /*18*/	{STB7109_FDMA_REQ_UART_2_TX,			WRITE,  OPCODE_1,  1,             DISABLE_FLG, 0,            1 },  /* UART 2 tx half emtpy */
- /*19*/	{STB7109_FDMA_REQ_UART_3_TX,			WRITE,  OPCODE_1,  1,             DISABLE_FLG, 0,            1 },  /* UART 3 tx half empty */
- /*20*/	{STB7109_FDMA_REQ_REQ_EXT_PIO_0,		READ,   OPCODE_4,  1,             DISABLE_FLG, 0,            1 },  /* External 0 (PIO2bit5) hi priority */
- /*21*/	{STB7109_FDMA_REQ_REQ_EXT_PIO_1,		READ,   OPCODE_4,  1,             DISABLE_FLG, 0,            1 },  /* External 1 (PIO2bit6) hi priority */
- /*22*/	{STB7109_FDMA_REQ_CPXM_DECRYPT,  	     	READ,   OPCODE_4,  4,             DISABLE_FLG, 0,            1 },  /* CPxM decrypted data request */
- /*23*/  {STB7109_FDMA_REQ_CPXM_ENCRYPT,  	     	WRITE,  OPCODE_4,  4,             DISABLE_FLG, 0,            1 },  /* CPxm encrypted data request */
- /*24*/	{STB7109_FDMA_REQ_PCM_0,			WRITE,  OPCODE_4,  1,             DISABLE_FLG, 0,            0 },  /* Audio PCM Player 0 */
- /*25*/	{STB7109_FDMA_REQ_PCM_1,			WRITE,  OPCODE_4,  1,             DISABLE_FLG, 0,            0 },  /* Audio PCM Player 1 */
- /*26*/	{STB7109_FDMA_REQ_PCM_READ,			READ,   OPCODE_4,  1,             DISABLE_FLG, 0,            0 },  /* Audio PCM Reader */
- /*27*/	{STB7109_FDMA_REQ_SPDIF,			WRITE,  OPCODE_4,  1,             DISABLE_FLG, 0,            0 },  /* Audio SPDIF - 2xST4*/
- /*29*/	{STB7109_FDMA_REQ_SWTS_0,			WRITE,  OPCODE_32, 1,             DISABLE_FLG, 0,            0 },  /* SWTS 0 */
- /*29*/	{STB7109_FDMA_REQ_SWTS_1,			WRITE,  OPCODE_32, 1,             DISABLE_FLG, 0,            0 },  /* SWTS 1 */
- /*30*/	{STB7109_FDMA_REQ_SWTS_2,			WRITE,  OPCODE_32, 1,             DISABLE_FLG, 0,            0 },  /* SWTS 2 */
- /*31*/  {STB7109_FDMA_REQ_UNUSED,           		UNUSED, UNUSED,    1,             UNUSED,      0,            0 },  /* Reserved */
- };
- 
- static fdma_regs_t stb7109_fdma_regs = {
- 	.fdma_id= FDMA2_ID,
- 	.fdma_ver = FDAM2_VER,
- 	.fdma_en = FDMA2_ENABLE_REG,
- 	.fdma_clk_gate = FDMA2_CLOCKGATE,
- 	.fdma_rev_id = FDMA2_REV_ID,
- 	.fdma_cmd_statn = STB7109_FDMA_CMD_STATn_REG,
- 	.fdma_ptrn = STB7109_FDMA_PTR_REG,
- 	.fdma_cntn = STB7109_FDMA_COUNT_REG,
- 	.fdma_saddrn = STB7109_FDMA_SADDR_REG,
- 	.fdma_daddrn = STB7109_FDMA_DADDR_REG,
- 	.fdma_req_ctln = STB7109_FDMA_REQ_CTLn_REG,
- 	.fdma_cmd_sta = FDMA2_CMD_MBOX_STAT_REG,
- 	.fdma_cmd_set = FDMA2_CMD_MBOX_SET_REG,
- 	.fdma_cmd_clr = FDMA2_CMD_MBOX_CLR_REG,
- 	.fdma_cmd_mask = FDMA2_CMD_MBOX_MASK_REG,
- 	.fdma_int_sta = FDMA2_INT_STAT_REG,
- 	.fdma_int_set = FDMA2_INT_SET_REG,
- 	.fdma_int_clr= FDMA2_INT_CLR_REG,
- 	.fdma_int_mask= FDMA2_INT_MASK_REG,
- 	.fdma_sync_reg= FDMA2_SYNCREG,
- 	.fdma_dmem_region = STB7109_DMEM_OFFSET,
- 	.fdma_imem_region = STB7109_IMEM_OFFSET,
- };
- 
- static struct fdma_platform_device_data stb7109_C1_fdma_plat_data ={
- 	.cpu_subtype = 7109,
- 	.cpu_rev = 1,
- };
- 
- static struct fdma_platform_device_data stb7109_C2_fdma_plat_data = {
- 	.req_line_tbl_adr = (void*)&stb7109_fdma_req_config,
- 	.registers_ptr =(void*) &stb7109_fdma_regs,
- 	.cpu_subtype = 7109,
- 	.cpu_rev = 2,
- 	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
- 	.max_ch_num  =CONFIG_MAX_STM_DMA_CHANNEL_NR,
- 	.fdma_base  = STB7109_FDMA_BASE,
- 	.irq_vect = LINUX_FDMA_STB7109_IRQ_VECT,
- 	.fw_device_name = "STB7109_fdma_fw",
- 	.nr_reqlines = (sizeof(stb7109_fdma_req_config) / sizeof(fdmareq_RequestConfig_t)),
- 	.fw.data_reg = (unsigned long*)&STB7109_C2_DMEM_REGION,
- 	.fw.imem_reg = (unsigned long*)&STB7109_C2_IMEM_REGION,
- 	.fw.imem_fw_sz = STB7109_C2_IMEM_FIRMWARE_SZ,
- 	.fw.dmem_fw_sz = STB7109_C2_DMEM_FIRMWARE_SZ,
- 	.fw.dmem_len = STB7109_C2_DMEM_REGION_LENGTH,
- 	.fw.imem_len = STB7109_C2_IMEM_REGION_LENGTH
- };
- 
- static struct fdma_platform_device_data stb7109_C3_fdma_plat_data = {
- 	.req_line_tbl_adr = (void*)&stb7109_fdma_req_config,
- 	.registers_ptr =(void*) &stb7109_fdma_regs,
- 	.cpu_subtype = 7109,
- 	.cpu_rev = 3,
- 	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
- 	.max_ch_num  =CONFIG_MAX_STM_DMA_CHANNEL_NR,
- 	.fdma_base  = STB7109_FDMA_BASE,
- 	.irq_vect = LINUX_FDMA_STB7109_IRQ_VECT,
- 	.fw_device_name = "STB7109_C3_fdma_fw",
- 	.nr_reqlines = (sizeof(stb7109_fdma_req_config) / sizeof(fdmareq_RequestConfig_t)),
- 	.fw.data_reg = (unsigned long*)&STB7109_C3_DMEM_REGION,
- 	.fw.imem_reg = (unsigned long*)&STB7109_C3_IMEM_REGION,
- 	.fw.imem_fw_sz = STB7109_C3_IMEM_FIRMWARE_SZ,
- 	.fw.dmem_fw_sz = STB7109_C3_DMEM_FIRMWARE_SZ,
- 	.fw.dmem_len = STB7109_C3_DMEM_REGION_LENGTH,
- 	.fw.imem_len = STB7109_C3_IMEM_REGION_LENGTH
- 
- };
  
! static struct platform_device fdma_710x_device = {
!         .name           = "710x_FDMA",
          .id             = -1,
  };
  
! static struct resource alsa_710x_resource_pcm0[3] = {
! 
! 	[0] = {/* allocatable channels*/
! 		.start =2,
! 		.end   = 10,
! 		.flags 	= IORESOURCE_IRQ
! 	},
! 	[1]= {/*fdma reqline*/
! 		.start = STB7109_FDMA_REQ_PCM_0,
! 		.end   = STB7109_FDMA_REQ_PCM_0,
! 		.flags = IORESOURCE_IRQ
! 	},
! 	[2] = {/*rising or falling edge I2s clocking*/
! 		 /*.start = runtime dependant*/
! 		 /*.end = runtime dependant*/
! 		.flags = IORESOURCE_IRQ
! 	}};
! 
! 
! static struct resource alsa_710x_resource_pcm1[3] = {
! 
! 	[0] = {/* allocatable channels*/
! 		.start = 2,
! 		.end   = 2,
! 		.flags 	= IORESOURCE_IRQ,
! 	},
! 	[1]= {/*fdma reqline*/
! 		.start =STB7109_FDMA_REQ_PCM_1,
! 		.end   =STB7109_FDMA_REQ_PCM_1,
! 		.flags = IORESOURCE_IRQ,
! 	},
! 	[2] = {/*rising or falling edge I2s clocking
! 		1 == FALLING_EDGE
! 		0 == RISING EDGE */
! 		 /*.start = runtime dependant*/
! 		 /*.end = runtime dependant*/
! 		.flags = IORESOURCE_IRQ
! 	}};
! 
! static struct resource alsa_710x_resource_spdif[2] = {
! 
! 	[0] = {/*min allocatable channels*/
! 		.start = 2,
! 		.end   =2,
! 		.flags = IORESOURCE_IRQ
! 	},
! 	[1] = {/*fdma reqline*/
! 		.start =STB7109_FDMA_REQ_SPDIF,
! 		.end   = STB7109_FDMA_REQ_SPDIF,
! 		.flags = IORESOURCE_IRQ
! 	}};
! 
! static struct resource alsa_710x_resource_cnv[2] = {
! 
! 	[0] = {/*min allocatable channels*/
! 		.start = 2,
! 		.end   =10,
! 		.flags = IORESOURCE_IRQ,
! 	},
! 	[1] = {/*fdma reqline*/
! 		.start = STB7109_FDMA_REQ_PCM_0,
! 		.end   = STB7109_FDMA_REQ_PCM_0,
! 		.flags = IORESOURCE_IRQ,
! 	}};
! 
! static struct resource alsa_710x_resource_pcmin[3] = {
! 
! 	[0] = {/*min allocatable channels*/
! 		.start = 0,
! 		.end   = 0,
! 		.flags = IORESOURCE_IRQ,
! 	},
! 	[1] = {/*fdma reqline*/
! 		/*.start = runtime dependant*/
! 		/*.end   = runtime dependant*/
! 		.flags = IORESOURCE_IRQ,
! 	},
! 	[2] = {/*fdma reqline*/
! 		/*.start = runtime dependant*/
! 		/*.end   = runtime dependant*/
! 		.flags = IORESOURCE_IRQ,
! 	}};
! 
! 
! static struct platform_device alsa_710x_device_pcmin = {
! 	.name			= "710x_ALSA_PCMIN",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_pcmin),
! 	.resource		= alsa_710x_resource_pcmin,
! };
! 
! static struct platform_device alsa_710x_device_pcm0 = {
! 	.name			= "710x_ALSA_PCM0",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_pcm0),
! 	.resource		= alsa_710x_resource_pcm0,
! };
! 
! 
! static struct platform_device alsa_710x_device_pcm1 = {
! 	.name			= "710x_ALSA_PCM1",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_pcm1),
! 	.resource		= alsa_710x_resource_pcm1,
! };
! 
! static struct platform_device alsa_710x_device_spdif = {
! 	.name			= "710x_ALSA_SPD",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_spdif),
! 	.resource		= alsa_710x_resource_spdif,
! };
! 
! static struct platform_device alsa_710x_device_cnv = {
! 	.name			= "710x_ALSA_CNV",
! 	.id 			= -1,
! 	.num_resources	= 	ARRAY_SIZE(alsa_710x_resource_cnv),
! 	.resource		= alsa_710x_resource_cnv,
  };
  
! 
! 
! static struct platform_device *stb7109eref_devices[] __initdata = {
! 	&smc91x_device,
  	&stb7109eth_device,
- 	&ste101p_device,
  	&st40_ohci_devices,
  	&st40_ehci_devices,
! 	&lirc_device,
  	&sata_device,
  	&wdt_device,
  	&ssc_device,
! 	&rtc_device,
  	&physmap_flash,
  	&fdma_710x_device,
  	&alsa_710x_device_pcm0,
--- 488,533 ----
  	.name		= "physmap-flash",
  	.id		= -1,
  	.dev		= {
! 	.platform_data	= physmap_flash_data_addr,
  	},
  	.num_resources	= 1,
  	.resource	= &physmap_flash_resource,
  };
  
! static struct platform_device epld_device = {
!         .name           = "epld",
          .id             = -1,
+         .num_resources  = 1,
+         .resource       = (struct resource[]) {
+                 {
+                         .start  = EPLD_BASE,
+                         .end    = EPLD_BASE + EPLD_SIZE - 1,
+                         .flags  = IORESOURCE_MEM,
+                 }
+         },
+         .dev.platform_data = &(struct plat_epld_data) {
+                  .opsize = 8,
+         },
  };
  
! static struct platform_device boxtype_device = {
!         .name = "boxtype",
!         .dev.platform_data = (void*)100
  };
  
! static struct platform_device *tf7700_devices[] __initdata = {
! 	&epld_device,
! 	&boxtype_device,
! 	//&smc91x_device,
  	&stb7109eth_device,
  	&st40_ohci_devices,
  	&st40_ehci_devices,
! 	//&lirc_device,
  	&sata_device,
  	&wdt_device,
  	&ssc_device,
! 	//&rtc_device,
! 	&stm_pwm_device,
  	&physmap_flash,
  	&fdma_710x_device,
  	&alsa_710x_device_pcm0,
***************
*** 740,825 ****
  {
  	int ret =0;
  	unsigned long devid;
! 	unsigned long chip_revision;
  
  	devid = ctrl_inl(SYSCONF_DEVICEID);
  	chip_revision = (devid >> 28) + 1;
  
! 	sata_private_info.phy_init = 0x388FC;
  
! 	if (chip_revision == 1) {
! 		/* 7109 cut 1.x */
  		sata_private_info.only_32bit = 1;
  		sata_private_info.pc_glue_logic_init = 0x1ff;
  	} else {
- 		/* 7109 cut >= 2.0 */
  		sata_private_info.only_32bit = 0;
  		sata_private_info.pc_glue_logic_init = 0x100ff;
  	}
- 	switch (chip_revision) {
- 	case 1:
- 		alsa_710x_resource_pcm0[2].start =0;
- 		alsa_710x_resource_pcm0[2].end = 0;
- 
- 		alsa_710x_resource_pcm0[2].start =0;
- 		alsa_710x_resource_pcm0[2].end = 0;
- 
- 		alsa_710x_resource_pcmin[2].start = 1;
- 		alsa_710x_resource_pcmin[2].end =   1;
- 
- 		fdma_710x_device.dev.platform_data = (void*)&stb7109_C1_fdma_plat_data;
- 		break;
- 	case 2:
- 		alsa_710x_resource_pcm0[2].start =0;
- 		alsa_710x_resource_pcm0[2].end = 0;
  
! 		alsa_710x_resource_pcm0[2].start =0;
! 		alsa_710x_resource_pcm0[2].end = 0;
! 
! 		alsa_710x_resource_pcmin[2].start = 0;
! 		alsa_710x_resource_pcmin[2].end =   0;
! 		fdma_710x_device.dev.platform_data =(void*) &stb7109_C2_fdma_plat_data;
! 		break;
! 	default:
! 		/* 7109 cut >= 3.0 */
! 		BUG_ON(chip_revision < 2);
! 		alsa_710x_resource_pcm0[2].start =1;
! 		alsa_710x_resource_pcm0[2].end = 1;
! 
! 		alsa_710x_resource_pcm0[2].start =1;
! 		alsa_710x_resource_pcm0[2].end = 1;
! 
! 		alsa_710x_resource_pcmin[2].start = 0;
! 		alsa_710x_resource_pcmin[2].end =   0;
! 
! 		fdma_710x_device.dev.platform_data =(void*) &stb7109_C3_fdma_plat_data;
! 		break;
  	}
  
! 	alsa_710x_resource_pcm0[0].start = 2;
! 	alsa_710x_resource_pcm0[0].end = 10;
! 
! 	alsa_710x_resource_pcm1[0].start = 2;
! 	alsa_710x_resource_pcm1[0].end 	= 2;
! 
! 	alsa_710x_resource_pcm0[1].start = STB7109_FDMA_REQ_PCM_0;
! 	alsa_710x_resource_pcm0[1].end = STB7109_FDMA_REQ_PCM_0;
! 
! 	alsa_710x_resource_pcm1[1].start = STB7109_FDMA_REQ_PCM_1;
! 	alsa_710x_resource_pcm1[1].end = STB7109_FDMA_REQ_PCM_1;
! 
! 	alsa_710x_resource_spdif[1].start = STB7109_FDMA_REQ_SPDIF;
! 	alsa_710x_resource_spdif[1].end =   STB7109_FDMA_REQ_SPDIF;
! 
! 	alsa_710x_resource_cnv[0].start =10;
! 	alsa_710x_resource_cnv[0].end = 10;
! 	alsa_710x_resource_cnv[1].start = STB7109_FDMA_REQ_PCM_0;
! 	alsa_710x_resource_cnv[1].end = STB7109_FDMA_REQ_PCM_0;
! 
! 	alsa_710x_resource_pcmin[1].start = STB7109_FDMA_REQ_PCM_READ;
! 	alsa_710x_resource_pcmin[1].end =   STB7109_FDMA_REQ_PCM_READ;
  
! 	ret = platform_add_devices(stb7109eref_devices, ARRAY_SIZE(stb7109eref_devices));
  	return ret;
  }
  
--- 541,577 ----
  {
  	int ret =0;
  	unsigned long devid;
! 	unsigned long chip_revision, chip_7109;
  
  	devid = ctrl_inl(SYSCONF_DEVICEID);
+ 	chip_7109 = (((devid >> 12) & 0x3ff) == 0x02c);
  	chip_revision = (devid >> 28) + 1;
  
! 	if ((! chip_7109) && (chip_revision == 1)) {
! 		/* 7100 cut 1.x */
! 		sata_private_info.phy_init = 0x0013704A;
! 	} else {
! 		/* 7100 cut 2.x and cut 3.x and 7109 */
! 		sata_private_info.phy_init = 0x388fc;
! 	}
  
! 	if ((! chip_7109) || (chip_7109 && (chip_revision == 1))) {
  		sata_private_info.only_32bit = 1;
  		sata_private_info.pc_glue_logic_init = 0x1ff;
  	} else {
  		sata_private_info.only_32bit = 0;
  		sata_private_info.pc_glue_logic_init = 0x100ff;
  	}
  
! 	/* Configure the ethernet MAC PBL depending on the cut of the chip */
! 	if (chip_7109){
! 		eth7109_private_data.pbl = 1;
  	}
  
! 	fdma_setup(chip_7109, chip_revision);
! 	alsa_setup(chip_7109, chip_revision);
  
! 	ret = platform_add_devices(tf7700_devices, ARRAY_SIZE(tf7700_devices));
  	return ret;
  }
  
diff -rcN linux/drivers/mtd/maps_/Makefile linux/drivers/mtd/maps/Makefile
*** linux/drivers/mtd/maps_/Makefile	2009-01-11 00:34:07.000000000 +0100
--- linux/drivers/mtd/maps/Makefile	2009-01-10 23:28:40.000000000 +0100
***************
*** 74,76 ****
--- 74,77 ----
  obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
  obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
  obj-$(CONFIG_MTD_STBOARDS)	+= stboards.o
+ obj-$(if $(TF7700),y)		+= tf7700.o
diff -rcN linux/drivers/mtd/maps_/tf7700.c linux/drivers/mtd/maps/tf7700.c
*** linux/drivers/mtd/maps_/tf7700.c	1970-01-01 01:00:00.000000000 +0100
--- linux/drivers/mtd/maps/tf7700.c	2009-01-11 00:35:18.000000000 +0100
***************
*** 0 ****
--- 1,139 ----
+ #include <linux/module.h>
+ #include <linux/types.h>
+ #include <linux/kernel.h>
+ #include <linux/init.h>
+ #include <asm/io.h>
+ #include <asm/errno.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/map.h>
+ #include <linux/mtd/partitions.h>
+ 
+ #define EPLD_FLASH 0x400000
+ #define FLASH_ADDR 0x00000000
+ #define FLASH_SIZE (8*1024*1024)
+ #define FLASH_BANKWIDTH 2
+ 
+ extern void epld_write(unsigned long value, unsigned long offset);
+ 
+ static void mtd_set_vpp(struct map_info *map, int vpp)
+ {
+ 	if (vpp)
+ 	{
+ 		epld_write(3, EPLD_FLASH);
+ 	}
+ 	else
+ 	{
+ 		epld_write(2, EPLD_FLASH);
+ 	}
+ }
+ 
+ static struct mtd_info *flash_mtd;
+ 
+ static struct map_info flash_map = {
+ 	.name = "Flash",
+ 	.size = FLASH_SIZE,
+ 	.bankwidth = FLASH_BANKWIDTH,
+ 	.set_vpp = mtd_set_vpp,
+ };
+ 
+ static struct mtd_partition flash_partitions[] = {
+ 	{
+ 	 .name = "TF Boot Loader",
+ 	 .size = 0x00030000,
+ 	 .offset = 0x00000000,
+ 	 .mask_flags = MTD_WRITEABLE
+ 	 },
+ 	{ 
+ 	 .name = "U-Boot",
+ 	 .size = 0x00020000,
+ 	 .offset = MTDPART_OFS_NXTBLK,
+ 	 },
+ 	{ 
+ 	 .name = "U-Boot Settings",
+ 	 .size = 0x00010000,
+ 	 .offset = MTDPART_OFS_NXTBLK,
+ 	 },
+ 	{
+ 	 .name = "TF Kernel",
+ 	 .size = 0x00200000, 
+ 	 .offset = MTDPART_OFS_NXTBLK,
+ 	 }, 
+ 	{ 
+ 	 .name = "Root FS (unused)",
+ 	 .size = MTDPART_SIZ_FULL,
+ 	 .offset = MTDPART_OFS_NXTBLK
+ 	 }, 
+ 	{
+ 	 .name   = "TF Firmware (overwrites U-Boot and Kernel!)",
+ 	 .offset = 0x00030000,
+ 	 .size   = 0x00790000,
+ 	 }, 
+ 	{
+ 	 .name   = "TF Settings",
+ 	 .offset = 0x007c0000,
+ 	 .size   = 0x00020000,
+ 	 },
+ 	{
+ 	 .name   = "TF Defaults",
+ 	 .offset = 0x007e0000,
+ 	 .size   = 0x00020000,
+ 	 } 
+ };
+ 
+ static struct mtd_partition *parsed_parts;
+ static const char *probes[] = { "cmdlinepart", NULL };
+ 
+ int __init init_tf7700_flash(void)
+ {
+ 	int nr_parts = 0;
+ 
+ 	flash_map.phys = FLASH_ADDR;
+ 	flash_map.size = FLASH_SIZE;
+ 	flash_map.virt =
+ 	    (unsigned long *)ioremap(flash_map.phys, flash_map.size);
+ 	if (flash_map.virt == 0) {
+ 		printk(KERN_ERR "Failed to ioremap onboard Flash\n");
+ 	}
+ 	else
+ 	{
+ #ifndef CONFIG_MTD_COMPLEX_MAPPINGS
+ 		simple_map_init(&flash_map);
+ #endif
+ 		flash_mtd = do_map_probe("cfi_probe", &flash_map);
+ 		if (flash_mtd != NULL) {
+ 			flash_mtd->owner = THIS_MODULE;
+ #ifdef CONFIG_MTD_CMDLINE_PARTS
+ 			nr_parts =
+ 			    parse_mtd_partitions(flash_mtd, probes,
+ 						 &parsed_parts, 0);
+ #endif
+ 			if (nr_parts <= 0)
+ 				add_mtd_partitions(flash_mtd,
+ 						   flash_partitions,
+ 						   ARRAY_SIZE
+ 						   (flash_partitions));
+ 			else
+ 				add_mtd_partitions(flash_mtd, parsed_parts,
+ 						   nr_parts);
+ 		} else {
+ 			iounmap((void *)flash_map.virt);
+ 		}
+ 	}
+ 
+ 	return -ENXIO;
+ }
+ 
+ static void __exit cleanup_tf7700_flash(void)
+ {
+ 	if (flash_mtd) {
+ 		del_mtd_partitions(flash_mtd);
+ 		map_destroy(flash_mtd);
+ 	}
+ 	if (flash_map.virt != 0) {
+ 		iounmap((void *)flash_map.virt);
+ 		flash_map.virt = 0;
+ 	}
+ }
+ 
+ module_init(init_tf7700_flash);
+ module_exit(cleanup_tf7700_flash);
